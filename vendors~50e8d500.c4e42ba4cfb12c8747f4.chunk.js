(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~50e8d500"],{

/***/ "0esZ":
/*!***********************************************************************************************!*\
  !*** ./node_modules/aurelia-route-recognizer/dist/native-modules/aurelia-route-recognizer.js ***!
  \***********************************************************************************************/
/*! exports provided: State, StaticSegment, DynamicSegment, StarSegment, EpsilonSegment, RouteRecognizer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"State\", function() { return State; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StaticSegment\", function() { return StaticSegment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DynamicSegment\", function() { return DynamicSegment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StarSegment\", function() { return StarSegment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EpsilonSegment\", function() { return EpsilonSegment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouteRecognizer\", function() { return RouteRecognizer; });\n/* harmony import */ var aurelia_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-path */ \"iD3O\");\n\n\n\n\nvar State = function () {\n  function State(charSpec) {\n    \n\n    this.charSpec = charSpec;\n    this.nextStates = [];\n  }\n\n  State.prototype.get = function get(charSpec) {\n    for (var _iterator = this.nextStates, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var child = _ref;\n\n      var isEqual = child.charSpec.validChars === charSpec.validChars && child.charSpec.invalidChars === charSpec.invalidChars;\n\n      if (isEqual) {\n        return child;\n      }\n    }\n\n    return undefined;\n  };\n\n  State.prototype.put = function put(charSpec) {\n    var state = this.get(charSpec);\n\n    if (state) {\n      return state;\n    }\n\n    state = new State(charSpec);\n\n    this.nextStates.push(state);\n\n    if (charSpec.repeat) {\n      state.nextStates.push(state);\n    }\n\n    return state;\n  };\n\n  State.prototype.match = function match(ch) {\n    var nextStates = this.nextStates;\n    var results = [];\n\n    for (var i = 0, l = nextStates.length; i < l; i++) {\n      var child = nextStates[i];\n      var charSpec = child.charSpec;\n\n      if (charSpec.validChars !== undefined) {\n        if (charSpec.validChars.indexOf(ch) !== -1) {\n          results.push(child);\n        }\n      } else if (charSpec.invalidChars !== undefined) {\n        if (charSpec.invalidChars.indexOf(ch) === -1) {\n          results.push(child);\n        }\n      }\n    }\n\n    return results;\n  };\n\n  return State;\n}();\n\nvar specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\'];\n\nvar escapeRegex = new RegExp('(\\\\' + specials.join('|\\\\') + ')', 'g');\n\nvar StaticSegment = function () {\n  function StaticSegment(string, caseSensitive) {\n    \n\n    this.string = string;\n    this.caseSensitive = caseSensitive;\n  }\n\n  StaticSegment.prototype.eachChar = function eachChar(callback) {\n    var s = this.string;\n    for (var i = 0, ii = s.length; i < ii; ++i) {\n      var ch = s[i];\n      callback({ validChars: this.caseSensitive ? ch : ch.toUpperCase() + ch.toLowerCase() });\n    }\n  };\n\n  StaticSegment.prototype.regex = function regex() {\n    return this.string.replace(escapeRegex, '\\\\$1');\n  };\n\n  StaticSegment.prototype.generate = function generate() {\n    return this.string;\n  };\n\n  return StaticSegment;\n}();\n\nvar DynamicSegment = function () {\n  function DynamicSegment(name, optional) {\n    \n\n    this.name = name;\n    this.optional = optional;\n  }\n\n  DynamicSegment.prototype.eachChar = function eachChar(callback) {\n    callback({ invalidChars: '/', repeat: true });\n  };\n\n  DynamicSegment.prototype.regex = function regex() {\n    return '([^/]+)';\n  };\n\n  DynamicSegment.prototype.generate = function generate(params, consumed) {\n    consumed[this.name] = true;\n    return params[this.name];\n  };\n\n  return DynamicSegment;\n}();\n\nvar StarSegment = function () {\n  function StarSegment(name) {\n    \n\n    this.name = name;\n  }\n\n  StarSegment.prototype.eachChar = function eachChar(callback) {\n    callback({ invalidChars: '', repeat: true });\n  };\n\n  StarSegment.prototype.regex = function regex() {\n    return '(.+)';\n  };\n\n  StarSegment.prototype.generate = function generate(params, consumed) {\n    consumed[this.name] = true;\n    return params[this.name];\n  };\n\n  return StarSegment;\n}();\n\nvar EpsilonSegment = function () {\n  function EpsilonSegment() {\n    \n  }\n\n  EpsilonSegment.prototype.eachChar = function eachChar() {};\n\n  EpsilonSegment.prototype.regex = function regex() {\n    return '';\n  };\n\n  EpsilonSegment.prototype.generate = function generate() {\n    return '';\n  };\n\n  return EpsilonSegment;\n}();\n\nvar RouteRecognizer = function () {\n  function RouteRecognizer() {\n    \n\n    this.rootState = new State();\n    this.names = {};\n    this.routes = new Map();\n  }\n\n  RouteRecognizer.prototype.add = function add(route) {\n    var _this = this;\n\n    if (Array.isArray(route)) {\n      route.forEach(function (r) {\n        return _this.add(r);\n      });\n      return undefined;\n    }\n\n    var currentState = this.rootState;\n    var skippableStates = [];\n    var regex = '^';\n    var types = { statics: 0, dynamics: 0, stars: 0 };\n    var names = [];\n    var routeName = route.handler.name;\n    var isEmpty = true;\n    var segments = parse(route.path, names, types, route.caseSensitive);\n\n    for (var i = 0, ii = segments.length; i < ii; i++) {\n      var segment = segments[i];\n      if (segment instanceof EpsilonSegment) {\n        continue;\n      }\n\n      var _addSegment = addSegment(currentState, segment),\n          firstState = _addSegment[0],\n          nextState = _addSegment[1];\n\n      for (var j = 0, jj = skippableStates.length; j < jj; j++) {\n        skippableStates[j].nextStates.push(firstState);\n      }\n\n      if (segment.optional) {\n        skippableStates.push(nextState);\n        regex += '(?:/' + segment.regex() + ')?';\n      } else {\n        currentState = nextState;\n        regex += '/' + segment.regex();\n        skippableStates.length = 0;\n        isEmpty = false;\n      }\n    }\n\n    if (isEmpty) {\n      currentState = currentState.put({ validChars: '/' });\n      regex += '/?';\n    }\n\n    var handlers = [{ handler: route.handler, names: names }];\n\n    this.routes.set(route.handler, { segments: segments, handlers: handlers });\n    if (routeName) {\n      var routeNames = Array.isArray(routeName) ? routeName : [routeName];\n      for (var _i2 = 0; _i2 < routeNames.length; _i2++) {\n        if (!(routeNames[_i2] in this.names)) {\n          this.names[routeNames[_i2]] = { segments: segments, handlers: handlers };\n        }\n      }\n    }\n\n    for (var _i3 = 0; _i3 < skippableStates.length; _i3++) {\n      var state = skippableStates[_i3];\n      state.handlers = handlers;\n      state.regex = new RegExp(regex + '$', route.caseSensitive ? '' : 'i');\n      state.types = types;\n    }\n\n    currentState.handlers = handlers;\n    currentState.regex = new RegExp(regex + '$', route.caseSensitive ? '' : 'i');\n    currentState.types = types;\n\n    return currentState;\n  };\n\n  RouteRecognizer.prototype.getRoute = function getRoute(nameOrRoute) {\n    return typeof nameOrRoute === 'string' ? this.names[nameOrRoute] : this.routes.get(nameOrRoute);\n  };\n\n  RouteRecognizer.prototype.handlersFor = function handlersFor(nameOrRoute) {\n    var route = this.getRoute(nameOrRoute);\n    if (!route) {\n      throw new Error('There is no route named ' + nameOrRoute);\n    }\n\n    return [].concat(route.handlers);\n  };\n\n  RouteRecognizer.prototype.hasRoute = function hasRoute(nameOrRoute) {\n    return !!this.getRoute(nameOrRoute);\n  };\n\n  RouteRecognizer.prototype.generate = function generate(nameOrRoute, params) {\n    var route = this.getRoute(nameOrRoute);\n    if (!route) {\n      throw new Error('There is no route named ' + nameOrRoute);\n    }\n\n    var handler = route.handlers[0].handler;\n    if (handler.generationUsesHref) {\n      return handler.href;\n    }\n\n    var routeParams = Object.assign({}, params);\n    var segments = route.segments;\n    var consumed = {};\n    var output = '';\n\n    for (var i = 0, l = segments.length; i < l; i++) {\n      var segment = segments[i];\n\n      if (segment instanceof EpsilonSegment) {\n        continue;\n      }\n\n      var segmentValue = segment.generate(routeParams, consumed);\n      if (segmentValue === null || segmentValue === undefined) {\n        if (!segment.optional) {\n          throw new Error('A value is required for route parameter \\'' + segment.name + '\\' in route \\'' + nameOrRoute + '\\'.');\n        }\n      } else {\n        output += '/';\n        output += segmentValue;\n      }\n    }\n\n    if (output.charAt(0) !== '/') {\n      output = '/' + output;\n    }\n\n    for (var param in consumed) {\n      delete routeParams[param];\n    }\n\n    var queryString = Object(aurelia_path__WEBPACK_IMPORTED_MODULE_0__[\"buildQueryString\"])(routeParams);\n    output += queryString ? '?' + queryString : '';\n\n    return output;\n  };\n\n  RouteRecognizer.prototype.recognize = function recognize(path) {\n    var states = [this.rootState];\n    var queryParams = {};\n    var isSlashDropped = false;\n    var normalizedPath = path;\n\n    var queryStart = normalizedPath.indexOf('?');\n    if (queryStart !== -1) {\n      var queryString = normalizedPath.substr(queryStart + 1, normalizedPath.length);\n      normalizedPath = normalizedPath.substr(0, queryStart);\n      queryParams = Object(aurelia_path__WEBPACK_IMPORTED_MODULE_0__[\"parseQueryString\"])(queryString);\n    }\n\n    normalizedPath = decodeURI(normalizedPath);\n\n    if (normalizedPath.charAt(0) !== '/') {\n      normalizedPath = '/' + normalizedPath;\n    }\n\n    var pathLen = normalizedPath.length;\n    if (pathLen > 1 && normalizedPath.charAt(pathLen - 1) === '/') {\n      normalizedPath = normalizedPath.substr(0, pathLen - 1);\n      isSlashDropped = true;\n    }\n\n    for (var i = 0, l = normalizedPath.length; i < l; i++) {\n      states = recognizeChar(states, normalizedPath.charAt(i));\n      if (!states.length) {\n        break;\n      }\n    }\n\n    var solutions = [];\n    for (var _i4 = 0, _l = states.length; _i4 < _l; _i4++) {\n      if (states[_i4].handlers) {\n        solutions.push(states[_i4]);\n      }\n    }\n\n    states = sortSolutions(solutions);\n\n    var state = solutions[0];\n    if (state && state.handlers) {\n      if (isSlashDropped && state.regex.source.slice(-5) === '(.+)$') {\n        normalizedPath = normalizedPath + '/';\n      }\n\n      return findHandler(state, normalizedPath, queryParams);\n    }\n  };\n\n  return RouteRecognizer;\n}();\n\nvar RecognizeResults = function RecognizeResults(queryParams) {\n  \n\n  this.splice = Array.prototype.splice;\n  this.slice = Array.prototype.slice;\n  this.push = Array.prototype.push;\n  this.length = 0;\n  this.queryParams = queryParams || {};\n};\n\nfunction parse(route, names, types, caseSensitive) {\n  var normalizedRoute = route;\n  if (route.charAt(0) === '/') {\n    normalizedRoute = route.substr(1);\n  }\n\n  var results = [];\n\n  var splitRoute = normalizedRoute.split('/');\n  for (var i = 0, ii = splitRoute.length; i < ii; ++i) {\n    var segment = splitRoute[i];\n\n    var match = segment.match(/^:([^?]+)(\\?)?$/);\n    if (match) {\n      var _match = match,\n          _name = _match[1],\n          optional = _match[2];\n\n      if (_name.indexOf('=') !== -1) {\n        throw new Error('Parameter ' + _name + ' in route ' + route + ' has a default value, which is not supported.');\n      }\n      results.push(new DynamicSegment(_name, !!optional));\n      names.push(_name);\n      types.dynamics++;\n      continue;\n    }\n\n    match = segment.match(/^\\*(.+)$/);\n    if (match) {\n      results.push(new StarSegment(match[1]));\n      names.push(match[1]);\n      types.stars++;\n    } else if (segment === '') {\n      results.push(new EpsilonSegment());\n    } else {\n      results.push(new StaticSegment(segment, caseSensitive));\n      types.statics++;\n    }\n  }\n\n  return results;\n}\n\nfunction sortSolutions(states) {\n  return states.sort(function (a, b) {\n    if (a.types.stars !== b.types.stars) {\n      return a.types.stars - b.types.stars;\n    }\n\n    if (a.types.stars) {\n      if (a.types.statics !== b.types.statics) {\n        return b.types.statics - a.types.statics;\n      }\n      if (a.types.dynamics !== b.types.dynamics) {\n        return b.types.dynamics - a.types.dynamics;\n      }\n    }\n\n    if (a.types.dynamics !== b.types.dynamics) {\n      return a.types.dynamics - b.types.dynamics;\n    }\n\n    if (a.types.statics !== b.types.statics) {\n      return b.types.statics - a.types.statics;\n    }\n\n    return 0;\n  });\n}\n\nfunction recognizeChar(states, ch) {\n  var nextStates = [];\n\n  for (var i = 0, l = states.length; i < l; i++) {\n    var state = states[i];\n    nextStates.push.apply(nextStates, state.match(ch));\n  }\n\n  return nextStates;\n}\n\nfunction findHandler(state, path, queryParams) {\n  var handlers = state.handlers;\n  var regex = state.regex;\n  var captures = path.match(regex);\n  var currentCapture = 1;\n  var result = new RecognizeResults(queryParams);\n\n  for (var i = 0, l = handlers.length; i < l; i++) {\n    var _handler = handlers[i];\n    var _names = _handler.names;\n    var _params = {};\n\n    for (var j = 0, m = _names.length; j < m; j++) {\n      _params[_names[j]] = captures[currentCapture++];\n    }\n\n    result.push({ handler: _handler.handler, params: _params, isDynamic: !!_names.length });\n  }\n\n  return result;\n}\n\nfunction addSegment(currentState, segment) {\n  var firstState = currentState.put({ validChars: '/' });\n  var nextState = firstState;\n  segment.eachChar(function (ch) {\n    nextState = nextState.put(ch);\n  });\n\n  return [firstState, nextState];\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMGVzWi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLXJvdXRlLXJlY29nbml6ZXIvZGlzdC9uYXRpdmUtbW9kdWxlcy9hdXJlbGlhLXJvdXRlLXJlY29nbml6ZXIuanM/ZDFlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuaW1wb3J0IHsgYnVpbGRRdWVyeVN0cmluZywgcGFyc2VRdWVyeVN0cmluZyB9IGZyb20gJ2F1cmVsaWEtcGF0aCc7XG5cbmV4cG9ydCB2YXIgU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0YXRlKGNoYXJTcGVjKSB7XG4gICAgXG5cbiAgICB0aGlzLmNoYXJTcGVjID0gY2hhclNwZWM7XG4gICAgdGhpcy5uZXh0U3RhdGVzID0gW107XG4gIH1cblxuICBTdGF0ZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KGNoYXJTcGVjKSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdGhpcy5uZXh0U3RhdGVzLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgdmFyIF9yZWY7XG5cbiAgICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChfaS5kb25lKSBicmVhaztcbiAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGQgPSBfcmVmO1xuXG4gICAgICB2YXIgaXNFcXVhbCA9IGNoaWxkLmNoYXJTcGVjLnZhbGlkQ2hhcnMgPT09IGNoYXJTcGVjLnZhbGlkQ2hhcnMgJiYgY2hpbGQuY2hhclNwZWMuaW52YWxpZENoYXJzID09PSBjaGFyU3BlYy5pbnZhbGlkQ2hhcnM7XG5cbiAgICAgIGlmIChpc0VxdWFsKSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIFN0YXRlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiBwdXQoY2hhclNwZWMpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLmdldChjaGFyU3BlYyk7XG5cbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICBzdGF0ZSA9IG5ldyBTdGF0ZShjaGFyU3BlYyk7XG5cbiAgICB0aGlzLm5leHRTdGF0ZXMucHVzaChzdGF0ZSk7XG5cbiAgICBpZiAoY2hhclNwZWMucmVwZWF0KSB7XG4gICAgICBzdGF0ZS5uZXh0U3RhdGVzLnB1c2goc3RhdGUpO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcblxuICBTdGF0ZS5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChjaCkge1xuICAgIHZhciBuZXh0U3RhdGVzID0gdGhpcy5uZXh0U3RhdGVzO1xuICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5leHRTdGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBuZXh0U3RhdGVzW2ldO1xuICAgICAgdmFyIGNoYXJTcGVjID0gY2hpbGQuY2hhclNwZWM7XG5cbiAgICAgIGlmIChjaGFyU3BlYy52YWxpZENoYXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGNoYXJTcGVjLnZhbGlkQ2hhcnMuaW5kZXhPZihjaCkgIT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGFyU3BlYy5pbnZhbGlkQ2hhcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoY2hhclNwZWMuaW52YWxpZENoYXJzLmluZGV4T2YoY2gpID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICByZXR1cm4gU3RhdGU7XG59KCk7XG5cbnZhciBzcGVjaWFscyA9IFsnLycsICcuJywgJyonLCAnKycsICc/JywgJ3wnLCAnKCcsICcpJywgJ1snLCAnXScsICd7JywgJ30nLCAnXFxcXCddO1xuXG52YXIgZXNjYXBlUmVnZXggPSBuZXcgUmVnRXhwKCcoXFxcXCcgKyBzcGVjaWFscy5qb2luKCd8XFxcXCcpICsgJyknLCAnZycpO1xuXG5leHBvcnQgdmFyIFN0YXRpY1NlZ21lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0YXRpY1NlZ21lbnQoc3RyaW5nLCBjYXNlU2Vuc2l0aXZlKSB7XG4gICAgXG5cbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLmNhc2VTZW5zaXRpdmUgPSBjYXNlU2Vuc2l0aXZlO1xuICB9XG5cbiAgU3RhdGljU2VnbWVudC5wcm90b3R5cGUuZWFjaENoYXIgPSBmdW5jdGlvbiBlYWNoQ2hhcihjYWxsYmFjaykge1xuICAgIHZhciBzID0gdGhpcy5zdHJpbmc7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgY2ggPSBzW2ldO1xuICAgICAgY2FsbGJhY2soeyB2YWxpZENoYXJzOiB0aGlzLmNhc2VTZW5zaXRpdmUgPyBjaCA6IGNoLnRvVXBwZXJDYXNlKCkgKyBjaC50b0xvd2VyQ2FzZSgpIH0pO1xuICAgIH1cbiAgfTtcblxuICBTdGF0aWNTZWdtZW50LnByb3RvdHlwZS5yZWdleCA9IGZ1bmN0aW9uIHJlZ2V4KCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZy5yZXBsYWNlKGVzY2FwZVJlZ2V4LCAnXFxcXCQxJyk7XG4gIH07XG5cbiAgU3RhdGljU2VnbWVudC5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmc7XG4gIH07XG5cbiAgcmV0dXJuIFN0YXRpY1NlZ21lbnQ7XG59KCk7XG5cbmV4cG9ydCB2YXIgRHluYW1pY1NlZ21lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIER5bmFtaWNTZWdtZW50KG5hbWUsIG9wdGlvbmFsKSB7XG4gICAgXG5cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgfVxuXG4gIER5bmFtaWNTZWdtZW50LnByb3RvdHlwZS5lYWNoQ2hhciA9IGZ1bmN0aW9uIGVhY2hDaGFyKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soeyBpbnZhbGlkQ2hhcnM6ICcvJywgcmVwZWF0OiB0cnVlIH0pO1xuICB9O1xuXG4gIER5bmFtaWNTZWdtZW50LnByb3RvdHlwZS5yZWdleCA9IGZ1bmN0aW9uIHJlZ2V4KCkge1xuICAgIHJldHVybiAnKFteL10rKSc7XG4gIH07XG5cbiAgRHluYW1pY1NlZ21lbnQucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUocGFyYW1zLCBjb25zdW1lZCkge1xuICAgIGNvbnN1bWVkW3RoaXMubmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiBwYXJhbXNbdGhpcy5uYW1lXTtcbiAgfTtcblxuICByZXR1cm4gRHluYW1pY1NlZ21lbnQ7XG59KCk7XG5cbmV4cG9ydCB2YXIgU3RhclNlZ21lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0YXJTZWdtZW50KG5hbWUpIHtcbiAgICBcblxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cblxuICBTdGFyU2VnbWVudC5wcm90b3R5cGUuZWFjaENoYXIgPSBmdW5jdGlvbiBlYWNoQ2hhcihjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHsgaW52YWxpZENoYXJzOiAnJywgcmVwZWF0OiB0cnVlIH0pO1xuICB9O1xuXG4gIFN0YXJTZWdtZW50LnByb3RvdHlwZS5yZWdleCA9IGZ1bmN0aW9uIHJlZ2V4KCkge1xuICAgIHJldHVybiAnKC4rKSc7XG4gIH07XG5cbiAgU3RhclNlZ21lbnQucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUocGFyYW1zLCBjb25zdW1lZCkge1xuICAgIGNvbnN1bWVkW3RoaXMubmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiBwYXJhbXNbdGhpcy5uYW1lXTtcbiAgfTtcblxuICByZXR1cm4gU3RhclNlZ21lbnQ7XG59KCk7XG5cbmV4cG9ydCB2YXIgRXBzaWxvblNlZ21lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVwc2lsb25TZWdtZW50KCkge1xuICAgIFxuICB9XG5cbiAgRXBzaWxvblNlZ21lbnQucHJvdG90eXBlLmVhY2hDaGFyID0gZnVuY3Rpb24gZWFjaENoYXIoKSB7fTtcblxuICBFcHNpbG9uU2VnbWVudC5wcm90b3R5cGUucmVnZXggPSBmdW5jdGlvbiByZWdleCgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgRXBzaWxvblNlZ21lbnQucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIHJldHVybiBFcHNpbG9uU2VnbWVudDtcbn0oKTtcblxuZXhwb3J0IHZhciBSb3V0ZVJlY29nbml6ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJvdXRlUmVjb2duaXplcigpIHtcbiAgICBcblxuICAgIHRoaXMucm9vdFN0YXRlID0gbmV3IFN0YXRlKCk7XG4gICAgdGhpcy5uYW1lcyA9IHt9O1xuICAgIHRoaXMucm91dGVzID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocm91dGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocm91dGUpKSB7XG4gICAgICByb3V0ZS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5hZGQocik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHRoaXMucm9vdFN0YXRlO1xuICAgIHZhciBza2lwcGFibGVTdGF0ZXMgPSBbXTtcbiAgICB2YXIgcmVnZXggPSAnXic7XG4gICAgdmFyIHR5cGVzID0geyBzdGF0aWNzOiAwLCBkeW5hbWljczogMCwgc3RhcnM6IDAgfTtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICB2YXIgcm91dGVOYW1lID0gcm91dGUuaGFuZGxlci5uYW1lO1xuICAgIHZhciBpc0VtcHR5ID0gdHJ1ZTtcbiAgICB2YXIgc2VnbWVudHMgPSBwYXJzZShyb3V0ZS5wYXRoLCBuYW1lcywgdHlwZXMsIHJvdXRlLmNhc2VTZW5zaXRpdmUpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgIGlmIChzZWdtZW50IGluc3RhbmNlb2YgRXBzaWxvblNlZ21lbnQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBfYWRkU2VnbWVudCA9IGFkZFNlZ21lbnQoY3VycmVudFN0YXRlLCBzZWdtZW50KSxcbiAgICAgICAgICBmaXJzdFN0YXRlID0gX2FkZFNlZ21lbnRbMF0sXG4gICAgICAgICAgbmV4dFN0YXRlID0gX2FkZFNlZ21lbnRbMV07XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IHNraXBwYWJsZVN0YXRlcy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgIHNraXBwYWJsZVN0YXRlc1tqXS5uZXh0U3RhdGVzLnB1c2goZmlyc3RTdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWdtZW50Lm9wdGlvbmFsKSB7XG4gICAgICAgIHNraXBwYWJsZVN0YXRlcy5wdXNoKG5leHRTdGF0ZSk7XG4gICAgICAgIHJlZ2V4ICs9ICcoPzovJyArIHNlZ21lbnQucmVnZXgoKSArICcpPyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50U3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICAgIHJlZ2V4ICs9ICcvJyArIHNlZ21lbnQucmVnZXgoKTtcbiAgICAgICAgc2tpcHBhYmxlU3RhdGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIGlzRW1wdHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgY3VycmVudFN0YXRlID0gY3VycmVudFN0YXRlLnB1dCh7IHZhbGlkQ2hhcnM6ICcvJyB9KTtcbiAgICAgIHJlZ2V4ICs9ICcvPyc7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZXJzID0gW3sgaGFuZGxlcjogcm91dGUuaGFuZGxlciwgbmFtZXM6IG5hbWVzIH1dO1xuXG4gICAgdGhpcy5yb3V0ZXMuc2V0KHJvdXRlLmhhbmRsZXIsIHsgc2VnbWVudHM6IHNlZ21lbnRzLCBoYW5kbGVyczogaGFuZGxlcnMgfSk7XG4gICAgaWYgKHJvdXRlTmFtZSkge1xuICAgICAgdmFyIHJvdXRlTmFtZXMgPSBBcnJheS5pc0FycmF5KHJvdXRlTmFtZSkgPyByb3V0ZU5hbWUgOiBbcm91dGVOYW1lXTtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHJvdXRlTmFtZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICBpZiAoIShyb3V0ZU5hbWVzW19pMl0gaW4gdGhpcy5uYW1lcykpIHtcbiAgICAgICAgICB0aGlzLm5hbWVzW3JvdXRlTmFtZXNbX2kyXV0gPSB7IHNlZ21lbnRzOiBzZWdtZW50cywgaGFuZGxlcnM6IGhhbmRsZXJzIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBza2lwcGFibGVTdGF0ZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgdmFyIHN0YXRlID0gc2tpcHBhYmxlU3RhdGVzW19pM107XG4gICAgICBzdGF0ZS5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgICAgc3RhdGUucmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4ICsgJyQnLCByb3V0ZS5jYXNlU2Vuc2l0aXZlID8gJycgOiAnaScpO1xuICAgICAgc3RhdGUudHlwZXMgPSB0eXBlcztcbiAgICB9XG5cbiAgICBjdXJyZW50U3RhdGUuaGFuZGxlcnMgPSBoYW5kbGVycztcbiAgICBjdXJyZW50U3RhdGUucmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4ICsgJyQnLCByb3V0ZS5jYXNlU2Vuc2l0aXZlID8gJycgOiAnaScpO1xuICAgIGN1cnJlbnRTdGF0ZS50eXBlcyA9IHR5cGVzO1xuXG4gICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcbiAgfTtcblxuICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLmdldFJvdXRlID0gZnVuY3Rpb24gZ2V0Um91dGUobmFtZU9yUm91dGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIG5hbWVPclJvdXRlID09PSAnc3RyaW5nJyA/IHRoaXMubmFtZXNbbmFtZU9yUm91dGVdIDogdGhpcy5yb3V0ZXMuZ2V0KG5hbWVPclJvdXRlKTtcbiAgfTtcblxuICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLmhhbmRsZXJzRm9yID0gZnVuY3Rpb24gaGFuZGxlcnNGb3IobmFtZU9yUm91dGUpIHtcbiAgICB2YXIgcm91dGUgPSB0aGlzLmdldFJvdXRlKG5hbWVPclJvdXRlKTtcbiAgICBpZiAoIXJvdXRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIHJvdXRlIG5hbWVkICcgKyBuYW1lT3JSb3V0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdLmNvbmNhdChyb3V0ZS5oYW5kbGVycyk7XG4gIH07XG5cbiAgUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5oYXNSb3V0ZSA9IGZ1bmN0aW9uIGhhc1JvdXRlKG5hbWVPclJvdXRlKSB7XG4gICAgcmV0dXJuICEhdGhpcy5nZXRSb3V0ZShuYW1lT3JSb3V0ZSk7XG4gIH07XG5cbiAgUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlKG5hbWVPclJvdXRlLCBwYXJhbXMpIHtcbiAgICB2YXIgcm91dGUgPSB0aGlzLmdldFJvdXRlKG5hbWVPclJvdXRlKTtcbiAgICBpZiAoIXJvdXRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIHJvdXRlIG5hbWVkICcgKyBuYW1lT3JSb3V0ZSk7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZXIgPSByb3V0ZS5oYW5kbGVyc1swXS5oYW5kbGVyO1xuICAgIGlmIChoYW5kbGVyLmdlbmVyYXRpb25Vc2VzSHJlZikge1xuICAgICAgcmV0dXJuIGhhbmRsZXIuaHJlZjtcbiAgICB9XG5cbiAgICB2YXIgcm91dGVQYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpO1xuICAgIHZhciBzZWdtZW50cyA9IHJvdXRlLnNlZ21lbnRzO1xuICAgIHZhciBjb25zdW1lZCA9IHt9O1xuICAgIHZhciBvdXRwdXQgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXG4gICAgICBpZiAoc2VnbWVudCBpbnN0YW5jZW9mIEVwc2lsb25TZWdtZW50KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VnbWVudFZhbHVlID0gc2VnbWVudC5nZW5lcmF0ZShyb3V0ZVBhcmFtcywgY29uc3VtZWQpO1xuICAgICAgaWYgKHNlZ21lbnRWYWx1ZSA9PT0gbnVsbCB8fCBzZWdtZW50VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIXNlZ21lbnQub3B0aW9uYWwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgdmFsdWUgaXMgcmVxdWlyZWQgZm9yIHJvdXRlIHBhcmFtZXRlciBcXCcnICsgc2VnbWVudC5uYW1lICsgJ1xcJyBpbiByb3V0ZSBcXCcnICsgbmFtZU9yUm91dGUgKyAnXFwnLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQgKz0gJy8nO1xuICAgICAgICBvdXRwdXQgKz0gc2VnbWVudFZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvdXRwdXQuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgIG91dHB1dCA9ICcvJyArIG91dHB1dDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwYXJhbSBpbiBjb25zdW1lZCkge1xuICAgICAgZGVsZXRlIHJvdXRlUGFyYW1zW3BhcmFtXTtcbiAgICB9XG5cbiAgICB2YXIgcXVlcnlTdHJpbmcgPSBidWlsZFF1ZXJ5U3RyaW5nKHJvdXRlUGFyYW1zKTtcbiAgICBvdXRwdXQgKz0gcXVlcnlTdHJpbmcgPyAnPycgKyBxdWVyeVN0cmluZyA6ICcnO1xuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLnJlY29nbml6ZSA9IGZ1bmN0aW9uIHJlY29nbml6ZShwYXRoKSB7XG4gICAgdmFyIHN0YXRlcyA9IFt0aGlzLnJvb3RTdGF0ZV07XG4gICAgdmFyIHF1ZXJ5UGFyYW1zID0ge307XG4gICAgdmFyIGlzU2xhc2hEcm9wcGVkID0gZmFsc2U7XG4gICAgdmFyIG5vcm1hbGl6ZWRQYXRoID0gcGF0aDtcblxuICAgIHZhciBxdWVyeVN0YXJ0ID0gbm9ybWFsaXplZFBhdGguaW5kZXhPZignPycpO1xuICAgIGlmIChxdWVyeVN0YXJ0ICE9PSAtMSkge1xuICAgICAgdmFyIHF1ZXJ5U3RyaW5nID0gbm9ybWFsaXplZFBhdGguc3Vic3RyKHF1ZXJ5U3RhcnQgKyAxLCBub3JtYWxpemVkUGF0aC5sZW5ndGgpO1xuICAgICAgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVkUGF0aC5zdWJzdHIoMCwgcXVlcnlTdGFydCk7XG4gICAgICBxdWVyeVBhcmFtcyA9IHBhcnNlUXVlcnlTdHJpbmcocXVlcnlTdHJpbmcpO1xuICAgIH1cblxuICAgIG5vcm1hbGl6ZWRQYXRoID0gZGVjb2RlVVJJKG5vcm1hbGl6ZWRQYXRoKTtcblxuICAgIGlmIChub3JtYWxpemVkUGF0aC5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgbm9ybWFsaXplZFBhdGggPSAnLycgKyBub3JtYWxpemVkUGF0aDtcbiAgICB9XG5cbiAgICB2YXIgcGF0aExlbiA9IG5vcm1hbGl6ZWRQYXRoLmxlbmd0aDtcbiAgICBpZiAocGF0aExlbiA+IDEgJiYgbm9ybWFsaXplZFBhdGguY2hhckF0KHBhdGhMZW4gLSAxKSA9PT0gJy8nKSB7XG4gICAgICBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZWRQYXRoLnN1YnN0cigwLCBwYXRoTGVuIC0gMSk7XG4gICAgICBpc1NsYXNoRHJvcHBlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub3JtYWxpemVkUGF0aC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHN0YXRlcyA9IHJlY29nbml6ZUNoYXIoc3RhdGVzLCBub3JtYWxpemVkUGF0aC5jaGFyQXQoaSkpO1xuICAgICAgaWYgKCFzdGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzb2x1dGlvbnMgPSBbXTtcbiAgICBmb3IgKHZhciBfaTQgPSAwLCBfbCA9IHN0YXRlcy5sZW5ndGg7IF9pNCA8IF9sOyBfaTQrKykge1xuICAgICAgaWYgKHN0YXRlc1tfaTRdLmhhbmRsZXJzKSB7XG4gICAgICAgIHNvbHV0aW9ucy5wdXNoKHN0YXRlc1tfaTRdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZXMgPSBzb3J0U29sdXRpb25zKHNvbHV0aW9ucyk7XG5cbiAgICB2YXIgc3RhdGUgPSBzb2x1dGlvbnNbMF07XG4gICAgaWYgKHN0YXRlICYmIHN0YXRlLmhhbmRsZXJzKSB7XG4gICAgICBpZiAoaXNTbGFzaERyb3BwZWQgJiYgc3RhdGUucmVnZXguc291cmNlLnNsaWNlKC01KSA9PT0gJyguKykkJykge1xuICAgICAgICBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZWRQYXRoICsgJy8nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmluZEhhbmRsZXIoc3RhdGUsIG5vcm1hbGl6ZWRQYXRoLCBxdWVyeVBhcmFtcyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBSb3V0ZVJlY29nbml6ZXI7XG59KCk7XG5cbnZhciBSZWNvZ25pemVSZXN1bHRzID0gZnVuY3Rpb24gUmVjb2duaXplUmVzdWx0cyhxdWVyeVBhcmFtcykge1xuICBcblxuICB0aGlzLnNwbGljZSA9IEFycmF5LnByb3RvdHlwZS5zcGxpY2U7XG4gIHRoaXMuc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gIHRoaXMucHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucXVlcnlQYXJhbXMgPSBxdWVyeVBhcmFtcyB8fCB7fTtcbn07XG5cbmZ1bmN0aW9uIHBhcnNlKHJvdXRlLCBuYW1lcywgdHlwZXMsIGNhc2VTZW5zaXRpdmUpIHtcbiAgdmFyIG5vcm1hbGl6ZWRSb3V0ZSA9IHJvdXRlO1xuICBpZiAocm91dGUuY2hhckF0KDApID09PSAnLycpIHtcbiAgICBub3JtYWxpemVkUm91dGUgPSByb3V0ZS5zdWJzdHIoMSk7XG4gIH1cblxuICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gIHZhciBzcGxpdFJvdXRlID0gbm9ybWFsaXplZFJvdXRlLnNwbGl0KCcvJyk7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IHNwbGl0Um91dGUubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHZhciBzZWdtZW50ID0gc3BsaXRSb3V0ZVtpXTtcblxuICAgIHZhciBtYXRjaCA9IHNlZ21lbnQubWF0Y2goL146KFteP10rKShcXD8pPyQvKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciBfbWF0Y2ggPSBtYXRjaCxcbiAgICAgICAgICBfbmFtZSA9IF9tYXRjaFsxXSxcbiAgICAgICAgICBvcHRpb25hbCA9IF9tYXRjaFsyXTtcblxuICAgICAgaWYgKF9uYW1lLmluZGV4T2YoJz0nKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXIgJyArIF9uYW1lICsgJyBpbiByb3V0ZSAnICsgcm91dGUgKyAnIGhhcyBhIGRlZmF1bHQgdmFsdWUsIHdoaWNoIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICB9XG4gICAgICByZXN1bHRzLnB1c2gobmV3IER5bmFtaWNTZWdtZW50KF9uYW1lLCAhIW9wdGlvbmFsKSk7XG4gICAgICBuYW1lcy5wdXNoKF9uYW1lKTtcbiAgICAgIHR5cGVzLmR5bmFtaWNzKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBtYXRjaCA9IHNlZ21lbnQubWF0Y2goL15cXCooLispJC8pO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgcmVzdWx0cy5wdXNoKG5ldyBTdGFyU2VnbWVudChtYXRjaFsxXSkpO1xuICAgICAgbmFtZXMucHVzaChtYXRjaFsxXSk7XG4gICAgICB0eXBlcy5zdGFycysrO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCA9PT0gJycpIHtcbiAgICAgIHJlc3VsdHMucHVzaChuZXcgRXBzaWxvblNlZ21lbnQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdHMucHVzaChuZXcgU3RhdGljU2VnbWVudChzZWdtZW50LCBjYXNlU2Vuc2l0aXZlKSk7XG4gICAgICB0eXBlcy5zdGF0aWNzKys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIHNvcnRTb2x1dGlvbnMoc3RhdGVzKSB7XG4gIHJldHVybiBzdGF0ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhLnR5cGVzLnN0YXJzICE9PSBiLnR5cGVzLnN0YXJzKSB7XG4gICAgICByZXR1cm4gYS50eXBlcy5zdGFycyAtIGIudHlwZXMuc3RhcnM7XG4gICAgfVxuXG4gICAgaWYgKGEudHlwZXMuc3RhcnMpIHtcbiAgICAgIGlmIChhLnR5cGVzLnN0YXRpY3MgIT09IGIudHlwZXMuc3RhdGljcykge1xuICAgICAgICByZXR1cm4gYi50eXBlcy5zdGF0aWNzIC0gYS50eXBlcy5zdGF0aWNzO1xuICAgICAgfVxuICAgICAgaWYgKGEudHlwZXMuZHluYW1pY3MgIT09IGIudHlwZXMuZHluYW1pY3MpIHtcbiAgICAgICAgcmV0dXJuIGIudHlwZXMuZHluYW1pY3MgLSBhLnR5cGVzLmR5bmFtaWNzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhLnR5cGVzLmR5bmFtaWNzICE9PSBiLnR5cGVzLmR5bmFtaWNzKSB7XG4gICAgICByZXR1cm4gYS50eXBlcy5keW5hbWljcyAtIGIudHlwZXMuZHluYW1pY3M7XG4gICAgfVxuXG4gICAgaWYgKGEudHlwZXMuc3RhdGljcyAhPT0gYi50eXBlcy5zdGF0aWNzKSB7XG4gICAgICByZXR1cm4gYi50eXBlcy5zdGF0aWNzIC0gYS50eXBlcy5zdGF0aWNzO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVjb2duaXplQ2hhcihzdGF0ZXMsIGNoKSB7XG4gIHZhciBuZXh0U3RhdGVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHN0YXRlID0gc3RhdGVzW2ldO1xuICAgIG5leHRTdGF0ZXMucHVzaC5hcHBseShuZXh0U3RhdGVzLCBzdGF0ZS5tYXRjaChjaCkpO1xuICB9XG5cbiAgcmV0dXJuIG5leHRTdGF0ZXM7XG59XG5cbmZ1bmN0aW9uIGZpbmRIYW5kbGVyKHN0YXRlLCBwYXRoLCBxdWVyeVBhcmFtcykge1xuICB2YXIgaGFuZGxlcnMgPSBzdGF0ZS5oYW5kbGVycztcbiAgdmFyIHJlZ2V4ID0gc3RhdGUucmVnZXg7XG4gIHZhciBjYXB0dXJlcyA9IHBhdGgubWF0Y2gocmVnZXgpO1xuICB2YXIgY3VycmVudENhcHR1cmUgPSAxO1xuICB2YXIgcmVzdWx0ID0gbmV3IFJlY29nbml6ZVJlc3VsdHMocXVlcnlQYXJhbXMpO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIF9oYW5kbGVyID0gaGFuZGxlcnNbaV07XG4gICAgdmFyIF9uYW1lcyA9IF9oYW5kbGVyLm5hbWVzO1xuICAgIHZhciBfcGFyYW1zID0ge307XG5cbiAgICBmb3IgKHZhciBqID0gMCwgbSA9IF9uYW1lcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgIF9wYXJhbXNbX25hbWVzW2pdXSA9IGNhcHR1cmVzW2N1cnJlbnRDYXB0dXJlKytdO1xuICAgIH1cblxuICAgIHJlc3VsdC5wdXNoKHsgaGFuZGxlcjogX2hhbmRsZXIuaGFuZGxlciwgcGFyYW1zOiBfcGFyYW1zLCBpc0R5bmFtaWM6ICEhX25hbWVzLmxlbmd0aCB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGFkZFNlZ21lbnQoY3VycmVudFN0YXRlLCBzZWdtZW50KSB7XG4gIHZhciBmaXJzdFN0YXRlID0gY3VycmVudFN0YXRlLnB1dCh7IHZhbGlkQ2hhcnM6ICcvJyB9KTtcbiAgdmFyIG5leHRTdGF0ZSA9IGZpcnN0U3RhdGU7XG4gIHNlZ21lbnQuZWFjaENoYXIoZnVuY3Rpb24gKGNoKSB7XG4gICAgbmV4dFN0YXRlID0gbmV4dFN0YXRlLnB1dChjaCk7XG4gIH0pO1xuXG4gIHJldHVybiBbZmlyc3RTdGF0ZSwgbmV4dFN0YXRlXTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0esZ\n");

/***/ }),

/***/ "4ysu":
/*!***************************************************************************!*\
  !*** ./node_modules/aurelia-router/dist/native-modules/aurelia-router.js ***!
  \***************************************************************************/
/*! exports provided: _normalizeAbsolutePath, _createRootedPath, _resolveUrl, _ensureArrayWithSingleRoutePerConfig, CommitChangesStep, NavigationInstruction, NavModel, isNavigationCommand, Redirect, RedirectToRoute, pipelineStatus, Pipeline, RouterConfiguration, activationStrategy, BuildNavigationPlanStep, _buildNavigationPlan, Router, CanDeactivatePreviousStep, CanActivateNextStep, DeactivatePreviousStep, ActivateNextStep, RouteLoader, LoadRouteStep, PipelineProvider, AppRouter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Promise) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_normalizeAbsolutePath\", function() { return _normalizeAbsolutePath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_createRootedPath\", function() { return _createRootedPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_resolveUrl\", function() { return _resolveUrl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_ensureArrayWithSingleRoutePerConfig\", function() { return _ensureArrayWithSingleRoutePerConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CommitChangesStep\", function() { return CommitChangesStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NavigationInstruction\", function() { return NavigationInstruction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NavModel\", function() { return NavModel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNavigationCommand\", function() { return isNavigationCommand; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Redirect\", function() { return Redirect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RedirectToRoute\", function() { return RedirectToRoute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pipelineStatus\", function() { return pipelineStatus; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Pipeline\", function() { return Pipeline; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouterConfiguration\", function() { return RouterConfiguration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"activationStrategy\", function() { return activationStrategy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BuildNavigationPlanStep\", function() { return BuildNavigationPlanStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_buildNavigationPlan\", function() { return _buildNavigationPlan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Router\", function() { return Router; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CanDeactivatePreviousStep\", function() { return CanDeactivatePreviousStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CanActivateNextStep\", function() { return CanActivateNextStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DeactivatePreviousStep\", function() { return DeactivatePreviousStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ActivateNextStep\", function() { return ActivateNextStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouteLoader\", function() { return RouteLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoadRouteStep\", function() { return LoadRouteStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PipelineProvider\", function() { return PipelineProvider; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AppRouter\", function() { return AppRouter; });\n/* harmony import */ var aurelia_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-logging */ \"MP1E\");\n/* harmony import */ var aurelia_route_recognizer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aurelia-route-recognizer */ \"0esZ\");\n/* harmony import */ var aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! aurelia-dependency-injection */ \"3U8n\");\n/* harmony import */ var aurelia_history__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! aurelia-history */ \"eP1p\");\n/* harmony import */ var aurelia_event_aggregator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! aurelia-event-aggregator */ \"aurelia-event-aggregator\");\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\n\n\nfunction _normalizeAbsolutePath(path, hasPushState) {\n  var absolute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (!hasPushState && path[0] !== '#') {\n    path = '#' + path;\n  }\n\n  if (hasPushState && absolute) {\n    path = path.substring(1, path.length);\n  }\n\n  return path;\n}\n\nfunction _createRootedPath(fragment, baseUrl, hasPushState, absolute) {\n  if (isAbsoluteUrl.test(fragment)) {\n    return fragment;\n  }\n\n  var path = '';\n\n  if (baseUrl.length && baseUrl[0] !== '/') {\n    path += '/';\n  }\n\n  path += baseUrl;\n\n  if ((!path.length || path[path.length - 1] !== '/') && fragment[0] !== '/') {\n    path += '/';\n  }\n\n  if (path.length && path[path.length - 1] === '/' && fragment[0] === '/') {\n    path = path.substring(0, path.length - 1);\n  }\n\n  return _normalizeAbsolutePath(path + fragment, hasPushState, absolute);\n}\n\nfunction _resolveUrl(fragment, baseUrl, hasPushState) {\n  if (isRootedPath.test(fragment)) {\n    return _normalizeAbsolutePath(fragment, hasPushState);\n  }\n\n  return _createRootedPath(fragment, baseUrl, hasPushState);\n}\n\nfunction _ensureArrayWithSingleRoutePerConfig(config) {\n  var routeConfigs = [];\n\n  if (Array.isArray(config.route)) {\n    for (var i = 0, ii = config.route.length; i < ii; ++i) {\n      var current = Object.assign({}, config);\n      current.route = config.route[i];\n      routeConfigs.push(current);\n    }\n  } else {\n    routeConfigs.push(Object.assign({}, config));\n  }\n\n  return routeConfigs;\n}\n\nvar isRootedPath = /^#?\\//;\nvar isAbsoluteUrl = /^([a-z][a-z0-9+\\-.]*:)?\\/\\//i;\n\nvar CommitChangesStep = function () {\n  function CommitChangesStep() {\n    \n  }\n\n  CommitChangesStep.prototype.run = function run(navigationInstruction, next) {\n    return navigationInstruction._commitChanges(true).then(function () {\n      navigationInstruction._updateTitle();\n      return next();\n    });\n  };\n\n  return CommitChangesStep;\n}();\n\nvar NavigationInstruction = function () {\n  function NavigationInstruction(init) {\n    \n\n    this.plan = null;\n    this.options = {};\n\n    Object.assign(this, init);\n\n    this.params = this.params || {};\n    this.viewPortInstructions = {};\n\n    var ancestorParams = [];\n    var current = this;\n    do {\n      var currentParams = Object.assign({}, current.params);\n      if (current.config && current.config.hasChildRouter) {\n        delete currentParams[current.getWildCardName()];\n      }\n\n      ancestorParams.unshift(currentParams);\n      current = current.parentInstruction;\n    } while (current);\n\n    var allParams = Object.assign.apply(Object, [{}, this.queryParams].concat(ancestorParams));\n    this.lifecycleArgs = [allParams, this.config, this];\n  }\n\n  NavigationInstruction.prototype.getAllInstructions = function getAllInstructions() {\n    var instructions = [this];\n    for (var _key in this.viewPortInstructions) {\n      var childInstruction = this.viewPortInstructions[_key].childNavigationInstruction;\n      if (childInstruction) {\n        instructions.push.apply(instructions, childInstruction.getAllInstructions());\n      }\n    }\n\n    return instructions;\n  };\n\n  NavigationInstruction.prototype.getAllPreviousInstructions = function getAllPreviousInstructions() {\n    return this.getAllInstructions().map(function (c) {\n      return c.previousInstruction;\n    }).filter(function (c) {\n      return c;\n    });\n  };\n\n  NavigationInstruction.prototype.addViewPortInstruction = function addViewPortInstruction(viewPortName, strategy, moduleId, component) {\n    var config = Object.assign({}, this.lifecycleArgs[1], { currentViewPort: viewPortName });\n    var viewportInstruction = this.viewPortInstructions[viewPortName] = {\n      name: viewPortName,\n      strategy: strategy,\n      moduleId: moduleId,\n      component: component,\n      childRouter: component.childRouter,\n      lifecycleArgs: [].concat(this.lifecycleArgs[0], config, this.lifecycleArgs[2])\n    };\n\n    return viewportInstruction;\n  };\n\n  NavigationInstruction.prototype.getWildCardName = function getWildCardName() {\n    var wildcardIndex = this.config.route.lastIndexOf('*');\n    return this.config.route.substr(wildcardIndex + 1);\n  };\n\n  NavigationInstruction.prototype.getWildcardPath = function getWildcardPath() {\n    var wildcardName = this.getWildCardName();\n    var path = this.params[wildcardName] || '';\n\n    if (this.queryString) {\n      path += '?' + this.queryString;\n    }\n\n    return path;\n  };\n\n  NavigationInstruction.prototype.getBaseUrl = function getBaseUrl() {\n    var _this = this;\n\n    var fragment = decodeURI(this.fragment);\n\n    if (fragment === '') {\n      var nonEmptyRoute = this.router.routes.find(function (route) {\n        return route.name === _this.config.name && route.route !== '';\n      });\n      if (nonEmptyRoute) {\n        fragment = nonEmptyRoute.route;\n      }\n    }\n\n    if (!this.params) {\n      return encodeURI(fragment);\n    }\n\n    var wildcardName = this.getWildCardName();\n    var path = this.params[wildcardName] || '';\n\n    if (!path) {\n      return encodeURI(fragment);\n    }\n\n    return encodeURI(fragment.substr(0, fragment.lastIndexOf(path)));\n  };\n\n  NavigationInstruction.prototype._commitChanges = function _commitChanges(waitToSwap) {\n    var _this2 = this;\n\n    var router = this.router;\n    router.currentInstruction = this;\n\n    if (this.previousInstruction) {\n      this.previousInstruction.config.navModel.isActive = false;\n    }\n\n    this.config.navModel.isActive = true;\n\n    router.refreshNavigation();\n\n    var loads = [];\n    var delaySwaps = [];\n\n    var _loop = function _loop(viewPortName) {\n      var viewPortInstruction = _this2.viewPortInstructions[viewPortName];\n      var viewPort = router.viewPorts[viewPortName];\n\n      if (!viewPort) {\n        throw new Error('There was no router-view found in the view for ' + viewPortInstruction.moduleId + '.');\n      }\n\n      if (viewPortInstruction.strategy === activationStrategy.replace) {\n        if (viewPortInstruction.childNavigationInstruction && viewPortInstruction.childNavigationInstruction.parentCatchHandler) {\n          loads.push(viewPortInstruction.childNavigationInstruction._commitChanges(waitToSwap));\n        } else {\n          if (waitToSwap) {\n            delaySwaps.push({ viewPort: viewPort, viewPortInstruction: viewPortInstruction });\n          }\n          loads.push(viewPort.process(viewPortInstruction, waitToSwap).then(function (x) {\n            if (viewPortInstruction.childNavigationInstruction) {\n              return viewPortInstruction.childNavigationInstruction._commitChanges(waitToSwap);\n            }\n          }));\n        }\n      } else {\n        if (viewPortInstruction.childNavigationInstruction) {\n          loads.push(viewPortInstruction.childNavigationInstruction._commitChanges(waitToSwap));\n        }\n      }\n    };\n\n    for (var viewPortName in this.viewPortInstructions) {\n      _loop(viewPortName);\n    }\n\n    return Promise.all(loads).then(function () {\n      delaySwaps.forEach(function (x) {\n        return x.viewPort.swap(x.viewPortInstruction);\n      });\n      return null;\n    }).then(function () {\n      return prune(_this2);\n    });\n  };\n\n  NavigationInstruction.prototype._updateTitle = function _updateTitle() {\n    var title = this._buildTitle(this.router.titleSeparator);\n    if (title) {\n      this.router.history.setTitle(title);\n    }\n  };\n\n  NavigationInstruction.prototype._buildTitle = function _buildTitle() {\n    var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ' | ';\n\n    var title = '';\n    var childTitles = [];\n\n    if (this.config.navModel.title) {\n      title = this.router.transformTitle(this.config.navModel.title);\n    }\n\n    for (var viewPortName in this.viewPortInstructions) {\n      var _viewPortInstruction = this.viewPortInstructions[viewPortName];\n\n      if (_viewPortInstruction.childNavigationInstruction) {\n        var childTitle = _viewPortInstruction.childNavigationInstruction._buildTitle(separator);\n        if (childTitle) {\n          childTitles.push(childTitle);\n        }\n      }\n    }\n\n    if (childTitles.length) {\n      title = childTitles.join(separator) + (title ? separator : '') + title;\n    }\n\n    if (this.router.title) {\n      title += (title ? separator : '') + this.router.transformTitle(this.router.title);\n    }\n\n    return title;\n  };\n\n  return NavigationInstruction;\n}();\n\nfunction prune(instruction) {\n  instruction.previousInstruction = null;\n  instruction.plan = null;\n}\n\nvar NavModel = function () {\n  function NavModel(router, relativeHref) {\n    \n\n    this.isActive = false;\n    this.title = null;\n    this.href = null;\n    this.relativeHref = null;\n    this.settings = {};\n    this.config = null;\n\n    this.router = router;\n    this.relativeHref = relativeHref;\n  }\n\n  NavModel.prototype.setTitle = function setTitle(title) {\n    this.title = title;\n\n    if (this.isActive) {\n      this.router.updateTitle();\n    }\n  };\n\n  return NavModel;\n}();\n\nfunction isNavigationCommand(obj) {\n  return obj && typeof obj.navigate === 'function';\n}\n\nvar Redirect = function () {\n  function Redirect(url) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    \n\n    this.url = url;\n    this.options = Object.assign({ trigger: true, replace: true }, options);\n    this.shouldContinueProcessing = false;\n  }\n\n  Redirect.prototype.setRouter = function setRouter(router) {\n    this.router = router;\n  };\n\n  Redirect.prototype.navigate = function navigate(appRouter) {\n    var navigatingRouter = this.options.useAppRouter ? appRouter : this.router || appRouter;\n    navigatingRouter.navigate(this.url, this.options);\n  };\n\n  return Redirect;\n}();\n\nvar RedirectToRoute = function () {\n  function RedirectToRoute(route) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    \n\n    this.route = route;\n    this.params = params;\n    this.options = Object.assign({ trigger: true, replace: true }, options);\n    this.shouldContinueProcessing = false;\n  }\n\n  RedirectToRoute.prototype.setRouter = function setRouter(router) {\n    this.router = router;\n  };\n\n  RedirectToRoute.prototype.navigate = function navigate(appRouter) {\n    var navigatingRouter = this.options.useAppRouter ? appRouter : this.router || appRouter;\n    navigatingRouter.navigateToRoute(this.route, this.params, this.options);\n  };\n\n  return RedirectToRoute;\n}();\n\nvar pipelineStatus = {\n  completed: 'completed',\n  canceled: 'canceled',\n  rejected: 'rejected',\n  running: 'running'\n};\n\nvar Pipeline = function () {\n  function Pipeline() {\n    \n\n    this.steps = [];\n  }\n\n  Pipeline.prototype.addStep = function addStep(step) {\n    var run = void 0;\n\n    if (typeof step === 'function') {\n      run = step;\n    } else if (typeof step.getSteps === 'function') {\n      var steps = step.getSteps();\n      for (var i = 0, l = steps.length; i < l; i++) {\n        this.addStep(steps[i]);\n      }\n\n      return this;\n    } else {\n      run = step.run.bind(step);\n    }\n\n    this.steps.push(run);\n\n    return this;\n  };\n\n  Pipeline.prototype.run = function run(instruction) {\n    var index = -1;\n    var steps = this.steps;\n\n    function next() {\n      index++;\n\n      if (index < steps.length) {\n        var currentStep = steps[index];\n\n        try {\n          return currentStep(instruction, next);\n        } catch (e) {\n          return next.reject(e);\n        }\n      } else {\n        return next.complete();\n      }\n    }\n\n    next.complete = createCompletionHandler(next, pipelineStatus.completed);\n    next.cancel = createCompletionHandler(next, pipelineStatus.canceled);\n    next.reject = createCompletionHandler(next, pipelineStatus.rejected);\n\n    return next();\n  };\n\n  return Pipeline;\n}();\n\nfunction createCompletionHandler(next, status) {\n  return function (output) {\n    return Promise.resolve({ status: status, output: output, completed: status === pipelineStatus.completed });\n  };\n}\n\nvar RouterConfiguration = function () {\n  function RouterConfiguration() {\n    \n\n    this.instructions = [];\n    this.options = {};\n    this.pipelineSteps = [];\n  }\n\n  RouterConfiguration.prototype.addPipelineStep = function addPipelineStep(name, step) {\n    if (step === null || step === undefined) {\n      throw new Error('Pipeline step cannot be null or undefined.');\n    }\n    this.pipelineSteps.push({ name: name, step: step });\n    return this;\n  };\n\n  RouterConfiguration.prototype.addAuthorizeStep = function addAuthorizeStep(step) {\n    return this.addPipelineStep('authorize', step);\n  };\n\n  RouterConfiguration.prototype.addPreActivateStep = function addPreActivateStep(step) {\n    return this.addPipelineStep('preActivate', step);\n  };\n\n  RouterConfiguration.prototype.addPreRenderStep = function addPreRenderStep(step) {\n    return this.addPipelineStep('preRender', step);\n  };\n\n  RouterConfiguration.prototype.addPostRenderStep = function addPostRenderStep(step) {\n    return this.addPipelineStep('postRender', step);\n  };\n\n  RouterConfiguration.prototype.fallbackRoute = function fallbackRoute(fragment) {\n    this._fallbackRoute = fragment;\n    return this;\n  };\n\n  RouterConfiguration.prototype.map = function map(route) {\n    if (Array.isArray(route)) {\n      route.forEach(this.map.bind(this));\n      return this;\n    }\n\n    return this.mapRoute(route);\n  };\n\n  RouterConfiguration.prototype.useViewPortDefaults = function useViewPortDefaults(viewPortConfig) {\n    this.viewPortDefaults = viewPortConfig;\n    return this;\n  };\n\n  RouterConfiguration.prototype.mapRoute = function mapRoute(config) {\n    this.instructions.push(function (router) {\n      var routeConfigs = _ensureArrayWithSingleRoutePerConfig(config);\n\n      var navModel = void 0;\n      for (var i = 0, ii = routeConfigs.length; i < ii; ++i) {\n        var _routeConfig = routeConfigs[i];\n        _routeConfig.settings = _routeConfig.settings || {};\n        if (!navModel) {\n          navModel = router.createNavModel(_routeConfig);\n        }\n\n        router.addRoute(_routeConfig, navModel);\n      }\n    });\n\n    return this;\n  };\n\n  RouterConfiguration.prototype.mapUnknownRoutes = function mapUnknownRoutes(config) {\n    this.unknownRouteConfig = config;\n    return this;\n  };\n\n  RouterConfiguration.prototype.exportToRouter = function exportToRouter(router) {\n    var instructions = this.instructions;\n    for (var i = 0, ii = instructions.length; i < ii; ++i) {\n      instructions[i](router);\n    }\n\n    if (this.title) {\n      router.title = this.title;\n    }\n\n    if (this.titleSeparator) {\n      router.titleSeparator = this.titleSeparator;\n    }\n\n    if (this.unknownRouteConfig) {\n      router.handleUnknownRoutes(this.unknownRouteConfig);\n    }\n\n    if (this._fallbackRoute) {\n      router.fallbackRoute = this._fallbackRoute;\n    }\n\n    if (this.viewPortDefaults) {\n      router.useViewPortDefaults(this.viewPortDefaults);\n    }\n\n    Object.assign(router.options, this.options);\n\n    var pipelineSteps = this.pipelineSteps;\n    if (pipelineSteps.length) {\n      if (!router.isRoot) {\n        throw new Error('Pipeline steps can only be added to the root router');\n      }\n\n      var pipelineProvider = router.pipelineProvider;\n      for (var _i = 0, _ii = pipelineSteps.length; _i < _ii; ++_i) {\n        var _pipelineSteps$_i = pipelineSteps[_i],\n            _name = _pipelineSteps$_i.name,\n            _step = _pipelineSteps$_i.step;\n\n        pipelineProvider.addStep(_name, _step);\n      }\n    }\n  };\n\n  return RouterConfiguration;\n}();\n\nvar activationStrategy = {\n  noChange: 'no-change',\n  invokeLifecycle: 'invoke-lifecycle',\n  replace: 'replace'\n};\n\nvar BuildNavigationPlanStep = function () {\n  function BuildNavigationPlanStep() {\n    \n  }\n\n  BuildNavigationPlanStep.prototype.run = function run(navigationInstruction, next) {\n    return _buildNavigationPlan(navigationInstruction).then(function (plan) {\n      if (plan instanceof Redirect) {\n        return next.cancel(plan);\n      }\n      navigationInstruction.plan = plan;\n      return next();\n    }).catch(next.cancel);\n  };\n\n  return BuildNavigationPlanStep;\n}();\n\nfunction _buildNavigationPlan(instruction, forceLifecycleMinimum) {\n  var config = instruction.config;\n\n  if ('redirect' in config) {\n    var _router = instruction.router;\n    return _router._createNavigationInstruction(config.redirect).then(function (newInstruction) {\n      var params = {};\n      for (var _key2 in newInstruction.params) {\n        var val = newInstruction.params[_key2];\n        if (typeof val === 'string' && val[0] === ':') {\n          val = val.slice(1);\n\n          if (val in instruction.params) {\n            params[_key2] = instruction.params[val];\n          }\n        } else {\n          params[_key2] = newInstruction.params[_key2];\n        }\n      }\n      var redirectLocation = _router.generate(newInstruction.config.name, params, instruction.options);\n\n      if (instruction.queryString) {\n        redirectLocation += '?' + instruction.queryString;\n      }\n\n      return Promise.resolve(new Redirect(redirectLocation));\n    });\n  }\n\n  var prev = instruction.previousInstruction;\n  var plan = {};\n  var defaults = instruction.router.viewPortDefaults;\n\n  if (prev) {\n    var newParams = hasDifferentParameterValues(prev, instruction);\n    var pending = [];\n\n    var _loop2 = function _loop2(viewPortName) {\n      var prevViewPortInstruction = prev.viewPortInstructions[viewPortName];\n      var nextViewPortConfig = viewPortName in config.viewPorts ? config.viewPorts[viewPortName] : prevViewPortInstruction;\n      if (nextViewPortConfig.moduleId === null && viewPortName in instruction.router.viewPortDefaults) {\n        nextViewPortConfig = defaults[viewPortName];\n      }\n\n      var viewPortPlan = plan[viewPortName] = {\n        name: viewPortName,\n        config: nextViewPortConfig,\n        prevComponent: prevViewPortInstruction.component,\n        prevModuleId: prevViewPortInstruction.moduleId\n      };\n\n      if (prevViewPortInstruction.moduleId !== nextViewPortConfig.moduleId) {\n        viewPortPlan.strategy = activationStrategy.replace;\n      } else if ('determineActivationStrategy' in prevViewPortInstruction.component.viewModel) {\n        var _prevViewPortInstruct;\n\n        viewPortPlan.strategy = (_prevViewPortInstruct = prevViewPortInstruction.component.viewModel).determineActivationStrategy.apply(_prevViewPortInstruct, instruction.lifecycleArgs);\n      } else if (config.activationStrategy) {\n        viewPortPlan.strategy = config.activationStrategy;\n      } else if (newParams || forceLifecycleMinimum) {\n        viewPortPlan.strategy = activationStrategy.invokeLifecycle;\n      } else {\n        viewPortPlan.strategy = activationStrategy.noChange;\n      }\n\n      if (viewPortPlan.strategy !== activationStrategy.replace && prevViewPortInstruction.childRouter) {\n        var path = instruction.getWildcardPath();\n        var task = prevViewPortInstruction.childRouter._createNavigationInstruction(path, instruction).then(function (childInstruction) {\n          viewPortPlan.childNavigationInstruction = childInstruction;\n\n          return _buildNavigationPlan(childInstruction, viewPortPlan.strategy === activationStrategy.invokeLifecycle).then(function (childPlan) {\n            if (childPlan instanceof Redirect) {\n              return Promise.reject(childPlan);\n            }\n            childInstruction.plan = childPlan;\n          });\n        });\n\n        pending.push(task);\n      }\n    };\n\n    for (var viewPortName in prev.viewPortInstructions) {\n      _loop2(viewPortName);\n    }\n\n    return Promise.all(pending).then(function () {\n      return plan;\n    });\n  }\n\n  for (var viewPortName in config.viewPorts) {\n    var viewPortConfig = config.viewPorts[viewPortName];\n    if (viewPortConfig.moduleId === null && viewPortName in instruction.router.viewPortDefaults) {\n      viewPortConfig = defaults[viewPortName];\n    }\n    plan[viewPortName] = {\n      name: viewPortName,\n      strategy: activationStrategy.replace,\n      config: viewPortConfig\n    };\n  }\n\n  return Promise.resolve(plan);\n}\n\nfunction hasDifferentParameterValues(prev, next) {\n  var prevParams = prev.params;\n  var nextParams = next.params;\n  var nextWildCardName = next.config.hasChildRouter ? next.getWildCardName() : null;\n\n  for (var _key3 in nextParams) {\n    if (_key3 === nextWildCardName) {\n      continue;\n    }\n\n    if (prevParams[_key3] !== nextParams[_key3]) {\n      return true;\n    }\n  }\n\n  for (var _key4 in prevParams) {\n    if (_key4 === nextWildCardName) {\n      continue;\n    }\n\n    if (prevParams[_key4] !== nextParams[_key4]) {\n      return true;\n    }\n  }\n\n  if (!next.options.compareQueryParams) {\n    return false;\n  }\n\n  var prevQueryParams = prev.queryParams;\n  var nextQueryParams = next.queryParams;\n  for (var _key5 in nextQueryParams) {\n    if (prevQueryParams[_key5] !== nextQueryParams[_key5]) {\n      return true;\n    }\n  }\n\n  for (var _key6 in prevQueryParams) {\n    if (prevQueryParams[_key6] !== nextQueryParams[_key6]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar Router = function () {\n  function Router(container, history) {\n    var _this3 = this;\n\n    \n\n    this.parent = null;\n    this.options = {};\n    this.viewPortDefaults = {};\n\n    this.transformTitle = function (title) {\n      if (_this3.parent) {\n        return _this3.parent.transformTitle(title);\n      }\n      return title;\n    };\n\n    this.container = container;\n    this.history = history;\n    this.reset();\n  }\n\n  Router.prototype.reset = function reset() {\n    var _this4 = this;\n\n    this.viewPorts = {};\n    this.routes = [];\n    this.baseUrl = '';\n    this.isConfigured = false;\n    this.isNavigating = false;\n    this.isExplicitNavigation = false;\n    this.isExplicitNavigationBack = false;\n    this.isNavigatingFirst = false;\n    this.isNavigatingNew = false;\n    this.isNavigatingRefresh = false;\n    this.isNavigatingForward = false;\n    this.isNavigatingBack = false;\n    this.couldDeactivate = false;\n    this.navigation = [];\n    this.currentInstruction = null;\n    this.viewPortDefaults = {};\n    this._fallbackOrder = 100;\n    this._recognizer = new aurelia_route_recognizer__WEBPACK_IMPORTED_MODULE_1__[\"RouteRecognizer\"]();\n    this._childRecognizer = new aurelia_route_recognizer__WEBPACK_IMPORTED_MODULE_1__[\"RouteRecognizer\"]();\n    this._configuredPromise = new Promise(function (resolve) {\n      _this4._resolveConfiguredPromise = resolve;\n    });\n  };\n\n  Router.prototype.registerViewPort = function registerViewPort(viewPort, name) {\n    name = name || 'default';\n    this.viewPorts[name] = viewPort;\n  };\n\n  Router.prototype.ensureConfigured = function ensureConfigured() {\n    return this._configuredPromise;\n  };\n\n  Router.prototype.configure = function configure(callbackOrConfig) {\n    var _this5 = this;\n\n    this.isConfigured = true;\n\n    var result = callbackOrConfig;\n    var config = void 0;\n    if (typeof callbackOrConfig === 'function') {\n      config = new RouterConfiguration();\n      result = callbackOrConfig(config);\n    }\n\n    return Promise.resolve(result).then(function (c) {\n      if (c && c.exportToRouter) {\n        config = c;\n      }\n\n      config.exportToRouter(_this5);\n      _this5.isConfigured = true;\n      _this5._resolveConfiguredPromise();\n    });\n  };\n\n  Router.prototype.navigate = function navigate(fragment, options) {\n    if (!this.isConfigured && this.parent) {\n      return this.parent.navigate(fragment, options);\n    }\n\n    this.isExplicitNavigation = true;\n    return this.history.navigate(_resolveUrl(fragment, this.baseUrl, this.history._hasPushState), options);\n  };\n\n  Router.prototype.navigateToRoute = function navigateToRoute(route, params, options) {\n    var path = this.generate(route, params);\n    return this.navigate(path, options);\n  };\n\n  Router.prototype.navigateBack = function navigateBack() {\n    this.isExplicitNavigationBack = true;\n    this.history.navigateBack();\n  };\n\n  Router.prototype.createChild = function createChild(container) {\n    var childRouter = new Router(container || this.container.createChild(), this.history);\n    childRouter.parent = this;\n    return childRouter;\n  };\n\n  Router.prototype.generate = function generate(name, params) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var hasRoute = this._recognizer.hasRoute(name);\n    if ((!this.isConfigured || !hasRoute) && this.parent) {\n      return this.parent.generate(name, params, options);\n    }\n\n    if (!hasRoute) {\n      throw new Error('A route with name \\'' + name + '\\' could not be found. Check that `name: \\'' + name + '\\'` was specified in the route\\'s config.');\n    }\n\n    var path = this._recognizer.generate(name, params);\n    var rootedPath = _createRootedPath(path, this.baseUrl, this.history._hasPushState, options.absolute);\n    return options.absolute ? '' + this.history.getAbsoluteRoot() + rootedPath : rootedPath;\n  };\n\n  Router.prototype.createNavModel = function createNavModel(config) {\n    var navModel = new NavModel(this, 'href' in config ? config.href : config.route);\n    navModel.title = config.title;\n    navModel.order = config.nav;\n    navModel.href = config.href;\n    navModel.settings = config.settings;\n    navModel.config = config;\n\n    return navModel;\n  };\n\n  Router.prototype.addRoute = function addRoute(config, navModel) {\n    if (Array.isArray(config.route)) {\n      var routeConfigs = _ensureArrayWithSingleRoutePerConfig(config);\n      routeConfigs.forEach(this.addRoute.bind(this));\n      return;\n    }\n\n    validateRouteConfig(config, this.routes);\n\n    if (!('viewPorts' in config) && !config.navigationStrategy) {\n      config.viewPorts = {\n        'default': {\n          moduleId: config.moduleId,\n          view: config.view\n        }\n      };\n    }\n\n    if (!navModel) {\n      navModel = this.createNavModel(config);\n    }\n\n    this.routes.push(config);\n\n    var path = config.route;\n    if (path.charAt(0) === '/') {\n      path = path.substr(1);\n    }\n    var caseSensitive = config.caseSensitive === true;\n    var state = this._recognizer.add({ path: path, handler: config, caseSensitive: caseSensitive });\n\n    if (path) {\n      var _settings = config.settings;\n      delete config.settings;\n      var withChild = JSON.parse(JSON.stringify(config));\n      config.settings = _settings;\n      withChild.route = path + '/*childRoute';\n      withChild.hasChildRouter = true;\n      this._childRecognizer.add({\n        path: withChild.route,\n        handler: withChild,\n        caseSensitive: caseSensitive\n      });\n\n      withChild.navModel = navModel;\n      withChild.settings = config.settings;\n      withChild.navigationStrategy = config.navigationStrategy;\n    }\n\n    config.navModel = navModel;\n\n    if ((navModel.order || navModel.order === 0) && this.navigation.indexOf(navModel) === -1) {\n      if (!navModel.href && navModel.href !== '' && (state.types.dynamics || state.types.stars)) {\n        throw new Error('Invalid route config for \"' + config.route + '\" : dynamic routes must specify an \"href:\" to be included in the navigation model.');\n      }\n\n      if (typeof navModel.order !== 'number') {\n        navModel.order = ++this._fallbackOrder;\n      }\n\n      this.navigation.push(navModel);\n      this.navigation = this.navigation.sort(function (a, b) {\n        return a.order - b.order;\n      });\n    }\n  };\n\n  Router.prototype.hasRoute = function hasRoute(name) {\n    return !!(this._recognizer.hasRoute(name) || this.parent && this.parent.hasRoute(name));\n  };\n\n  Router.prototype.hasOwnRoute = function hasOwnRoute(name) {\n    return this._recognizer.hasRoute(name);\n  };\n\n  Router.prototype.handleUnknownRoutes = function handleUnknownRoutes(config) {\n    var _this6 = this;\n\n    if (!config) {\n      throw new Error('Invalid unknown route handler');\n    }\n\n    this.catchAllHandler = function (instruction) {\n      return _this6._createRouteConfig(config, instruction).then(function (c) {\n        instruction.config = c;\n        return instruction;\n      });\n    };\n  };\n\n  Router.prototype.updateTitle = function updateTitle() {\n    if (this.parent) {\n      return this.parent.updateTitle();\n    }\n\n    if (this.currentInstruction) {\n      this.currentInstruction._updateTitle();\n    }\n    return undefined;\n  };\n\n  Router.prototype.refreshNavigation = function refreshNavigation() {\n    var nav = this.navigation;\n\n    for (var i = 0, length = nav.length; i < length; i++) {\n      var _current = nav[i];\n      if (!_current.config.href) {\n        _current.href = _createRootedPath(_current.relativeHref, this.baseUrl, this.history._hasPushState);\n      } else {\n        _current.href = _normalizeAbsolutePath(_current.config.href, this.history._hasPushState);\n      }\n    }\n  };\n\n  Router.prototype.useViewPortDefaults = function useViewPortDefaults(viewPortDefaults) {\n    for (var viewPortName in viewPortDefaults) {\n      var viewPortConfig = viewPortDefaults[viewPortName];\n      this.viewPortDefaults[viewPortName] = {\n        moduleId: viewPortConfig.moduleId\n      };\n    }\n  };\n\n  Router.prototype._refreshBaseUrl = function _refreshBaseUrl() {\n    if (this.parent) {\n      this.baseUrl = generateBaseUrl(this.parent, this.parent.currentInstruction);\n    }\n  };\n\n  Router.prototype._createNavigationInstruction = function _createNavigationInstruction() {\n    var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var parentInstruction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    var fragment = url;\n    var queryString = '';\n\n    var queryIndex = url.indexOf('?');\n    if (queryIndex !== -1) {\n      fragment = url.substr(0, queryIndex);\n      queryString = url.substr(queryIndex + 1);\n    }\n\n    var results = this._recognizer.recognize(url);\n    if (!results || !results.length) {\n      results = this._childRecognizer.recognize(url);\n    }\n\n    var instructionInit = {\n      fragment: fragment,\n      queryString: queryString,\n      config: null,\n      parentInstruction: parentInstruction,\n      previousInstruction: this.currentInstruction,\n      router: this,\n      options: {\n        compareQueryParams: this.options.compareQueryParams\n      }\n    };\n\n    var result = void 0;\n\n    if (results && results.length) {\n      var first = results[0];\n      var _instruction = new NavigationInstruction(Object.assign({}, instructionInit, {\n        params: first.params,\n        queryParams: first.queryParams || results.queryParams,\n        config: first.config || first.handler\n      }));\n\n      if (typeof first.handler === 'function') {\n        result = evaluateNavigationStrategy(_instruction, first.handler, first);\n      } else if (first.handler && typeof first.handler.navigationStrategy === 'function') {\n        result = evaluateNavigationStrategy(_instruction, first.handler.navigationStrategy, first.handler);\n      } else {\n        result = Promise.resolve(_instruction);\n      }\n    } else if (this.catchAllHandler) {\n      var _instruction2 = new NavigationInstruction(Object.assign({}, instructionInit, {\n        params: { path: fragment },\n        queryParams: results ? results.queryParams : {},\n        config: null }));\n\n      result = evaluateNavigationStrategy(_instruction2, this.catchAllHandler);\n    } else if (this.parent) {\n      var _router2 = this._parentCatchAllHandler(this.parent);\n\n      if (_router2) {\n        var newParentInstruction = this._findParentInstructionFromRouter(_router2, parentInstruction);\n\n        var _instruction3 = new NavigationInstruction(Object.assign({}, instructionInit, {\n          params: { path: fragment },\n          queryParams: results ? results.queryParams : {},\n          router: _router2,\n          parentInstruction: newParentInstruction,\n          parentCatchHandler: true,\n          config: null }));\n\n        result = evaluateNavigationStrategy(_instruction3, _router2.catchAllHandler);\n      }\n    }\n\n    if (result && parentInstruction) {\n      this.baseUrl = generateBaseUrl(this.parent, parentInstruction);\n    }\n\n    return result || Promise.reject(new Error('Route not found: ' + url));\n  };\n\n  Router.prototype._findParentInstructionFromRouter = function _findParentInstructionFromRouter(router, instruction) {\n    if (instruction.router === router) {\n      instruction.fragment = router.baseUrl;\n      return instruction;\n    } else if (instruction.parentInstruction) {\n      return this._findParentInstructionFromRouter(router, instruction.parentInstruction);\n    }\n    return undefined;\n  };\n\n  Router.prototype._parentCatchAllHandler = function _parentCatchAllHandler(router) {\n    if (router.catchAllHandler) {\n      return router;\n    } else if (router.parent) {\n      return this._parentCatchAllHandler(router.parent);\n    }\n    return false;\n  };\n\n  Router.prototype._createRouteConfig = function _createRouteConfig(config, instruction) {\n    var _this7 = this;\n\n    return Promise.resolve(config).then(function (c) {\n      if (typeof c === 'string') {\n        return { moduleId: c };\n      } else if (typeof c === 'function') {\n        return c(instruction);\n      }\n\n      return c;\n    }).then(function (c) {\n      return typeof c === 'string' ? { moduleId: c } : c;\n    }).then(function (c) {\n      c.route = instruction.params.path;\n      validateRouteConfig(c, _this7.routes);\n\n      if (!c.navModel) {\n        c.navModel = _this7.createNavModel(c);\n      }\n\n      return c;\n    });\n  };\n\n  _createClass(Router, [{\n    key: 'isRoot',\n    get: function get() {\n      return !this.parent;\n    }\n  }]);\n\n  return Router;\n}();\n\nfunction generateBaseUrl(router, instruction) {\n  return '' + (router.baseUrl || '') + (instruction.getBaseUrl() || '');\n}\n\nfunction validateRouteConfig(config, routes) {\n  if ((typeof config === 'undefined' ? 'undefined' : _typeof(config)) !== 'object') {\n    throw new Error('Invalid Route Config');\n  }\n\n  if (typeof config.route !== 'string') {\n    var _name2 = config.name || '(no name)';\n    throw new Error('Invalid Route Config for \"' + _name2 + '\": You must specify a \"route:\" pattern.');\n  }\n\n  if (!('redirect' in config || config.moduleId || config.navigationStrategy || config.viewPorts)) {\n    throw new Error('Invalid Route Config for \"' + config.route + '\": You must specify a \"moduleId:\", \"redirect:\", \"navigationStrategy:\", or \"viewPorts:\".');\n  }\n}\n\nfunction evaluateNavigationStrategy(instruction, evaluator, context) {\n  return Promise.resolve(evaluator.call(context, instruction)).then(function () {\n    if (!('viewPorts' in instruction.config)) {\n      instruction.config.viewPorts = {\n        'default': {\n          moduleId: instruction.config.moduleId\n        }\n      };\n    }\n\n    return instruction;\n  });\n}\n\nvar CanDeactivatePreviousStep = function () {\n  function CanDeactivatePreviousStep() {\n    \n  }\n\n  CanDeactivatePreviousStep.prototype.run = function run(navigationInstruction, next) {\n    return processDeactivatable(navigationInstruction, 'canDeactivate', next);\n  };\n\n  return CanDeactivatePreviousStep;\n}();\n\nvar CanActivateNextStep = function () {\n  function CanActivateNextStep() {\n    \n  }\n\n  CanActivateNextStep.prototype.run = function run(navigationInstruction, next) {\n    return processActivatable(navigationInstruction, 'canActivate', next);\n  };\n\n  return CanActivateNextStep;\n}();\n\nvar DeactivatePreviousStep = function () {\n  function DeactivatePreviousStep() {\n    \n  }\n\n  DeactivatePreviousStep.prototype.run = function run(navigationInstruction, next) {\n    return processDeactivatable(navigationInstruction, 'deactivate', next, true);\n  };\n\n  return DeactivatePreviousStep;\n}();\n\nvar ActivateNextStep = function () {\n  function ActivateNextStep() {\n    \n  }\n\n  ActivateNextStep.prototype.run = function run(navigationInstruction, next) {\n    return processActivatable(navigationInstruction, 'activate', next, true);\n  };\n\n  return ActivateNextStep;\n}();\n\nfunction processDeactivatable(navigationInstruction, callbackName, next, ignoreResult) {\n  var plan = navigationInstruction.plan;\n  var infos = findDeactivatable(plan, callbackName);\n  var i = infos.length;\n\n  function inspect(val) {\n    if (ignoreResult || shouldContinue(val)) {\n      return iterate();\n    }\n\n    return next.cancel(val);\n  }\n\n  function iterate() {\n    if (i--) {\n      try {\n        var viewModel = infos[i];\n        var _result = viewModel[callbackName](navigationInstruction);\n        return processPotential(_result, inspect, next.cancel);\n      } catch (error) {\n        return next.cancel(error);\n      }\n    }\n\n    navigationInstruction.router.couldDeactivate = true;\n\n    return next();\n  }\n\n  return iterate();\n}\n\nfunction findDeactivatable(plan, callbackName) {\n  var list = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  for (var viewPortName in plan) {\n    var _viewPortPlan = plan[viewPortName];\n    var prevComponent = _viewPortPlan.prevComponent;\n\n    if ((_viewPortPlan.strategy === activationStrategy.invokeLifecycle || _viewPortPlan.strategy === activationStrategy.replace) && prevComponent) {\n      var viewModel = prevComponent.viewModel;\n\n      if (callbackName in viewModel) {\n        list.push(viewModel);\n      }\n    }\n\n    if (_viewPortPlan.strategy === activationStrategy.replace && prevComponent) {\n      addPreviousDeactivatable(prevComponent, callbackName, list);\n    } else if (_viewPortPlan.childNavigationInstruction) {\n      findDeactivatable(_viewPortPlan.childNavigationInstruction.plan, callbackName, list);\n    }\n  }\n\n  return list;\n}\n\nfunction addPreviousDeactivatable(component, callbackName, list) {\n  var childRouter = component.childRouter;\n\n  if (childRouter && childRouter.currentInstruction) {\n    var viewPortInstructions = childRouter.currentInstruction.viewPortInstructions;\n\n    for (var viewPortName in viewPortInstructions) {\n      var _viewPortInstruction2 = viewPortInstructions[viewPortName];\n      var prevComponent = _viewPortInstruction2.component;\n      var prevViewModel = prevComponent.viewModel;\n\n      if (callbackName in prevViewModel) {\n        list.push(prevViewModel);\n      }\n\n      addPreviousDeactivatable(prevComponent, callbackName, list);\n    }\n  }\n}\n\nfunction processActivatable(navigationInstruction, callbackName, next, ignoreResult) {\n  var infos = findActivatable(navigationInstruction, callbackName);\n  var length = infos.length;\n  var i = -1;\n\n  function inspect(val, router) {\n    if (ignoreResult || shouldContinue(val, router)) {\n      return iterate();\n    }\n\n    return next.cancel(val);\n  }\n\n  function iterate() {\n    i++;\n\n    if (i < length) {\n      try {\n        var _current2$viewModel;\n\n        var _current2 = infos[i];\n        var _result2 = (_current2$viewModel = _current2.viewModel)[callbackName].apply(_current2$viewModel, _current2.lifecycleArgs);\n        return processPotential(_result2, function (val) {\n          return inspect(val, _current2.router);\n        }, next.cancel);\n      } catch (error) {\n        return next.cancel(error);\n      }\n    }\n\n    return next();\n  }\n\n  return iterate();\n}\n\nfunction findActivatable(navigationInstruction, callbackName) {\n  var list = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var router = arguments[3];\n\n  var plan = navigationInstruction.plan;\n\n  Object.keys(plan).filter(function (viewPortName) {\n    var viewPortPlan = plan[viewPortName];\n    var viewPortInstruction = navigationInstruction.viewPortInstructions[viewPortName];\n    var viewModel = viewPortInstruction.component.viewModel;\n\n    if ((viewPortPlan.strategy === activationStrategy.invokeLifecycle || viewPortPlan.strategy === activationStrategy.replace) && callbackName in viewModel) {\n      list.push({\n        viewModel: viewModel,\n        lifecycleArgs: viewPortInstruction.lifecycleArgs,\n        router: router\n      });\n    }\n\n    if (viewPortPlan.childNavigationInstruction) {\n      findActivatable(viewPortPlan.childNavigationInstruction, callbackName, list, viewPortInstruction.component.childRouter || router);\n    }\n  });\n\n  return list;\n}\n\nfunction shouldContinue(output, router) {\n  if (output instanceof Error) {\n    return false;\n  }\n\n  if (isNavigationCommand(output)) {\n    if (typeof output.setRouter === 'function') {\n      output.setRouter(router);\n    }\n\n    return !!output.shouldContinueProcessing;\n  }\n\n  if (output === undefined) {\n    return true;\n  }\n\n  return output;\n}\n\nvar SafeSubscription = function () {\n  function SafeSubscription(subscriptionFunc) {\n    \n\n    this._subscribed = true;\n    this._subscription = subscriptionFunc(this);\n\n    if (!this._subscribed) this.unsubscribe();\n  }\n\n  SafeSubscription.prototype.unsubscribe = function unsubscribe() {\n    if (this._subscribed && this._subscription) this._subscription.unsubscribe();\n\n    this._subscribed = false;\n  };\n\n  _createClass(SafeSubscription, [{\n    key: 'subscribed',\n    get: function get() {\n      return this._subscribed;\n    }\n  }]);\n\n  return SafeSubscription;\n}();\n\nfunction processPotential(obj, resolve, reject) {\n  if (obj && typeof obj.then === 'function') {\n    return Promise.resolve(obj).then(resolve).catch(reject);\n  }\n\n  if (obj && typeof obj.subscribe === 'function') {\n    var obs = obj;\n    return new SafeSubscription(function (sub) {\n      return obs.subscribe({\n        next: function next() {\n          if (sub.subscribed) {\n            sub.unsubscribe();\n            resolve(obj);\n          }\n        },\n        error: function error(_error) {\n          if (sub.subscribed) {\n            sub.unsubscribe();\n            reject(_error);\n          }\n        },\n        complete: function complete() {\n          if (sub.subscribed) {\n            sub.unsubscribe();\n            resolve(obj);\n          }\n        }\n      });\n    });\n  }\n\n  try {\n    return resolve(obj);\n  } catch (error) {\n    return reject(error);\n  }\n}\n\nvar RouteLoader = function () {\n  function RouteLoader() {\n    \n  }\n\n  RouteLoader.prototype.loadRoute = function loadRoute(router, config, navigationInstruction) {\n    throw Error('Route loaders must implement \"loadRoute(router, config, navigationInstruction)\".');\n  };\n\n  return RouteLoader;\n}();\n\nvar LoadRouteStep = function () {\n  LoadRouteStep.inject = function inject() {\n    return [RouteLoader];\n  };\n\n  function LoadRouteStep(routeLoader) {\n    \n\n    this.routeLoader = routeLoader;\n  }\n\n  LoadRouteStep.prototype.run = function run(navigationInstruction, next) {\n    return loadNewRoute(this.routeLoader, navigationInstruction).then(next).catch(next.cancel);\n  };\n\n  return LoadRouteStep;\n}();\n\nfunction loadNewRoute(routeLoader, navigationInstruction) {\n  var toLoad = determineWhatToLoad(navigationInstruction);\n  var loadPromises = toLoad.map(function (current) {\n    return loadRoute(routeLoader, current.navigationInstruction, current.viewPortPlan);\n  });\n\n  return Promise.all(loadPromises);\n}\n\nfunction determineWhatToLoad(navigationInstruction) {\n  var toLoad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  var plan = navigationInstruction.plan;\n\n  for (var viewPortName in plan) {\n    var _viewPortPlan2 = plan[viewPortName];\n\n    if (_viewPortPlan2.strategy === activationStrategy.replace) {\n      toLoad.push({ viewPortPlan: _viewPortPlan2, navigationInstruction: navigationInstruction });\n\n      if (_viewPortPlan2.childNavigationInstruction) {\n        determineWhatToLoad(_viewPortPlan2.childNavigationInstruction, toLoad);\n      }\n    } else {\n      var _viewPortInstruction3 = navigationInstruction.addViewPortInstruction(viewPortName, _viewPortPlan2.strategy, _viewPortPlan2.prevModuleId, _viewPortPlan2.prevComponent);\n\n      if (_viewPortPlan2.childNavigationInstruction) {\n        _viewPortInstruction3.childNavigationInstruction = _viewPortPlan2.childNavigationInstruction;\n        determineWhatToLoad(_viewPortPlan2.childNavigationInstruction, toLoad);\n      }\n    }\n  }\n\n  return toLoad;\n}\n\nfunction loadRoute(routeLoader, navigationInstruction, viewPortPlan) {\n  var moduleId = viewPortPlan.config ? viewPortPlan.config.moduleId : null;\n\n  return loadComponent(routeLoader, navigationInstruction, viewPortPlan.config).then(function (component) {\n    var viewPortInstruction = navigationInstruction.addViewPortInstruction(viewPortPlan.name, viewPortPlan.strategy, moduleId, component);\n\n    var childRouter = component.childRouter;\n    if (childRouter) {\n      var path = navigationInstruction.getWildcardPath();\n\n      return childRouter._createNavigationInstruction(path, navigationInstruction).then(function (childInstruction) {\n        viewPortPlan.childNavigationInstruction = childInstruction;\n\n        return _buildNavigationPlan(childInstruction).then(function (childPlan) {\n          if (childPlan instanceof Redirect) {\n            return Promise.reject(childPlan);\n          }\n          childInstruction.plan = childPlan;\n          viewPortInstruction.childNavigationInstruction = childInstruction;\n\n          return loadNewRoute(routeLoader, childInstruction);\n        });\n      });\n    }\n\n    return undefined;\n  });\n}\n\nfunction loadComponent(routeLoader, navigationInstruction, config) {\n  var router = navigationInstruction.router;\n  var lifecycleArgs = navigationInstruction.lifecycleArgs;\n\n  return routeLoader.loadRoute(router, config, navigationInstruction).then(function (component) {\n    var viewModel = component.viewModel,\n        childContainer = component.childContainer;\n\n    component.router = router;\n    component.config = config;\n\n    if ('configureRouter' in viewModel) {\n      var childRouter = childContainer.getChildRouter();\n      component.childRouter = childRouter;\n\n      return childRouter.configure(function (c) {\n        return viewModel.configureRouter.apply(viewModel, [c, childRouter].concat(lifecycleArgs));\n      }).then(function () {\n        return component;\n      });\n    }\n\n    return component;\n  });\n}\n\nvar PipelineSlot = function () {\n  function PipelineSlot(container, name, alias) {\n    \n\n    this.steps = [];\n\n    this.container = container;\n    this.slotName = name;\n    this.slotAlias = alias;\n  }\n\n  PipelineSlot.prototype.getSteps = function getSteps() {\n    var _this8 = this;\n\n    return this.steps.map(function (x) {\n      return _this8.container.get(x);\n    });\n  };\n\n  return PipelineSlot;\n}();\n\nvar PipelineProvider = function () {\n  PipelineProvider.inject = function inject() {\n    return [aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_2__[\"Container\"]];\n  };\n\n  function PipelineProvider(container) {\n    \n\n    this.container = container;\n    this.steps = [BuildNavigationPlanStep, CanDeactivatePreviousStep, LoadRouteStep, this._createPipelineSlot('authorize'), CanActivateNextStep, this._createPipelineSlot('preActivate', 'modelbind'), DeactivatePreviousStep, ActivateNextStep, this._createPipelineSlot('preRender', 'precommit'), CommitChangesStep, this._createPipelineSlot('postRender', 'postcomplete')];\n  }\n\n  PipelineProvider.prototype.createPipeline = function createPipeline() {\n    var _this9 = this;\n\n    var useCanDeactivateStep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    var pipeline = new Pipeline();\n    this.steps.forEach(function (step) {\n      if (useCanDeactivateStep || step !== CanDeactivatePreviousStep) {\n        pipeline.addStep(_this9.container.get(step));\n      }\n    });\n    return pipeline;\n  };\n\n  PipelineProvider.prototype._findStep = function _findStep(name) {\n    return this.steps.find(function (x) {\n      return x.slotName === name || x.slotAlias === name;\n    });\n  };\n\n  PipelineProvider.prototype.addStep = function addStep(name, step) {\n    var found = this._findStep(name);\n    if (found) {\n      if (!found.steps.includes(step)) {\n        found.steps.push(step);\n      }\n    } else {\n      throw new Error('Invalid pipeline slot name: ' + name + '.');\n    }\n  };\n\n  PipelineProvider.prototype.removeStep = function removeStep(name, step) {\n    var slot = this._findStep(name);\n    if (slot) {\n      slot.steps.splice(slot.steps.indexOf(step), 1);\n    }\n  };\n\n  PipelineProvider.prototype._clearSteps = function _clearSteps() {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n    var slot = this._findStep(name);\n    if (slot) {\n      slot.steps = [];\n    }\n  };\n\n  PipelineProvider.prototype.reset = function reset() {\n    this._clearSteps('authorize');\n    this._clearSteps('preActivate');\n    this._clearSteps('preRender');\n    this._clearSteps('postRender');\n  };\n\n  PipelineProvider.prototype._createPipelineSlot = function _createPipelineSlot(name, alias) {\n    return new PipelineSlot(this.container, name, alias);\n  };\n\n  return PipelineProvider;\n}();\n\nvar logger = aurelia_logging__WEBPACK_IMPORTED_MODULE_0__[\"getLogger\"]('app-router');\n\nvar AppRouter = function (_Router) {\n  _inherits(AppRouter, _Router);\n\n  AppRouter.inject = function inject() {\n    return [aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_2__[\"Container\"], aurelia_history__WEBPACK_IMPORTED_MODULE_3__[\"History\"], PipelineProvider, aurelia_event_aggregator__WEBPACK_IMPORTED_MODULE_4__[\"EventAggregator\"]];\n  };\n\n  function AppRouter(container, history, pipelineProvider, events) {\n    \n\n    var _this10 = _possibleConstructorReturn(this, _Router.call(this, container, history));\n\n    _this10.pipelineProvider = pipelineProvider;\n    _this10.events = events;\n    return _this10;\n  }\n\n  AppRouter.prototype.reset = function reset() {\n    _Router.prototype.reset.call(this);\n    this.maxInstructionCount = 10;\n    if (!this._queue) {\n      this._queue = [];\n    } else {\n      this._queue.length = 0;\n    }\n  };\n\n  AppRouter.prototype.loadUrl = function loadUrl(url) {\n    var _this11 = this;\n\n    return this._createNavigationInstruction(url).then(function (instruction) {\n      return _this11._queueInstruction(instruction);\n    }).catch(function (error) {\n      logger.error(error);\n      restorePreviousLocation(_this11);\n    });\n  };\n\n  AppRouter.prototype.registerViewPort = function registerViewPort(viewPort, name) {\n    var _this12 = this;\n\n    _Router.prototype.registerViewPort.call(this, viewPort, name);\n\n    if (!this.isActive) {\n      var viewModel = this._findViewModel(viewPort);\n      if ('configureRouter' in viewModel) {\n        if (!this.isConfigured) {\n          var resolveConfiguredPromise = this._resolveConfiguredPromise;\n          this._resolveConfiguredPromise = function () {};\n          return this.configure(function (config) {\n            return viewModel.configureRouter(config, _this12);\n          }).then(function () {\n            _this12.activate();\n            resolveConfiguredPromise();\n          });\n        }\n      } else {\n        this.activate();\n      }\n    } else {\n      this._dequeueInstruction();\n    }\n\n    return Promise.resolve();\n  };\n\n  AppRouter.prototype.activate = function activate(options) {\n    if (this.isActive) {\n      return;\n    }\n\n    this.isActive = true;\n    this.options = Object.assign({ routeHandler: this.loadUrl.bind(this) }, this.options, options);\n    this.history.activate(this.options);\n    this._dequeueInstruction();\n  };\n\n  AppRouter.prototype.deactivate = function deactivate() {\n    this.isActive = false;\n    this.history.deactivate();\n  };\n\n  AppRouter.prototype._queueInstruction = function _queueInstruction(instruction) {\n    var _this13 = this;\n\n    return new Promise(function (resolve) {\n      instruction.resolve = resolve;\n      _this13._queue.unshift(instruction);\n      _this13._dequeueInstruction();\n    });\n  };\n\n  AppRouter.prototype._dequeueInstruction = function _dequeueInstruction() {\n    var _this14 = this;\n\n    var instructionCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    return Promise.resolve().then(function () {\n      if (_this14.isNavigating && !instructionCount) {\n        return undefined;\n      }\n\n      var instruction = _this14._queue.shift();\n      _this14._queue.length = 0;\n\n      if (!instruction) {\n        return undefined;\n      }\n\n      _this14.isNavigating = true;\n\n      var navtracker = _this14.history.getState('NavigationTracker');\n      if (!navtracker && !_this14.currentNavigationTracker) {\n        _this14.isNavigatingFirst = true;\n        _this14.isNavigatingNew = true;\n      } else if (!navtracker) {\n        _this14.isNavigatingNew = true;\n      } else if (!_this14.currentNavigationTracker) {\n        _this14.isNavigatingRefresh = true;\n      } else if (_this14.currentNavigationTracker < navtracker) {\n        _this14.isNavigatingForward = true;\n      } else if (_this14.currentNavigationTracker > navtracker) {\n        _this14.isNavigatingBack = true;\n      }if (!navtracker) {\n        navtracker = Date.now();\n        _this14.history.setState('NavigationTracker', navtracker);\n      }\n      _this14.currentNavigationTracker = navtracker;\n\n      instruction.previousInstruction = _this14.currentInstruction;\n\n      if (!instructionCount) {\n        _this14.events.publish('router:navigation:processing', { instruction: instruction });\n      } else if (instructionCount === _this14.maxInstructionCount - 1) {\n        logger.error(instructionCount + 1 + ' navigation instructions have been attempted without success. Restoring last known good location.');\n        restorePreviousLocation(_this14);\n        return _this14._dequeueInstruction(instructionCount + 1);\n      } else if (instructionCount > _this14.maxInstructionCount) {\n        throw new Error('Maximum navigation attempts exceeded. Giving up.');\n      }\n\n      var pipeline = _this14.pipelineProvider.createPipeline(!_this14.couldDeactivate);\n\n      return pipeline.run(instruction).then(function (result) {\n        return processResult(instruction, result, instructionCount, _this14);\n      }).catch(function (error) {\n        return { output: error instanceof Error ? error : new Error(error) };\n      }).then(function (result) {\n        return resolveInstruction(instruction, result, !!instructionCount, _this14);\n      });\n    });\n  };\n\n  AppRouter.prototype._findViewModel = function _findViewModel(viewPort) {\n    if (this.container.viewModel) {\n      return this.container.viewModel;\n    }\n\n    if (viewPort.container) {\n      var container = viewPort.container;\n\n      while (container) {\n        if (container.viewModel) {\n          this.container.viewModel = container.viewModel;\n          return container.viewModel;\n        }\n\n        container = container.parent;\n      }\n    }\n\n    return undefined;\n  };\n\n  return AppRouter;\n}(Router);\n\nfunction processResult(instruction, result, instructionCount, router) {\n  if (!(result && 'completed' in result && 'output' in result)) {\n    result = result || {};\n    result.output = new Error('Expected router pipeline to return a navigation result, but got [' + JSON.stringify(result) + '] instead.');\n  }\n\n  var finalResult = null;\n  var navigationCommandResult = null;\n  if (isNavigationCommand(result.output)) {\n    navigationCommandResult = result.output.navigate(router);\n  } else {\n    finalResult = result;\n\n    if (!result.completed) {\n      if (result.output instanceof Error) {\n        logger.error(result.output);\n      }\n\n      restorePreviousLocation(router);\n    }\n  }\n\n  return Promise.resolve(navigationCommandResult).then(function (_) {\n    return router._dequeueInstruction(instructionCount + 1);\n  }).then(function (innerResult) {\n    return finalResult || innerResult || result;\n  });\n}\n\nfunction resolveInstruction(instruction, result, isInnerInstruction, router) {\n  instruction.resolve(result);\n\n  var eventArgs = { instruction: instruction, result: result };\n  if (!isInnerInstruction) {\n    router.isNavigating = false;\n    router.isExplicitNavigation = false;\n    router.isExplicitNavigationBack = false;\n    router.isNavigatingFirst = false;\n    router.isNavigatingNew = false;\n    router.isNavigatingRefresh = false;\n    router.isNavigatingForward = false;\n    router.isNavigatingBack = false;\n    router.couldDeactivate = false;\n\n    var eventName = void 0;\n\n    if (result.output instanceof Error) {\n      eventName = 'error';\n    } else if (!result.completed) {\n      eventName = 'canceled';\n    } else {\n      var _queryString = instruction.queryString ? '?' + instruction.queryString : '';\n      router.history.previousLocation = instruction.fragment + _queryString;\n      eventName = 'success';\n    }\n\n    router.events.publish('router:navigation:' + eventName, eventArgs);\n    router.events.publish('router:navigation:complete', eventArgs);\n  } else {\n    router.events.publish('router:navigation:child:complete', eventArgs);\n  }\n\n  return result;\n}\n\nfunction restorePreviousLocation(router) {\n  var previousLocation = router.history.previousLocation;\n  if (previousLocation) {\n    router.navigate(router.history.previousLocation, { trigger: false, replace: true });\n  } else if (router.fallbackRoute) {\n    router.navigate(router.fallbackRoute, { trigger: true, replace: true });\n  } else {\n    logger.error('Router navigation failed, and no previous location or fallbackRoute could be restored.');\n  }\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! promise-polyfill */ \"B/eG\")[\"default\"]))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNHlzdS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLXJvdXRlci9kaXN0L25hdGl2ZS1tb2R1bGVzL2F1cmVsaWEtcm91dGVyLmpzP2UzMmIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cblxuXG5pbXBvcnQgKiBhcyBMb2dNYW5hZ2VyIGZyb20gJ2F1cmVsaWEtbG9nZ2luZyc7XG5pbXBvcnQgeyBSb3V0ZVJlY29nbml6ZXIgfSBmcm9tICdhdXJlbGlhLXJvdXRlLXJlY29nbml6ZXInO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnYXVyZWxpYS1kZXBlbmRlbmN5LWluamVjdGlvbic7XG5pbXBvcnQgeyBIaXN0b3J5LCBOYXZpZ2F0aW9uT3B0aW9ucyB9IGZyb20gJ2F1cmVsaWEtaGlzdG9yeSc7XG5pbXBvcnQgeyBFdmVudEFnZ3JlZ2F0b3IgfSBmcm9tICdhdXJlbGlhLWV2ZW50LWFnZ3JlZ2F0b3InO1xuXG5leHBvcnQgZnVuY3Rpb24gX25vcm1hbGl6ZUFic29sdXRlUGF0aChwYXRoLCBoYXNQdXNoU3RhdGUpIHtcbiAgdmFyIGFic29sdXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICBpZiAoIWhhc1B1c2hTdGF0ZSAmJiBwYXRoWzBdICE9PSAnIycpIHtcbiAgICBwYXRoID0gJyMnICsgcGF0aDtcbiAgfVxuXG4gIGlmIChoYXNQdXNoU3RhdGUgJiYgYWJzb2x1dGUpIHtcbiAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMSwgcGF0aC5sZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfY3JlYXRlUm9vdGVkUGF0aChmcmFnbWVudCwgYmFzZVVybCwgaGFzUHVzaFN0YXRlLCBhYnNvbHV0ZSkge1xuICBpZiAoaXNBYnNvbHV0ZVVybC50ZXN0KGZyYWdtZW50KSkge1xuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuXG4gIHZhciBwYXRoID0gJyc7XG5cbiAgaWYgKGJhc2VVcmwubGVuZ3RoICYmIGJhc2VVcmxbMF0gIT09ICcvJykge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcGF0aCArPSBiYXNlVXJsO1xuXG4gIGlmICgoIXBhdGgubGVuZ3RoIHx8IHBhdGhbcGF0aC5sZW5ndGggLSAxXSAhPT0gJy8nKSAmJiBmcmFnbWVudFswXSAhPT0gJy8nKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICBpZiAocGF0aC5sZW5ndGggJiYgcGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSAnLycgJiYgZnJhZ21lbnRbMF0gPT09ICcvJykge1xuICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIF9ub3JtYWxpemVBYnNvbHV0ZVBhdGgocGF0aCArIGZyYWdtZW50LCBoYXNQdXNoU3RhdGUsIGFic29sdXRlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9yZXNvbHZlVXJsKGZyYWdtZW50LCBiYXNlVXJsLCBoYXNQdXNoU3RhdGUpIHtcbiAgaWYgKGlzUm9vdGVkUGF0aC50ZXN0KGZyYWdtZW50KSkge1xuICAgIHJldHVybiBfbm9ybWFsaXplQWJzb2x1dGVQYXRoKGZyYWdtZW50LCBoYXNQdXNoU3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVSb290ZWRQYXRoKGZyYWdtZW50LCBiYXNlVXJsLCBoYXNQdXNoU3RhdGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2Vuc3VyZUFycmF5V2l0aFNpbmdsZVJvdXRlUGVyQ29uZmlnKGNvbmZpZykge1xuICB2YXIgcm91dGVDb25maWdzID0gW107XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLnJvdXRlKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvbmZpZy5yb3V0ZS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgY3VycmVudCA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyk7XG4gICAgICBjdXJyZW50LnJvdXRlID0gY29uZmlnLnJvdXRlW2ldO1xuICAgICAgcm91dGVDb25maWdzLnB1c2goY3VycmVudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJvdXRlQ29uZmlncy5wdXNoKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZykpO1xuICB9XG5cbiAgcmV0dXJuIHJvdXRlQ29uZmlncztcbn1cblxudmFyIGlzUm9vdGVkUGF0aCA9IC9eIz9cXC8vO1xudmFyIGlzQWJzb2x1dGVVcmwgPSAvXihbYS16XVthLXowLTkrXFwtLl0qOik/XFwvXFwvL2k7XG5cbmV4cG9ydCB2YXIgQ29tbWl0Q2hhbmdlc1N0ZXAgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbW1pdENoYW5nZXNTdGVwKCkge1xuICAgIFxuICB9XG5cbiAgQ29tbWl0Q2hhbmdlc1N0ZXAucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1bihuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sIG5leHQpIHtcbiAgICByZXR1cm4gbmF2aWdhdGlvbkluc3RydWN0aW9uLl9jb21taXRDaGFuZ2VzKHRydWUpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgbmF2aWdhdGlvbkluc3RydWN0aW9uLl91cGRhdGVUaXRsZSgpO1xuICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQ29tbWl0Q2hhbmdlc1N0ZXA7XG59KCk7XG5cbmV4cG9ydCB2YXIgTmF2aWdhdGlvbkluc3RydWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24oaW5pdCkge1xuICAgIFxuXG4gICAgdGhpcy5wbGFuID0gbnVsbDtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgaW5pdCk7XG5cbiAgICB0aGlzLnBhcmFtcyA9IHRoaXMucGFyYW1zIHx8IHt9O1xuICAgIHRoaXMudmlld1BvcnRJbnN0cnVjdGlvbnMgPSB7fTtcblxuICAgIHZhciBhbmNlc3RvclBhcmFtcyA9IFtdO1xuICAgIHZhciBjdXJyZW50ID0gdGhpcztcbiAgICBkbyB7XG4gICAgICB2YXIgY3VycmVudFBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIGN1cnJlbnQucGFyYW1zKTtcbiAgICAgIGlmIChjdXJyZW50LmNvbmZpZyAmJiBjdXJyZW50LmNvbmZpZy5oYXNDaGlsZFJvdXRlcikge1xuICAgICAgICBkZWxldGUgY3VycmVudFBhcmFtc1tjdXJyZW50LmdldFdpbGRDYXJkTmFtZSgpXTtcbiAgICAgIH1cblxuICAgICAgYW5jZXN0b3JQYXJhbXMudW5zaGlmdChjdXJyZW50UGFyYW1zKTtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudEluc3RydWN0aW9uO1xuICAgIH0gd2hpbGUgKGN1cnJlbnQpO1xuXG4gICAgdmFyIGFsbFBhcmFtcyA9IE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LCBbe30sIHRoaXMucXVlcnlQYXJhbXNdLmNvbmNhdChhbmNlc3RvclBhcmFtcykpO1xuICAgIHRoaXMubGlmZWN5Y2xlQXJncyA9IFthbGxQYXJhbXMsIHRoaXMuY29uZmlnLCB0aGlzXTtcbiAgfVxuXG4gIE5hdmlnYXRpb25JbnN0cnVjdGlvbi5wcm90b3R5cGUuZ2V0QWxsSW5zdHJ1Y3Rpb25zID0gZnVuY3Rpb24gZ2V0QWxsSW5zdHJ1Y3Rpb25zKCkge1xuICAgIHZhciBpbnN0cnVjdGlvbnMgPSBbdGhpc107XG4gICAgZm9yICh2YXIgX2tleSBpbiB0aGlzLnZpZXdQb3J0SW5zdHJ1Y3Rpb25zKSB7XG4gICAgICB2YXIgY2hpbGRJbnN0cnVjdGlvbiA9IHRoaXMudmlld1BvcnRJbnN0cnVjdGlvbnNbX2tleV0uY2hpbGROYXZpZ2F0aW9uSW5zdHJ1Y3Rpb247XG4gICAgICBpZiAoY2hpbGRJbnN0cnVjdGlvbikge1xuICAgICAgICBpbnN0cnVjdGlvbnMucHVzaC5hcHBseShpbnN0cnVjdGlvbnMsIGNoaWxkSW5zdHJ1Y3Rpb24uZ2V0QWxsSW5zdHJ1Y3Rpb25zKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbnN0cnVjdGlvbnM7XG4gIH07XG5cbiAgTmF2aWdhdGlvbkluc3RydWN0aW9uLnByb3RvdHlwZS5nZXRBbGxQcmV2aW91c0luc3RydWN0aW9ucyA9IGZ1bmN0aW9uIGdldEFsbFByZXZpb3VzSW5zdHJ1Y3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmdldEFsbEluc3RydWN0aW9ucygpLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGMucHJldmlvdXNJbnN0cnVjdGlvbjtcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH0pO1xuICB9O1xuXG4gIE5hdmlnYXRpb25JbnN0cnVjdGlvbi5wcm90b3R5cGUuYWRkVmlld1BvcnRJbnN0cnVjdGlvbiA9IGZ1bmN0aW9uIGFkZFZpZXdQb3J0SW5zdHJ1Y3Rpb24odmlld1BvcnROYW1lLCBzdHJhdGVneSwgbW9kdWxlSWQsIGNvbXBvbmVudCkge1xuICAgIHZhciBjb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxpZmVjeWNsZUFyZ3NbMV0sIHsgY3VycmVudFZpZXdQb3J0OiB2aWV3UG9ydE5hbWUgfSk7XG4gICAgdmFyIHZpZXdwb3J0SW5zdHJ1Y3Rpb24gPSB0aGlzLnZpZXdQb3J0SW5zdHJ1Y3Rpb25zW3ZpZXdQb3J0TmFtZV0gPSB7XG4gICAgICBuYW1lOiB2aWV3UG9ydE5hbWUsXG4gICAgICBzdHJhdGVneTogc3RyYXRlZ3ksXG4gICAgICBtb2R1bGVJZDogbW9kdWxlSWQsXG4gICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgIGNoaWxkUm91dGVyOiBjb21wb25lbnQuY2hpbGRSb3V0ZXIsXG4gICAgICBsaWZlY3ljbGVBcmdzOiBbXS5jb25jYXQodGhpcy5saWZlY3ljbGVBcmdzWzBdLCBjb25maWcsIHRoaXMubGlmZWN5Y2xlQXJnc1syXSlcbiAgICB9O1xuXG4gICAgcmV0dXJuIHZpZXdwb3J0SW5zdHJ1Y3Rpb247XG4gIH07XG5cbiAgTmF2aWdhdGlvbkluc3RydWN0aW9uLnByb3RvdHlwZS5nZXRXaWxkQ2FyZE5hbWUgPSBmdW5jdGlvbiBnZXRXaWxkQ2FyZE5hbWUoKSB7XG4gICAgdmFyIHdpbGRjYXJkSW5kZXggPSB0aGlzLmNvbmZpZy5yb3V0ZS5sYXN0SW5kZXhPZignKicpO1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5yb3V0ZS5zdWJzdHIod2lsZGNhcmRJbmRleCArIDEpO1xuICB9O1xuXG4gIE5hdmlnYXRpb25JbnN0cnVjdGlvbi5wcm90b3R5cGUuZ2V0V2lsZGNhcmRQYXRoID0gZnVuY3Rpb24gZ2V0V2lsZGNhcmRQYXRoKCkge1xuICAgIHZhciB3aWxkY2FyZE5hbWUgPSB0aGlzLmdldFdpbGRDYXJkTmFtZSgpO1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXJhbXNbd2lsZGNhcmROYW1lXSB8fCAnJztcblxuICAgIGlmICh0aGlzLnF1ZXJ5U3RyaW5nKSB7XG4gICAgICBwYXRoICs9ICc/JyArIHRoaXMucXVlcnlTdHJpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG5cbiAgTmF2aWdhdGlvbkluc3RydWN0aW9uLnByb3RvdHlwZS5nZXRCYXNlVXJsID0gZnVuY3Rpb24gZ2V0QmFzZVVybCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGZyYWdtZW50ID0gZGVjb2RlVVJJKHRoaXMuZnJhZ21lbnQpO1xuXG4gICAgaWYgKGZyYWdtZW50ID09PSAnJykge1xuICAgICAgdmFyIG5vbkVtcHR5Um91dGUgPSB0aGlzLnJvdXRlci5yb3V0ZXMuZmluZChmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgcmV0dXJuIHJvdXRlLm5hbWUgPT09IF90aGlzLmNvbmZpZy5uYW1lICYmIHJvdXRlLnJvdXRlICE9PSAnJztcbiAgICAgIH0pO1xuICAgICAgaWYgKG5vbkVtcHR5Um91dGUpIHtcbiAgICAgICAgZnJhZ21lbnQgPSBub25FbXB0eVJvdXRlLnJvdXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5wYXJhbXMpIHtcbiAgICAgIHJldHVybiBlbmNvZGVVUkkoZnJhZ21lbnQpO1xuICAgIH1cblxuICAgIHZhciB3aWxkY2FyZE5hbWUgPSB0aGlzLmdldFdpbGRDYXJkTmFtZSgpO1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXJhbXNbd2lsZGNhcmROYW1lXSB8fCAnJztcblxuICAgIGlmICghcGF0aCkge1xuICAgICAgcmV0dXJuIGVuY29kZVVSSShmcmFnbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuY29kZVVSSShmcmFnbWVudC5zdWJzdHIoMCwgZnJhZ21lbnQubGFzdEluZGV4T2YocGF0aCkpKTtcbiAgfTtcblxuICBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24ucHJvdG90eXBlLl9jb21taXRDaGFuZ2VzID0gZnVuY3Rpb24gX2NvbW1pdENoYW5nZXMod2FpdFRvU3dhcCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHJvdXRlciA9IHRoaXMucm91dGVyO1xuICAgIHJvdXRlci5jdXJyZW50SW5zdHJ1Y3Rpb24gPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMucHJldmlvdXNJbnN0cnVjdGlvbikge1xuICAgICAgdGhpcy5wcmV2aW91c0luc3RydWN0aW9uLmNvbmZpZy5uYXZNb2RlbC5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuY29uZmlnLm5hdk1vZGVsLmlzQWN0aXZlID0gdHJ1ZTtcblxuICAgIHJvdXRlci5yZWZyZXNoTmF2aWdhdGlvbigpO1xuXG4gICAgdmFyIGxvYWRzID0gW107XG4gICAgdmFyIGRlbGF5U3dhcHMgPSBbXTtcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHZpZXdQb3J0TmFtZSkge1xuICAgICAgdmFyIHZpZXdQb3J0SW5zdHJ1Y3Rpb24gPSBfdGhpczIudmlld1BvcnRJbnN0cnVjdGlvbnNbdmlld1BvcnROYW1lXTtcbiAgICAgIHZhciB2aWV3UG9ydCA9IHJvdXRlci52aWV3UG9ydHNbdmlld1BvcnROYW1lXTtcblxuICAgICAgaWYgKCF2aWV3UG9ydCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIHdhcyBubyByb3V0ZXItdmlldyBmb3VuZCBpbiB0aGUgdmlldyBmb3IgJyArIHZpZXdQb3J0SW5zdHJ1Y3Rpb24ubW9kdWxlSWQgKyAnLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmlld1BvcnRJbnN0cnVjdGlvbi5zdHJhdGVneSA9PT0gYWN0aXZhdGlvblN0cmF0ZWd5LnJlcGxhY2UpIHtcbiAgICAgICAgaWYgKHZpZXdQb3J0SW5zdHJ1Y3Rpb24uY2hpbGROYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24gJiYgdmlld1BvcnRJbnN0cnVjdGlvbi5jaGlsZE5hdmlnYXRpb25JbnN0cnVjdGlvbi5wYXJlbnRDYXRjaEhhbmRsZXIpIHtcbiAgICAgICAgICBsb2Fkcy5wdXNoKHZpZXdQb3J0SW5zdHJ1Y3Rpb24uY2hpbGROYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24uX2NvbW1pdENoYW5nZXMod2FpdFRvU3dhcCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh3YWl0VG9Td2FwKSB7XG4gICAgICAgICAgICBkZWxheVN3YXBzLnB1c2goeyB2aWV3UG9ydDogdmlld1BvcnQsIHZpZXdQb3J0SW5zdHJ1Y3Rpb246IHZpZXdQb3J0SW5zdHJ1Y3Rpb24gfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvYWRzLnB1c2godmlld1BvcnQucHJvY2Vzcyh2aWV3UG9ydEluc3RydWN0aW9uLCB3YWl0VG9Td2FwKS50aGVuKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICBpZiAodmlld1BvcnRJbnN0cnVjdGlvbi5jaGlsZE5hdmlnYXRpb25JbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgICByZXR1cm4gdmlld1BvcnRJbnN0cnVjdGlvbi5jaGlsZE5hdmlnYXRpb25JbnN0cnVjdGlvbi5fY29tbWl0Q2hhbmdlcyh3YWl0VG9Td2FwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2aWV3UG9ydEluc3RydWN0aW9uLmNoaWxkTmF2aWdhdGlvbkluc3RydWN0aW9uKSB7XG4gICAgICAgICAgbG9hZHMucHVzaCh2aWV3UG9ydEluc3RydWN0aW9uLmNoaWxkTmF2aWdhdGlvbkluc3RydWN0aW9uLl9jb21taXRDaGFuZ2VzKHdhaXRUb1N3YXApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciB2aWV3UG9ydE5hbWUgaW4gdGhpcy52aWV3UG9ydEluc3RydWN0aW9ucykge1xuICAgICAgX2xvb3Aodmlld1BvcnROYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwobG9hZHMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgZGVsYXlTd2Fwcy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LnZpZXdQb3J0LnN3YXAoeC52aWV3UG9ydEluc3RydWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcHJ1bmUoX3RoaXMyKTtcbiAgICB9KTtcbiAgfTtcblxuICBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24ucHJvdG90eXBlLl91cGRhdGVUaXRsZSA9IGZ1bmN0aW9uIF91cGRhdGVUaXRsZSgpIHtcbiAgICB2YXIgdGl0bGUgPSB0aGlzLl9idWlsZFRpdGxlKHRoaXMucm91dGVyLnRpdGxlU2VwYXJhdG9yKTtcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIHRoaXMucm91dGVyLmhpc3Rvcnkuc2V0VGl0bGUodGl0bGUpO1xuICAgIH1cbiAgfTtcblxuICBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24ucHJvdG90eXBlLl9idWlsZFRpdGxlID0gZnVuY3Rpb24gX2J1aWxkVGl0bGUoKSB7XG4gICAgdmFyIHNlcGFyYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyB8ICc7XG5cbiAgICB2YXIgdGl0bGUgPSAnJztcbiAgICB2YXIgY2hpbGRUaXRsZXMgPSBbXTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy5uYXZNb2RlbC50aXRsZSkge1xuICAgICAgdGl0bGUgPSB0aGlzLnJvdXRlci50cmFuc2Zvcm1UaXRsZSh0aGlzLmNvbmZpZy5uYXZNb2RlbC50aXRsZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgdmlld1BvcnROYW1lIGluIHRoaXMudmlld1BvcnRJbnN0cnVjdGlvbnMpIHtcbiAgICAgIHZhciBfdmlld1BvcnRJbnN0cnVjdGlvbiA9IHRoaXMudmlld1BvcnRJbnN0cnVjdGlvbnNbdmlld1BvcnROYW1lXTtcblxuICAgICAgaWYgKF92aWV3UG9ydEluc3RydWN0aW9uLmNoaWxkTmF2aWdhdGlvbkluc3RydWN0aW9uKSB7XG4gICAgICAgIHZhciBjaGlsZFRpdGxlID0gX3ZpZXdQb3J0SW5zdHJ1Y3Rpb24uY2hpbGROYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24uX2J1aWxkVGl0bGUoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKGNoaWxkVGl0bGUpIHtcbiAgICAgICAgICBjaGlsZFRpdGxlcy5wdXNoKGNoaWxkVGl0bGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkVGl0bGVzLmxlbmd0aCkge1xuICAgICAgdGl0bGUgPSBjaGlsZFRpdGxlcy5qb2luKHNlcGFyYXRvcikgKyAodGl0bGUgPyBzZXBhcmF0b3IgOiAnJykgKyB0aXRsZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yb3V0ZXIudGl0bGUpIHtcbiAgICAgIHRpdGxlICs9ICh0aXRsZSA/IHNlcGFyYXRvciA6ICcnKSArIHRoaXMucm91dGVyLnRyYW5zZm9ybVRpdGxlKHRoaXMucm91dGVyLnRpdGxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGl0bGU7XG4gIH07XG5cbiAgcmV0dXJuIE5hdmlnYXRpb25JbnN0cnVjdGlvbjtcbn0oKTtcblxuZnVuY3Rpb24gcHJ1bmUoaW5zdHJ1Y3Rpb24pIHtcbiAgaW5zdHJ1Y3Rpb24ucHJldmlvdXNJbnN0cnVjdGlvbiA9IG51bGw7XG4gIGluc3RydWN0aW9uLnBsYW4gPSBudWxsO1xufVxuXG5leHBvcnQgdmFyIE5hdk1vZGVsID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOYXZNb2RlbChyb3V0ZXIsIHJlbGF0aXZlSHJlZikge1xuICAgIFxuXG4gICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMudGl0bGUgPSBudWxsO1xuICAgIHRoaXMuaHJlZiA9IG51bGw7XG4gICAgdGhpcy5yZWxhdGl2ZUhyZWYgPSBudWxsO1xuICAgIHRoaXMuc2V0dGluZ3MgPSB7fTtcbiAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG5cbiAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICB0aGlzLnJlbGF0aXZlSHJlZiA9IHJlbGF0aXZlSHJlZjtcbiAgfVxuXG4gIE5hdk1vZGVsLnByb3RvdHlwZS5zZXRUaXRsZSA9IGZ1bmN0aW9uIHNldFRpdGxlKHRpdGxlKSB7XG4gICAgdGhpcy50aXRsZSA9IHRpdGxlO1xuXG4gICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgIHRoaXMucm91dGVyLnVwZGF0ZVRpdGxlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBOYXZNb2RlbDtcbn0oKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTmF2aWdhdGlvbkNvbW1hbmQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIG9iai5uYXZpZ2F0ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IHZhciBSZWRpcmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVkaXJlY3QodXJsKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgXG5cbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgdHJpZ2dlcjogdHJ1ZSwgcmVwbGFjZTogdHJ1ZSB9LCBvcHRpb25zKTtcbiAgICB0aGlzLnNob3VsZENvbnRpbnVlUHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLnNldFJvdXRlciA9IGZ1bmN0aW9uIHNldFJvdXRlcihyb3V0ZXIpIHtcbiAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUubmF2aWdhdGUgPSBmdW5jdGlvbiBuYXZpZ2F0ZShhcHBSb3V0ZXIpIHtcbiAgICB2YXIgbmF2aWdhdGluZ1JvdXRlciA9IHRoaXMub3B0aW9ucy51c2VBcHBSb3V0ZXIgPyBhcHBSb3V0ZXIgOiB0aGlzLnJvdXRlciB8fCBhcHBSb3V0ZXI7XG4gICAgbmF2aWdhdGluZ1JvdXRlci5uYXZpZ2F0ZSh0aGlzLnVybCwgdGhpcy5vcHRpb25zKTtcbiAgfTtcblxuICByZXR1cm4gUmVkaXJlY3Q7XG59KCk7XG5cbmV4cG9ydCB2YXIgUmVkaXJlY3RUb1JvdXRlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZWRpcmVjdFRvUm91dGUocm91dGUpIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICBcblxuICAgIHRoaXMucm91dGUgPSByb3V0ZTtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgdHJpZ2dlcjogdHJ1ZSwgcmVwbGFjZTogdHJ1ZSB9LCBvcHRpb25zKTtcbiAgICB0aGlzLnNob3VsZENvbnRpbnVlUHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG5cbiAgUmVkaXJlY3RUb1JvdXRlLnByb3RvdHlwZS5zZXRSb3V0ZXIgPSBmdW5jdGlvbiBzZXRSb3V0ZXIocm91dGVyKSB7XG4gICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gIH07XG5cbiAgUmVkaXJlY3RUb1JvdXRlLnByb3RvdHlwZS5uYXZpZ2F0ZSA9IGZ1bmN0aW9uIG5hdmlnYXRlKGFwcFJvdXRlcikge1xuICAgIHZhciBuYXZpZ2F0aW5nUm91dGVyID0gdGhpcy5vcHRpb25zLnVzZUFwcFJvdXRlciA/IGFwcFJvdXRlciA6IHRoaXMucm91dGVyIHx8IGFwcFJvdXRlcjtcbiAgICBuYXZpZ2F0aW5nUm91dGVyLm5hdmlnYXRlVG9Sb3V0ZSh0aGlzLnJvdXRlLCB0aGlzLnBhcmFtcywgdGhpcy5vcHRpb25zKTtcbiAgfTtcblxuICByZXR1cm4gUmVkaXJlY3RUb1JvdXRlO1xufSgpO1xuXG5leHBvcnQgdmFyIHBpcGVsaW5lU3RhdHVzID0ge1xuICBjb21wbGV0ZWQ6ICdjb21wbGV0ZWQnLFxuICBjYW5jZWxlZDogJ2NhbmNlbGVkJyxcbiAgcmVqZWN0ZWQ6ICdyZWplY3RlZCcsXG4gIHJ1bm5pbmc6ICdydW5uaW5nJ1xufTtcblxuZXhwb3J0IHZhciBQaXBlbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGlwZWxpbmUoKSB7XG4gICAgXG5cbiAgICB0aGlzLnN0ZXBzID0gW107XG4gIH1cblxuICBQaXBlbGluZS5wcm90b3R5cGUuYWRkU3RlcCA9IGZ1bmN0aW9uIGFkZFN0ZXAoc3RlcCkge1xuICAgIHZhciBydW4gPSB2b2lkIDA7XG5cbiAgICBpZiAodHlwZW9mIHN0ZXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJ1biA9IHN0ZXA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RlcC5nZXRTdGVwcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHN0ZXBzID0gc3RlcC5nZXRTdGVwcygpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdGVwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGRTdGVwKHN0ZXBzW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ1biA9IHN0ZXAucnVuLmJpbmQoc3RlcCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGVwcy5wdXNoKHJ1bik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBQaXBlbGluZS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuKGluc3RydWN0aW9uKSB7XG4gICAgdmFyIGluZGV4ID0gLTE7XG4gICAgdmFyIHN0ZXBzID0gdGhpcy5zdGVwcztcblxuICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICBpbmRleCsrO1xuXG4gICAgICBpZiAoaW5kZXggPCBzdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGVwID0gc3RlcHNbaW5kZXhdO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRTdGVwKGluc3RydWN0aW9uLCBuZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBuZXh0LnJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5leHQuY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuZXh0LmNvbXBsZXRlID0gY3JlYXRlQ29tcGxldGlvbkhhbmRsZXIobmV4dCwgcGlwZWxpbmVTdGF0dXMuY29tcGxldGVkKTtcbiAgICBuZXh0LmNhbmNlbCA9IGNyZWF0ZUNvbXBsZXRpb25IYW5kbGVyKG5leHQsIHBpcGVsaW5lU3RhdHVzLmNhbmNlbGVkKTtcbiAgICBuZXh0LnJlamVjdCA9IGNyZWF0ZUNvbXBsZXRpb25IYW5kbGVyKG5leHQsIHBpcGVsaW5lU3RhdHVzLnJlamVjdGVkKTtcblxuICAgIHJldHVybiBuZXh0KCk7XG4gIH07XG5cbiAgcmV0dXJuIFBpcGVsaW5lO1xufSgpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wbGV0aW9uSGFuZGxlcihuZXh0LCBzdGF0dXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvdXRwdXQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgc3RhdHVzOiBzdGF0dXMsIG91dHB1dDogb3V0cHV0LCBjb21wbGV0ZWQ6IHN0YXR1cyA9PT0gcGlwZWxpbmVTdGF0dXMuY29tcGxldGVkIH0pO1xuICB9O1xufVxuXG5leHBvcnQgdmFyIFJvdXRlckNvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJvdXRlckNvbmZpZ3VyYXRpb24oKSB7XG4gICAgXG5cbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IFtdO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMucGlwZWxpbmVTdGVwcyA9IFtdO1xuICB9XG5cbiAgUm91dGVyQ29uZmlndXJhdGlvbi5wcm90b3R5cGUuYWRkUGlwZWxpbmVTdGVwID0gZnVuY3Rpb24gYWRkUGlwZWxpbmVTdGVwKG5hbWUsIHN0ZXApIHtcbiAgICBpZiAoc3RlcCA9PT0gbnVsbCB8fCBzdGVwID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGlwZWxpbmUgc3RlcCBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJyk7XG4gICAgfVxuICAgIHRoaXMucGlwZWxpbmVTdGVwcy5wdXNoKHsgbmFtZTogbmFtZSwgc3RlcDogc3RlcCB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBSb3V0ZXJDb25maWd1cmF0aW9uLnByb3RvdHlwZS5hZGRBdXRob3JpemVTdGVwID0gZnVuY3Rpb24gYWRkQXV0aG9yaXplU3RlcChzdGVwKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkUGlwZWxpbmVTdGVwKCdhdXRob3JpemUnLCBzdGVwKTtcbiAgfTtcblxuICBSb3V0ZXJDb25maWd1cmF0aW9uLnByb3RvdHlwZS5hZGRQcmVBY3RpdmF0ZVN0ZXAgPSBmdW5jdGlvbiBhZGRQcmVBY3RpdmF0ZVN0ZXAoc3RlcCkge1xuICAgIHJldHVybiB0aGlzLmFkZFBpcGVsaW5lU3RlcCgncHJlQWN0aXZhdGUnLCBzdGVwKTtcbiAgfTtcblxuICBSb3V0ZXJDb25maWd1cmF0aW9uLnByb3RvdHlwZS5hZGRQcmVSZW5kZXJTdGVwID0gZnVuY3Rpb24gYWRkUHJlUmVuZGVyU3RlcChzdGVwKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkUGlwZWxpbmVTdGVwKCdwcmVSZW5kZXInLCBzdGVwKTtcbiAgfTtcblxuICBSb3V0ZXJDb25maWd1cmF0aW9uLnByb3RvdHlwZS5hZGRQb3N0UmVuZGVyU3RlcCA9IGZ1bmN0aW9uIGFkZFBvc3RSZW5kZXJTdGVwKHN0ZXApIHtcbiAgICByZXR1cm4gdGhpcy5hZGRQaXBlbGluZVN0ZXAoJ3Bvc3RSZW5kZXInLCBzdGVwKTtcbiAgfTtcblxuICBSb3V0ZXJDb25maWd1cmF0aW9uLnByb3RvdHlwZS5mYWxsYmFja1JvdXRlID0gZnVuY3Rpb24gZmFsbGJhY2tSb3V0ZShmcmFnbWVudCkge1xuICAgIHRoaXMuX2ZhbGxiYWNrUm91dGUgPSBmcmFnbWVudDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBSb3V0ZXJDb25maWd1cmF0aW9uLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAocm91dGUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyb3V0ZSkpIHtcbiAgICAgIHJvdXRlLmZvckVhY2godGhpcy5tYXAuYmluZCh0aGlzKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tYXBSb3V0ZShyb3V0ZSk7XG4gIH07XG5cbiAgUm91dGVyQ29uZmlndXJhdGlvbi5wcm90b3R5cGUudXNlVmlld1BvcnREZWZhdWx0cyA9IGZ1bmN0aW9uIHVzZVZpZXdQb3J0RGVmYXVsdHModmlld1BvcnRDb25maWcpIHtcbiAgICB0aGlzLnZpZXdQb3J0RGVmYXVsdHMgPSB2aWV3UG9ydENvbmZpZztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBSb3V0ZXJDb25maWd1cmF0aW9uLnByb3RvdHlwZS5tYXBSb3V0ZSA9IGZ1bmN0aW9uIG1hcFJvdXRlKGNvbmZpZykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goZnVuY3Rpb24gKHJvdXRlcikge1xuICAgICAgdmFyIHJvdXRlQ29uZmlncyA9IF9lbnN1cmVBcnJheVdpdGhTaW5nbGVSb3V0ZVBlckNvbmZpZyhjb25maWcpO1xuXG4gICAgICB2YXIgbmF2TW9kZWwgPSB2b2lkIDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSByb3V0ZUNvbmZpZ3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB2YXIgX3JvdXRlQ29uZmlnID0gcm91dGVDb25maWdzW2ldO1xuICAgICAgICBfcm91dGVDb25maWcuc2V0dGluZ3MgPSBfcm91dGVDb25maWcuc2V0dGluZ3MgfHwge307XG4gICAgICAgIGlmICghbmF2TW9kZWwpIHtcbiAgICAgICAgICBuYXZNb2RlbCA9IHJvdXRlci5jcmVhdGVOYXZNb2RlbChfcm91dGVDb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcm91dGVyLmFkZFJvdXRlKF9yb3V0ZUNvbmZpZywgbmF2TW9kZWwpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgUm91dGVyQ29uZmlndXJhdGlvbi5wcm90b3R5cGUubWFwVW5rbm93blJvdXRlcyA9IGZ1bmN0aW9uIG1hcFVua25vd25Sb3V0ZXMoY29uZmlnKSB7XG4gICAgdGhpcy51bmtub3duUm91dGVDb25maWcgPSBjb25maWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgUm91dGVyQ29uZmlndXJhdGlvbi5wcm90b3R5cGUuZXhwb3J0VG9Sb3V0ZXIgPSBmdW5jdGlvbiBleHBvcnRUb1JvdXRlcihyb3V0ZXIpIHtcbiAgICB2YXIgaW5zdHJ1Y3Rpb25zID0gdGhpcy5pbnN0cnVjdGlvbnM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGluc3RydWN0aW9uc1tpXShyb3V0ZXIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRpdGxlKSB7XG4gICAgICByb3V0ZXIudGl0bGUgPSB0aGlzLnRpdGxlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRpdGxlU2VwYXJhdG9yKSB7XG4gICAgICByb3V0ZXIudGl0bGVTZXBhcmF0b3IgPSB0aGlzLnRpdGxlU2VwYXJhdG9yO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnVua25vd25Sb3V0ZUNvbmZpZykge1xuICAgICAgcm91dGVyLmhhbmRsZVVua25vd25Sb3V0ZXModGhpcy51bmtub3duUm91dGVDb25maWcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9mYWxsYmFja1JvdXRlKSB7XG4gICAgICByb3V0ZXIuZmFsbGJhY2tSb3V0ZSA9IHRoaXMuX2ZhbGxiYWNrUm91dGU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudmlld1BvcnREZWZhdWx0cykge1xuICAgICAgcm91dGVyLnVzZVZpZXdQb3J0RGVmYXVsdHModGhpcy52aWV3UG9ydERlZmF1bHRzKTtcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKHJvdXRlci5vcHRpb25zLCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgdmFyIHBpcGVsaW5lU3RlcHMgPSB0aGlzLnBpcGVsaW5lU3RlcHM7XG4gICAgaWYgKHBpcGVsaW5lU3RlcHMubGVuZ3RoKSB7XG4gICAgICBpZiAoIXJvdXRlci5pc1Jvb3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQaXBlbGluZSBzdGVwcyBjYW4gb25seSBiZSBhZGRlZCB0byB0aGUgcm9vdCByb3V0ZXInKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBpcGVsaW5lUHJvdmlkZXIgPSByb3V0ZXIucGlwZWxpbmVQcm92aWRlcjtcbiAgICAgIGZvciAodmFyIF9pID0gMCwgX2lpID0gcGlwZWxpbmVTdGVwcy5sZW5ndGg7IF9pIDwgX2lpOyArK19pKSB7XG4gICAgICAgIHZhciBfcGlwZWxpbmVTdGVwcyRfaSA9IHBpcGVsaW5lU3RlcHNbX2ldLFxuICAgICAgICAgICAgX25hbWUgPSBfcGlwZWxpbmVTdGVwcyRfaS5uYW1lLFxuICAgICAgICAgICAgX3N0ZXAgPSBfcGlwZWxpbmVTdGVwcyRfaS5zdGVwO1xuXG4gICAgICAgIHBpcGVsaW5lUHJvdmlkZXIuYWRkU3RlcChfbmFtZSwgX3N0ZXApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUm91dGVyQ29uZmlndXJhdGlvbjtcbn0oKTtcblxuZXhwb3J0IHZhciBhY3RpdmF0aW9uU3RyYXRlZ3kgPSB7XG4gIG5vQ2hhbmdlOiAnbm8tY2hhbmdlJyxcbiAgaW52b2tlTGlmZWN5Y2xlOiAnaW52b2tlLWxpZmVjeWNsZScsXG4gIHJlcGxhY2U6ICdyZXBsYWNlJ1xufTtcblxuZXhwb3J0IHZhciBCdWlsZE5hdmlnYXRpb25QbGFuU3RlcCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVpbGROYXZpZ2F0aW9uUGxhblN0ZXAoKSB7XG4gICAgXG4gIH1cblxuICBCdWlsZE5hdmlnYXRpb25QbGFuU3RlcC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuKG5hdmlnYXRpb25JbnN0cnVjdGlvbiwgbmV4dCkge1xuICAgIHJldHVybiBfYnVpbGROYXZpZ2F0aW9uUGxhbihuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24pLnRoZW4oZnVuY3Rpb24gKHBsYW4pIHtcbiAgICAgIGlmIChwbGFuIGluc3RhbmNlb2YgUmVkaXJlY3QpIHtcbiAgICAgICAgcmV0dXJuIG5leHQuY2FuY2VsKHBsYW4pO1xuICAgICAgfVxuICAgICAgbmF2aWdhdGlvbkluc3RydWN0aW9uLnBsYW4gPSBwbGFuO1xuICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9KS5jYXRjaChuZXh0LmNhbmNlbCk7XG4gIH07XG5cbiAgcmV0dXJuIEJ1aWxkTmF2aWdhdGlvblBsYW5TdGVwO1xufSgpO1xuXG5leHBvcnQgZnVuY3Rpb24gX2J1aWxkTmF2aWdhdGlvblBsYW4oaW5zdHJ1Y3Rpb24sIGZvcmNlTGlmZWN5Y2xlTWluaW11bSkge1xuICB2YXIgY29uZmlnID0gaW5zdHJ1Y3Rpb24uY29uZmlnO1xuXG4gIGlmICgncmVkaXJlY3QnIGluIGNvbmZpZykge1xuICAgIHZhciBfcm91dGVyID0gaW5zdHJ1Y3Rpb24ucm91dGVyO1xuICAgIHJldHVybiBfcm91dGVyLl9jcmVhdGVOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24oY29uZmlnLnJlZGlyZWN0KS50aGVuKGZ1bmN0aW9uIChuZXdJbnN0cnVjdGlvbikge1xuICAgICAgdmFyIHBhcmFtcyA9IHt9O1xuICAgICAgZm9yICh2YXIgX2tleTIgaW4gbmV3SW5zdHJ1Y3Rpb24ucGFyYW1zKSB7XG4gICAgICAgIHZhciB2YWwgPSBuZXdJbnN0cnVjdGlvbi5wYXJhbXNbX2tleTJdO1xuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgdmFsWzBdID09PSAnOicpIHtcbiAgICAgICAgICB2YWwgPSB2YWwuc2xpY2UoMSk7XG5cbiAgICAgICAgICBpZiAodmFsIGluIGluc3RydWN0aW9uLnBhcmFtcykge1xuICAgICAgICAgICAgcGFyYW1zW19rZXkyXSA9IGluc3RydWN0aW9uLnBhcmFtc1t2YWxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJhbXNbX2tleTJdID0gbmV3SW5zdHJ1Y3Rpb24ucGFyYW1zW19rZXkyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHJlZGlyZWN0TG9jYXRpb24gPSBfcm91dGVyLmdlbmVyYXRlKG5ld0luc3RydWN0aW9uLmNvbmZpZy5uYW1lLCBwYXJhbXMsIGluc3RydWN0aW9uLm9wdGlvbnMpO1xuXG4gICAgICBpZiAoaW5zdHJ1Y3Rpb24ucXVlcnlTdHJpbmcpIHtcbiAgICAgICAgcmVkaXJlY3RMb2NhdGlvbiArPSAnPycgKyBpbnN0cnVjdGlvbi5xdWVyeVN0cmluZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgUmVkaXJlY3QocmVkaXJlY3RMb2NhdGlvbikpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHByZXYgPSBpbnN0cnVjdGlvbi5wcmV2aW91c0luc3RydWN0aW9uO1xuICB2YXIgcGxhbiA9IHt9O1xuICB2YXIgZGVmYXVsdHMgPSBpbnN0cnVjdGlvbi5yb3V0ZXIudmlld1BvcnREZWZhdWx0cztcblxuICBpZiAocHJldikge1xuICAgIHZhciBuZXdQYXJhbXMgPSBoYXNEaWZmZXJlbnRQYXJhbWV0ZXJWYWx1ZXMocHJldiwgaW5zdHJ1Y3Rpb24pO1xuICAgIHZhciBwZW5kaW5nID0gW107XG5cbiAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKHZpZXdQb3J0TmFtZSkge1xuICAgICAgdmFyIHByZXZWaWV3UG9ydEluc3RydWN0aW9uID0gcHJldi52aWV3UG9ydEluc3RydWN0aW9uc1t2aWV3UG9ydE5hbWVdO1xuICAgICAgdmFyIG5leHRWaWV3UG9ydENvbmZpZyA9IHZpZXdQb3J0TmFtZSBpbiBjb25maWcudmlld1BvcnRzID8gY29uZmlnLnZpZXdQb3J0c1t2aWV3UG9ydE5hbWVdIDogcHJldlZpZXdQb3J0SW5zdHJ1Y3Rpb247XG4gICAgICBpZiAobmV4dFZpZXdQb3J0Q29uZmlnLm1vZHVsZUlkID09PSBudWxsICYmIHZpZXdQb3J0TmFtZSBpbiBpbnN0cnVjdGlvbi5yb3V0ZXIudmlld1BvcnREZWZhdWx0cykge1xuICAgICAgICBuZXh0Vmlld1BvcnRDb25maWcgPSBkZWZhdWx0c1t2aWV3UG9ydE5hbWVdO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmlld1BvcnRQbGFuID0gcGxhblt2aWV3UG9ydE5hbWVdID0ge1xuICAgICAgICBuYW1lOiB2aWV3UG9ydE5hbWUsXG4gICAgICAgIGNvbmZpZzogbmV4dFZpZXdQb3J0Q29uZmlnLFxuICAgICAgICBwcmV2Q29tcG9uZW50OiBwcmV2Vmlld1BvcnRJbnN0cnVjdGlvbi5jb21wb25lbnQsXG4gICAgICAgIHByZXZNb2R1bGVJZDogcHJldlZpZXdQb3J0SW5zdHJ1Y3Rpb24ubW9kdWxlSWRcbiAgICAgIH07XG5cbiAgICAgIGlmIChwcmV2Vmlld1BvcnRJbnN0cnVjdGlvbi5tb2R1bGVJZCAhPT0gbmV4dFZpZXdQb3J0Q29uZmlnLm1vZHVsZUlkKSB7XG4gICAgICAgIHZpZXdQb3J0UGxhbi5zdHJhdGVneSA9IGFjdGl2YXRpb25TdHJhdGVneS5yZXBsYWNlO1xuICAgICAgfSBlbHNlIGlmICgnZGV0ZXJtaW5lQWN0aXZhdGlvblN0cmF0ZWd5JyBpbiBwcmV2Vmlld1BvcnRJbnN0cnVjdGlvbi5jb21wb25lbnQudmlld01vZGVsKSB7XG4gICAgICAgIHZhciBfcHJldlZpZXdQb3J0SW5zdHJ1Y3Q7XG5cbiAgICAgICAgdmlld1BvcnRQbGFuLnN0cmF0ZWd5ID0gKF9wcmV2Vmlld1BvcnRJbnN0cnVjdCA9IHByZXZWaWV3UG9ydEluc3RydWN0aW9uLmNvbXBvbmVudC52aWV3TW9kZWwpLmRldGVybWluZUFjdGl2YXRpb25TdHJhdGVneS5hcHBseShfcHJldlZpZXdQb3J0SW5zdHJ1Y3QsIGluc3RydWN0aW9uLmxpZmVjeWNsZUFyZ3MpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcuYWN0aXZhdGlvblN0cmF0ZWd5KSB7XG4gICAgICAgIHZpZXdQb3J0UGxhbi5zdHJhdGVneSA9IGNvbmZpZy5hY3RpdmF0aW9uU3RyYXRlZ3k7XG4gICAgICB9IGVsc2UgaWYgKG5ld1BhcmFtcyB8fCBmb3JjZUxpZmVjeWNsZU1pbmltdW0pIHtcbiAgICAgICAgdmlld1BvcnRQbGFuLnN0cmF0ZWd5ID0gYWN0aXZhdGlvblN0cmF0ZWd5Lmludm9rZUxpZmVjeWNsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZpZXdQb3J0UGxhbi5zdHJhdGVneSA9IGFjdGl2YXRpb25TdHJhdGVneS5ub0NoYW5nZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZpZXdQb3J0UGxhbi5zdHJhdGVneSAhPT0gYWN0aXZhdGlvblN0cmF0ZWd5LnJlcGxhY2UgJiYgcHJldlZpZXdQb3J0SW5zdHJ1Y3Rpb24uY2hpbGRSb3V0ZXIpIHtcbiAgICAgICAgdmFyIHBhdGggPSBpbnN0cnVjdGlvbi5nZXRXaWxkY2FyZFBhdGgoKTtcbiAgICAgICAgdmFyIHRhc2sgPSBwcmV2Vmlld1BvcnRJbnN0cnVjdGlvbi5jaGlsZFJvdXRlci5fY3JlYXRlTmF2aWdhdGlvbkluc3RydWN0aW9uKHBhdGgsIGluc3RydWN0aW9uKS50aGVuKGZ1bmN0aW9uIChjaGlsZEluc3RydWN0aW9uKSB7XG4gICAgICAgICAgdmlld1BvcnRQbGFuLmNoaWxkTmF2aWdhdGlvbkluc3RydWN0aW9uID0gY2hpbGRJbnN0cnVjdGlvbjtcblxuICAgICAgICAgIHJldHVybiBfYnVpbGROYXZpZ2F0aW9uUGxhbihjaGlsZEluc3RydWN0aW9uLCB2aWV3UG9ydFBsYW4uc3RyYXRlZ3kgPT09IGFjdGl2YXRpb25TdHJhdGVneS5pbnZva2VMaWZlY3ljbGUpLnRoZW4oZnVuY3Rpb24gKGNoaWxkUGxhbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkUGxhbiBpbnN0YW5jZW9mIFJlZGlyZWN0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjaGlsZFBsYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGRJbnN0cnVjdGlvbi5wbGFuID0gY2hpbGRQbGFuO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBwZW5kaW5nLnB1c2godGFzayk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIHZpZXdQb3J0TmFtZSBpbiBwcmV2LnZpZXdQb3J0SW5zdHJ1Y3Rpb25zKSB7XG4gICAgICBfbG9vcDIodmlld1BvcnROYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGxhbjtcbiAgICB9KTtcbiAgfVxuXG4gIGZvciAodmFyIHZpZXdQb3J0TmFtZSBpbiBjb25maWcudmlld1BvcnRzKSB7XG4gICAgdmFyIHZpZXdQb3J0Q29uZmlnID0gY29uZmlnLnZpZXdQb3J0c1t2aWV3UG9ydE5hbWVdO1xuICAgIGlmICh2aWV3UG9ydENvbmZpZy5tb2R1bGVJZCA9PT0gbnVsbCAmJiB2aWV3UG9ydE5hbWUgaW4gaW5zdHJ1Y3Rpb24ucm91dGVyLnZpZXdQb3J0RGVmYXVsdHMpIHtcbiAgICAgIHZpZXdQb3J0Q29uZmlnID0gZGVmYXVsdHNbdmlld1BvcnROYW1lXTtcbiAgICB9XG4gICAgcGxhblt2aWV3UG9ydE5hbWVdID0ge1xuICAgICAgbmFtZTogdmlld1BvcnROYW1lLFxuICAgICAgc3RyYXRlZ3k6IGFjdGl2YXRpb25TdHJhdGVneS5yZXBsYWNlLFxuICAgICAgY29uZmlnOiB2aWV3UG9ydENvbmZpZ1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBsYW4pO1xufVxuXG5mdW5jdGlvbiBoYXNEaWZmZXJlbnRQYXJhbWV0ZXJWYWx1ZXMocHJldiwgbmV4dCkge1xuICB2YXIgcHJldlBhcmFtcyA9IHByZXYucGFyYW1zO1xuICB2YXIgbmV4dFBhcmFtcyA9IG5leHQucGFyYW1zO1xuICB2YXIgbmV4dFdpbGRDYXJkTmFtZSA9IG5leHQuY29uZmlnLmhhc0NoaWxkUm91dGVyID8gbmV4dC5nZXRXaWxkQ2FyZE5hbWUoKSA6IG51bGw7XG5cbiAgZm9yICh2YXIgX2tleTMgaW4gbmV4dFBhcmFtcykge1xuICAgIGlmIChfa2V5MyA9PT0gbmV4dFdpbGRDYXJkTmFtZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHByZXZQYXJhbXNbX2tleTNdICE9PSBuZXh0UGFyYW1zW19rZXkzXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX2tleTQgaW4gcHJldlBhcmFtcykge1xuICAgIGlmIChfa2V5NCA9PT0gbmV4dFdpbGRDYXJkTmFtZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHByZXZQYXJhbXNbX2tleTRdICE9PSBuZXh0UGFyYW1zW19rZXk0XSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFuZXh0Lm9wdGlvbnMuY29tcGFyZVF1ZXJ5UGFyYW1zKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHByZXZRdWVyeVBhcmFtcyA9IHByZXYucXVlcnlQYXJhbXM7XG4gIHZhciBuZXh0UXVlcnlQYXJhbXMgPSBuZXh0LnF1ZXJ5UGFyYW1zO1xuICBmb3IgKHZhciBfa2V5NSBpbiBuZXh0UXVlcnlQYXJhbXMpIHtcbiAgICBpZiAocHJldlF1ZXJ5UGFyYW1zW19rZXk1XSAhPT0gbmV4dFF1ZXJ5UGFyYW1zW19rZXk1XSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX2tleTYgaW4gcHJldlF1ZXJ5UGFyYW1zKSB7XG4gICAgaWYgKHByZXZRdWVyeVBhcmFtc1tfa2V5Nl0gIT09IG5leHRRdWVyeVBhcmFtc1tfa2V5Nl0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IHZhciBSb3V0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJvdXRlcihjb250YWluZXIsIGhpc3RvcnkpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIFxuXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMudmlld1BvcnREZWZhdWx0cyA9IHt9O1xuXG4gICAgdGhpcy50cmFuc2Zvcm1UaXRsZSA9IGZ1bmN0aW9uICh0aXRsZSkge1xuICAgICAgaWYgKF90aGlzMy5wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5wYXJlbnQudHJhbnNmb3JtVGl0bGUodGl0bGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRpdGxlO1xuICAgIH07XG5cbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLmhpc3RvcnkgPSBoaXN0b3J5O1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG4gIFJvdXRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIHRoaXMudmlld1BvcnRzID0ge307XG4gICAgdGhpcy5yb3V0ZXMgPSBbXTtcbiAgICB0aGlzLmJhc2VVcmwgPSAnJztcbiAgICB0aGlzLmlzQ29uZmlndXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNOYXZpZ2F0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5pc0V4cGxpY2l0TmF2aWdhdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuaXNFeHBsaWNpdE5hdmlnYXRpb25CYWNrID0gZmFsc2U7XG4gICAgdGhpcy5pc05hdmlnYXRpbmdGaXJzdCA9IGZhbHNlO1xuICAgIHRoaXMuaXNOYXZpZ2F0aW5nTmV3ID0gZmFsc2U7XG4gICAgdGhpcy5pc05hdmlnYXRpbmdSZWZyZXNoID0gZmFsc2U7XG4gICAgdGhpcy5pc05hdmlnYXRpbmdGb3J3YXJkID0gZmFsc2U7XG4gICAgdGhpcy5pc05hdmlnYXRpbmdCYWNrID0gZmFsc2U7XG4gICAgdGhpcy5jb3VsZERlYWN0aXZhdGUgPSBmYWxzZTtcbiAgICB0aGlzLm5hdmlnYXRpb24gPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRJbnN0cnVjdGlvbiA9IG51bGw7XG4gICAgdGhpcy52aWV3UG9ydERlZmF1bHRzID0ge307XG4gICAgdGhpcy5fZmFsbGJhY2tPcmRlciA9IDEwMDtcbiAgICB0aGlzLl9yZWNvZ25pemVyID0gbmV3IFJvdXRlUmVjb2duaXplcigpO1xuICAgIHRoaXMuX2NoaWxkUmVjb2duaXplciA9IG5ldyBSb3V0ZVJlY29nbml6ZXIoKTtcbiAgICB0aGlzLl9jb25maWd1cmVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBfdGhpczQuX3Jlc29sdmVDb25maWd1cmVkUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgfSk7XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5yZWdpc3RlclZpZXdQb3J0ID0gZnVuY3Rpb24gcmVnaXN0ZXJWaWV3UG9ydCh2aWV3UG9ydCwgbmFtZSkge1xuICAgIG5hbWUgPSBuYW1lIHx8ICdkZWZhdWx0JztcbiAgICB0aGlzLnZpZXdQb3J0c1tuYW1lXSA9IHZpZXdQb3J0O1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUuZW5zdXJlQ29uZmlndXJlZCA9IGZ1bmN0aW9uIGVuc3VyZUNvbmZpZ3VyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZ3VyZWRQcm9taXNlO1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gY29uZmlndXJlKGNhbGxiYWNrT3JDb25maWcpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIHRoaXMuaXNDb25maWd1cmVkID0gdHJ1ZTtcblxuICAgIHZhciByZXN1bHQgPSBjYWxsYmFja09yQ29uZmlnO1xuICAgIHZhciBjb25maWcgPSB2b2lkIDA7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFja09yQ29uZmlnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25maWcgPSBuZXcgUm91dGVyQ29uZmlndXJhdGlvbigpO1xuICAgICAgcmVzdWx0ID0gY2FsbGJhY2tPckNvbmZpZyhjb25maWcpO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYyAmJiBjLmV4cG9ydFRvUm91dGVyKSB7XG4gICAgICAgIGNvbmZpZyA9IGM7XG4gICAgICB9XG5cbiAgICAgIGNvbmZpZy5leHBvcnRUb1JvdXRlcihfdGhpczUpO1xuICAgICAgX3RoaXM1LmlzQ29uZmlndXJlZCA9IHRydWU7XG4gICAgICBfdGhpczUuX3Jlc29sdmVDb25maWd1cmVkUHJvbWlzZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUubmF2aWdhdGUgPSBmdW5jdGlvbiBuYXZpZ2F0ZShmcmFnbWVudCwgb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5pc0NvbmZpZ3VyZWQgJiYgdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5uYXZpZ2F0ZShmcmFnbWVudCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdGhpcy5pc0V4cGxpY2l0TmF2aWdhdGlvbiA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMuaGlzdG9yeS5uYXZpZ2F0ZShfcmVzb2x2ZVVybChmcmFnbWVudCwgdGhpcy5iYXNlVXJsLCB0aGlzLmhpc3RvcnkuX2hhc1B1c2hTdGF0ZSksIG9wdGlvbnMpO1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUubmF2aWdhdGVUb1JvdXRlID0gZnVuY3Rpb24gbmF2aWdhdGVUb1JvdXRlKHJvdXRlLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcGF0aCA9IHRoaXMuZ2VuZXJhdGUocm91dGUsIHBhcmFtcyk7XG4gICAgcmV0dXJuIHRoaXMubmF2aWdhdGUocGF0aCwgb3B0aW9ucyk7XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5uYXZpZ2F0ZUJhY2sgPSBmdW5jdGlvbiBuYXZpZ2F0ZUJhY2soKSB7XG4gICAgdGhpcy5pc0V4cGxpY2l0TmF2aWdhdGlvbkJhY2sgPSB0cnVlO1xuICAgIHRoaXMuaGlzdG9yeS5uYXZpZ2F0ZUJhY2soKTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmNyZWF0ZUNoaWxkID0gZnVuY3Rpb24gY3JlYXRlQ2hpbGQoY29udGFpbmVyKSB7XG4gICAgdmFyIGNoaWxkUm91dGVyID0gbmV3IFJvdXRlcihjb250YWluZXIgfHwgdGhpcy5jb250YWluZXIuY3JlYXRlQ2hpbGQoKSwgdGhpcy5oaXN0b3J5KTtcbiAgICBjaGlsZFJvdXRlci5wYXJlbnQgPSB0aGlzO1xuICAgIHJldHVybiBjaGlsZFJvdXRlcjtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUobmFtZSwgcGFyYW1zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgdmFyIGhhc1JvdXRlID0gdGhpcy5fcmVjb2duaXplci5oYXNSb3V0ZShuYW1lKTtcbiAgICBpZiAoKCF0aGlzLmlzQ29uZmlndXJlZCB8fCAhaGFzUm91dGUpICYmIHRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2VuZXJhdGUobmFtZSwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoIWhhc1JvdXRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Egcm91dGUgd2l0aCBuYW1lIFxcJycgKyBuYW1lICsgJ1xcJyBjb3VsZCBub3QgYmUgZm91bmQuIENoZWNrIHRoYXQgYG5hbWU6IFxcJycgKyBuYW1lICsgJ1xcJ2Agd2FzIHNwZWNpZmllZCBpbiB0aGUgcm91dGVcXCdzIGNvbmZpZy4nKTtcbiAgICB9XG5cbiAgICB2YXIgcGF0aCA9IHRoaXMuX3JlY29nbml6ZXIuZ2VuZXJhdGUobmFtZSwgcGFyYW1zKTtcbiAgICB2YXIgcm9vdGVkUGF0aCA9IF9jcmVhdGVSb290ZWRQYXRoKHBhdGgsIHRoaXMuYmFzZVVybCwgdGhpcy5oaXN0b3J5Ll9oYXNQdXNoU3RhdGUsIG9wdGlvbnMuYWJzb2x1dGUpO1xuICAgIHJldHVybiBvcHRpb25zLmFic29sdXRlID8gJycgKyB0aGlzLmhpc3RvcnkuZ2V0QWJzb2x1dGVSb290KCkgKyByb290ZWRQYXRoIDogcm9vdGVkUGF0aDtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmNyZWF0ZU5hdk1vZGVsID0gZnVuY3Rpb24gY3JlYXRlTmF2TW9kZWwoY29uZmlnKSB7XG4gICAgdmFyIG5hdk1vZGVsID0gbmV3IE5hdk1vZGVsKHRoaXMsICdocmVmJyBpbiBjb25maWcgPyBjb25maWcuaHJlZiA6IGNvbmZpZy5yb3V0ZSk7XG4gICAgbmF2TW9kZWwudGl0bGUgPSBjb25maWcudGl0bGU7XG4gICAgbmF2TW9kZWwub3JkZXIgPSBjb25maWcubmF2O1xuICAgIG5hdk1vZGVsLmhyZWYgPSBjb25maWcuaHJlZjtcbiAgICBuYXZNb2RlbC5zZXR0aW5ncyA9IGNvbmZpZy5zZXR0aW5ncztcbiAgICBuYXZNb2RlbC5jb25maWcgPSBjb25maWc7XG5cbiAgICByZXR1cm4gbmF2TW9kZWw7XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5hZGRSb3V0ZSA9IGZ1bmN0aW9uIGFkZFJvdXRlKGNvbmZpZywgbmF2TW9kZWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcucm91dGUpKSB7XG4gICAgICB2YXIgcm91dGVDb25maWdzID0gX2Vuc3VyZUFycmF5V2l0aFNpbmdsZVJvdXRlUGVyQ29uZmlnKGNvbmZpZyk7XG4gICAgICByb3V0ZUNvbmZpZ3MuZm9yRWFjaCh0aGlzLmFkZFJvdXRlLmJpbmQodGhpcykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhbGlkYXRlUm91dGVDb25maWcoY29uZmlnLCB0aGlzLnJvdXRlcyk7XG5cbiAgICBpZiAoISgndmlld1BvcnRzJyBpbiBjb25maWcpICYmICFjb25maWcubmF2aWdhdGlvblN0cmF0ZWd5KSB7XG4gICAgICBjb25maWcudmlld1BvcnRzID0ge1xuICAgICAgICAnZGVmYXVsdCc6IHtcbiAgICAgICAgICBtb2R1bGVJZDogY29uZmlnLm1vZHVsZUlkLFxuICAgICAgICAgIHZpZXc6IGNvbmZpZy52aWV3XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFuYXZNb2RlbCkge1xuICAgICAgbmF2TW9kZWwgPSB0aGlzLmNyZWF0ZU5hdk1vZGVsKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgdGhpcy5yb3V0ZXMucHVzaChjb25maWcpO1xuXG4gICAgdmFyIHBhdGggPSBjb25maWcucm91dGU7XG4gICAgaWYgKHBhdGguY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigxKTtcbiAgICB9XG4gICAgdmFyIGNhc2VTZW5zaXRpdmUgPSBjb25maWcuY2FzZVNlbnNpdGl2ZSA9PT0gdHJ1ZTtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWNvZ25pemVyLmFkZCh7IHBhdGg6IHBhdGgsIGhhbmRsZXI6IGNvbmZpZywgY2FzZVNlbnNpdGl2ZTogY2FzZVNlbnNpdGl2ZSB9KTtcblxuICAgIGlmIChwYXRoKSB7XG4gICAgICB2YXIgX3NldHRpbmdzID0gY29uZmlnLnNldHRpbmdzO1xuICAgICAgZGVsZXRlIGNvbmZpZy5zZXR0aW5ncztcbiAgICAgIHZhciB3aXRoQ2hpbGQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbmZpZykpO1xuICAgICAgY29uZmlnLnNldHRpbmdzID0gX3NldHRpbmdzO1xuICAgICAgd2l0aENoaWxkLnJvdXRlID0gcGF0aCArICcvKmNoaWxkUm91dGUnO1xuICAgICAgd2l0aENoaWxkLmhhc0NoaWxkUm91dGVyID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2NoaWxkUmVjb2duaXplci5hZGQoe1xuICAgICAgICBwYXRoOiB3aXRoQ2hpbGQucm91dGUsXG4gICAgICAgIGhhbmRsZXI6IHdpdGhDaGlsZCxcbiAgICAgICAgY2FzZVNlbnNpdGl2ZTogY2FzZVNlbnNpdGl2ZVxuICAgICAgfSk7XG5cbiAgICAgIHdpdGhDaGlsZC5uYXZNb2RlbCA9IG5hdk1vZGVsO1xuICAgICAgd2l0aENoaWxkLnNldHRpbmdzID0gY29uZmlnLnNldHRpbmdzO1xuICAgICAgd2l0aENoaWxkLm5hdmlnYXRpb25TdHJhdGVneSA9IGNvbmZpZy5uYXZpZ2F0aW9uU3RyYXRlZ3k7XG4gICAgfVxuXG4gICAgY29uZmlnLm5hdk1vZGVsID0gbmF2TW9kZWw7XG5cbiAgICBpZiAoKG5hdk1vZGVsLm9yZGVyIHx8IG5hdk1vZGVsLm9yZGVyID09PSAwKSAmJiB0aGlzLm5hdmlnYXRpb24uaW5kZXhPZihuYXZNb2RlbCkgPT09IC0xKSB7XG4gICAgICBpZiAoIW5hdk1vZGVsLmhyZWYgJiYgbmF2TW9kZWwuaHJlZiAhPT0gJycgJiYgKHN0YXRlLnR5cGVzLmR5bmFtaWNzIHx8IHN0YXRlLnR5cGVzLnN0YXJzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcm91dGUgY29uZmlnIGZvciBcIicgKyBjb25maWcucm91dGUgKyAnXCIgOiBkeW5hbWljIHJvdXRlcyBtdXN0IHNwZWNpZnkgYW4gXCJocmVmOlwiIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBuYXZpZ2F0aW9uIG1vZGVsLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG5hdk1vZGVsLm9yZGVyICE9PSAnbnVtYmVyJykge1xuICAgICAgICBuYXZNb2RlbC5vcmRlciA9ICsrdGhpcy5fZmFsbGJhY2tPcmRlcjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5uYXZpZ2F0aW9uLnB1c2gobmF2TW9kZWwpO1xuICAgICAgdGhpcy5uYXZpZ2F0aW9uID0gdGhpcy5uYXZpZ2F0aW9uLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEub3JkZXIgLSBiLm9yZGVyO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUuaGFzUm91dGUgPSBmdW5jdGlvbiBoYXNSb3V0ZShuYW1lKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuX3JlY29nbml6ZXIuaGFzUm91dGUobmFtZSkgfHwgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaGFzUm91dGUobmFtZSkpO1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUuaGFzT3duUm91dGUgPSBmdW5jdGlvbiBoYXNPd25Sb3V0ZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlY29nbml6ZXIuaGFzUm91dGUobmFtZSk7XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5oYW5kbGVVbmtub3duUm91dGVzID0gZnVuY3Rpb24gaGFuZGxlVW5rbm93blJvdXRlcyhjb25maWcpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIGlmICghY29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdW5rbm93biByb3V0ZSBoYW5kbGVyJyk7XG4gICAgfVxuXG4gICAgdGhpcy5jYXRjaEFsbEhhbmRsZXIgPSBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgIHJldHVybiBfdGhpczYuX2NyZWF0ZVJvdXRlQ29uZmlnKGNvbmZpZywgaW5zdHJ1Y3Rpb24pLnRoZW4oZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaW5zdHJ1Y3Rpb24uY29uZmlnID0gYztcbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLnVwZGF0ZVRpdGxlID0gZnVuY3Rpb24gdXBkYXRlVGl0bGUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQudXBkYXRlVGl0bGUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jdXJyZW50SW5zdHJ1Y3Rpb24pIHtcbiAgICAgIHRoaXMuY3VycmVudEluc3RydWN0aW9uLl91cGRhdGVUaXRsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUucmVmcmVzaE5hdmlnYXRpb24gPSBmdW5jdGlvbiByZWZyZXNoTmF2aWdhdGlvbigpIHtcbiAgICB2YXIgbmF2ID0gdGhpcy5uYXZpZ2F0aW9uO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG5hdi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9jdXJyZW50ID0gbmF2W2ldO1xuICAgICAgaWYgKCFfY3VycmVudC5jb25maWcuaHJlZikge1xuICAgICAgICBfY3VycmVudC5ocmVmID0gX2NyZWF0ZVJvb3RlZFBhdGgoX2N1cnJlbnQucmVsYXRpdmVIcmVmLCB0aGlzLmJhc2VVcmwsIHRoaXMuaGlzdG9yeS5faGFzUHVzaFN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9jdXJyZW50LmhyZWYgPSBfbm9ybWFsaXplQWJzb2x1dGVQYXRoKF9jdXJyZW50LmNvbmZpZy5ocmVmLCB0aGlzLmhpc3RvcnkuX2hhc1B1c2hTdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUudXNlVmlld1BvcnREZWZhdWx0cyA9IGZ1bmN0aW9uIHVzZVZpZXdQb3J0RGVmYXVsdHModmlld1BvcnREZWZhdWx0cykge1xuICAgIGZvciAodmFyIHZpZXdQb3J0TmFtZSBpbiB2aWV3UG9ydERlZmF1bHRzKSB7XG4gICAgICB2YXIgdmlld1BvcnRDb25maWcgPSB2aWV3UG9ydERlZmF1bHRzW3ZpZXdQb3J0TmFtZV07XG4gICAgICB0aGlzLnZpZXdQb3J0RGVmYXVsdHNbdmlld1BvcnROYW1lXSA9IHtcbiAgICAgICAgbW9kdWxlSWQ6IHZpZXdQb3J0Q29uZmlnLm1vZHVsZUlkXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLl9yZWZyZXNoQmFzZVVybCA9IGZ1bmN0aW9uIF9yZWZyZXNoQmFzZVVybCgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMuYmFzZVVybCA9IGdlbmVyYXRlQmFzZVVybCh0aGlzLnBhcmVudCwgdGhpcy5wYXJlbnQuY3VycmVudEluc3RydWN0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5fY3JlYXRlTmF2aWdhdGlvbkluc3RydWN0aW9uID0gZnVuY3Rpb24gX2NyZWF0ZU5hdmlnYXRpb25JbnN0cnVjdGlvbigpIHtcbiAgICB2YXIgdXJsID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgICB2YXIgcGFyZW50SW5zdHJ1Y3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG5cbiAgICB2YXIgZnJhZ21lbnQgPSB1cmw7XG4gICAgdmFyIHF1ZXJ5U3RyaW5nID0gJyc7XG5cbiAgICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/Jyk7XG4gICAgaWYgKHF1ZXJ5SW5kZXggIT09IC0xKSB7XG4gICAgICBmcmFnbWVudCA9IHVybC5zdWJzdHIoMCwgcXVlcnlJbmRleCk7XG4gICAgICBxdWVyeVN0cmluZyA9IHVybC5zdWJzdHIocXVlcnlJbmRleCArIDEpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHRzID0gdGhpcy5fcmVjb2duaXplci5yZWNvZ25pemUodXJsKTtcbiAgICBpZiAoIXJlc3VsdHMgfHwgIXJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICByZXN1bHRzID0gdGhpcy5fY2hpbGRSZWNvZ25pemVyLnJlY29nbml6ZSh1cmwpO1xuICAgIH1cblxuICAgIHZhciBpbnN0cnVjdGlvbkluaXQgPSB7XG4gICAgICBmcmFnbWVudDogZnJhZ21lbnQsXG4gICAgICBxdWVyeVN0cmluZzogcXVlcnlTdHJpbmcsXG4gICAgICBjb25maWc6IG51bGwsXG4gICAgICBwYXJlbnRJbnN0cnVjdGlvbjogcGFyZW50SW5zdHJ1Y3Rpb24sXG4gICAgICBwcmV2aW91c0luc3RydWN0aW9uOiB0aGlzLmN1cnJlbnRJbnN0cnVjdGlvbixcbiAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgY29tcGFyZVF1ZXJ5UGFyYW1zOiB0aGlzLm9wdGlvbnMuY29tcGFyZVF1ZXJ5UGFyYW1zXG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG5cbiAgICBpZiAocmVzdWx0cyAmJiByZXN1bHRzLmxlbmd0aCkge1xuICAgICAgdmFyIGZpcnN0ID0gcmVzdWx0c1swXTtcbiAgICAgIHZhciBfaW5zdHJ1Y3Rpb24gPSBuZXcgTmF2aWdhdGlvbkluc3RydWN0aW9uKE9iamVjdC5hc3NpZ24oe30sIGluc3RydWN0aW9uSW5pdCwge1xuICAgICAgICBwYXJhbXM6IGZpcnN0LnBhcmFtcyxcbiAgICAgICAgcXVlcnlQYXJhbXM6IGZpcnN0LnF1ZXJ5UGFyYW1zIHx8IHJlc3VsdHMucXVlcnlQYXJhbXMsXG4gICAgICAgIGNvbmZpZzogZmlyc3QuY29uZmlnIHx8IGZpcnN0LmhhbmRsZXJcbiAgICAgIH0pKTtcblxuICAgICAgaWYgKHR5cGVvZiBmaXJzdC5oYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlTmF2aWdhdGlvblN0cmF0ZWd5KF9pbnN0cnVjdGlvbiwgZmlyc3QuaGFuZGxlciwgZmlyc3QpO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdC5oYW5kbGVyICYmIHR5cGVvZiBmaXJzdC5oYW5kbGVyLm5hdmlnYXRpb25TdHJhdGVneSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXN1bHQgPSBldmFsdWF0ZU5hdmlnYXRpb25TdHJhdGVneShfaW5zdHJ1Y3Rpb24sIGZpcnN0LmhhbmRsZXIubmF2aWdhdGlvblN0cmF0ZWd5LCBmaXJzdC5oYW5kbGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IFByb21pc2UucmVzb2x2ZShfaW5zdHJ1Y3Rpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5jYXRjaEFsbEhhbmRsZXIpIHtcbiAgICAgIHZhciBfaW5zdHJ1Y3Rpb24yID0gbmV3IE5hdmlnYXRpb25JbnN0cnVjdGlvbihPYmplY3QuYXNzaWduKHt9LCBpbnN0cnVjdGlvbkluaXQsIHtcbiAgICAgICAgcGFyYW1zOiB7IHBhdGg6IGZyYWdtZW50IH0sXG4gICAgICAgIHF1ZXJ5UGFyYW1zOiByZXN1bHRzID8gcmVzdWx0cy5xdWVyeVBhcmFtcyA6IHt9LFxuICAgICAgICBjb25maWc6IG51bGwgfSkpO1xuXG4gICAgICByZXN1bHQgPSBldmFsdWF0ZU5hdmlnYXRpb25TdHJhdGVneShfaW5zdHJ1Y3Rpb24yLCB0aGlzLmNhdGNoQWxsSGFuZGxlcik7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdmFyIF9yb3V0ZXIyID0gdGhpcy5fcGFyZW50Q2F0Y2hBbGxIYW5kbGVyKHRoaXMucGFyZW50KTtcblxuICAgICAgaWYgKF9yb3V0ZXIyKSB7XG4gICAgICAgIHZhciBuZXdQYXJlbnRJbnN0cnVjdGlvbiA9IHRoaXMuX2ZpbmRQYXJlbnRJbnN0cnVjdGlvbkZyb21Sb3V0ZXIoX3JvdXRlcjIsIHBhcmVudEluc3RydWN0aW9uKTtcblxuICAgICAgICB2YXIgX2luc3RydWN0aW9uMyA9IG5ldyBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24oT2JqZWN0LmFzc2lnbih7fSwgaW5zdHJ1Y3Rpb25Jbml0LCB7XG4gICAgICAgICAgcGFyYW1zOiB7IHBhdGg6IGZyYWdtZW50IH0sXG4gICAgICAgICAgcXVlcnlQYXJhbXM6IHJlc3VsdHMgPyByZXN1bHRzLnF1ZXJ5UGFyYW1zIDoge30sXG4gICAgICAgICAgcm91dGVyOiBfcm91dGVyMixcbiAgICAgICAgICBwYXJlbnRJbnN0cnVjdGlvbjogbmV3UGFyZW50SW5zdHJ1Y3Rpb24sXG4gICAgICAgICAgcGFyZW50Q2F0Y2hIYW5kbGVyOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZzogbnVsbCB9KSk7XG5cbiAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVOYXZpZ2F0aW9uU3RyYXRlZ3koX2luc3RydWN0aW9uMywgX3JvdXRlcjIuY2F0Y2hBbGxIYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzdWx0ICYmIHBhcmVudEluc3RydWN0aW9uKSB7XG4gICAgICB0aGlzLmJhc2VVcmwgPSBnZW5lcmF0ZUJhc2VVcmwodGhpcy5wYXJlbnQsIHBhcmVudEluc3RydWN0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0IHx8IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignUm91dGUgbm90IGZvdW5kOiAnICsgdXJsKSk7XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5fZmluZFBhcmVudEluc3RydWN0aW9uRnJvbVJvdXRlciA9IGZ1bmN0aW9uIF9maW5kUGFyZW50SW5zdHJ1Y3Rpb25Gcm9tUm91dGVyKHJvdXRlciwgaW5zdHJ1Y3Rpb24pIHtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ucm91dGVyID09PSByb3V0ZXIpIHtcbiAgICAgIGluc3RydWN0aW9uLmZyYWdtZW50ID0gcm91dGVyLmJhc2VVcmw7XG4gICAgICByZXR1cm4gaW5zdHJ1Y3Rpb247XG4gICAgfSBlbHNlIGlmIChpbnN0cnVjdGlvbi5wYXJlbnRJbnN0cnVjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRQYXJlbnRJbnN0cnVjdGlvbkZyb21Sb3V0ZXIocm91dGVyLCBpbnN0cnVjdGlvbi5wYXJlbnRJbnN0cnVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5fcGFyZW50Q2F0Y2hBbGxIYW5kbGVyID0gZnVuY3Rpb24gX3BhcmVudENhdGNoQWxsSGFuZGxlcihyb3V0ZXIpIHtcbiAgICBpZiAocm91dGVyLmNhdGNoQWxsSGFuZGxlcikge1xuICAgICAgcmV0dXJuIHJvdXRlcjtcbiAgICB9IGVsc2UgaWYgKHJvdXRlci5wYXJlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJlbnRDYXRjaEFsbEhhbmRsZXIocm91dGVyLnBhcmVudCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLl9jcmVhdGVSb3V0ZUNvbmZpZyA9IGZ1bmN0aW9uIF9jcmVhdGVSb3V0ZUNvbmZpZyhjb25maWcsIGluc3RydWN0aW9uKSB7XG4gICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZykudGhlbihmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKHR5cGVvZiBjID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4geyBtb2R1bGVJZDogYyB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gYyhpbnN0cnVjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgPyB7IG1vZHVsZUlkOiBjIH0gOiBjO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGMpIHtcbiAgICAgIGMucm91dGUgPSBpbnN0cnVjdGlvbi5wYXJhbXMucGF0aDtcbiAgICAgIHZhbGlkYXRlUm91dGVDb25maWcoYywgX3RoaXM3LnJvdXRlcyk7XG5cbiAgICAgIGlmICghYy5uYXZNb2RlbCkge1xuICAgICAgICBjLm5hdk1vZGVsID0gX3RoaXM3LmNyZWF0ZU5hdk1vZGVsKGMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYztcbiAgICB9KTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoUm91dGVyLCBbe1xuICAgIGtleTogJ2lzUm9vdCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gIXRoaXMucGFyZW50O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSb3V0ZXI7XG59KCk7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQmFzZVVybChyb3V0ZXIsIGluc3RydWN0aW9uKSB7XG4gIHJldHVybiAnJyArIChyb3V0ZXIuYmFzZVVybCB8fCAnJykgKyAoaW5zdHJ1Y3Rpb24uZ2V0QmFzZVVybCgpIHx8ICcnKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVSb3V0ZUNvbmZpZyhjb25maWcsIHJvdXRlcykge1xuICBpZiAoKHR5cGVvZiBjb25maWcgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmZpZykpICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBSb3V0ZSBDb25maWcnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29uZmlnLnJvdXRlICE9PSAnc3RyaW5nJykge1xuICAgIHZhciBfbmFtZTIgPSBjb25maWcubmFtZSB8fCAnKG5vIG5hbWUpJztcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUm91dGUgQ29uZmlnIGZvciBcIicgKyBfbmFtZTIgKyAnXCI6IFlvdSBtdXN0IHNwZWNpZnkgYSBcInJvdXRlOlwiIHBhdHRlcm4uJyk7XG4gIH1cblxuICBpZiAoISgncmVkaXJlY3QnIGluIGNvbmZpZyB8fCBjb25maWcubW9kdWxlSWQgfHwgY29uZmlnLm5hdmlnYXRpb25TdHJhdGVneSB8fCBjb25maWcudmlld1BvcnRzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBSb3V0ZSBDb25maWcgZm9yIFwiJyArIGNvbmZpZy5yb3V0ZSArICdcIjogWW91IG11c3Qgc3BlY2lmeSBhIFwibW9kdWxlSWQ6XCIsIFwicmVkaXJlY3Q6XCIsIFwibmF2aWdhdGlvblN0cmF0ZWd5OlwiLCBvciBcInZpZXdQb3J0czpcIi4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmFsdWF0ZU5hdmlnYXRpb25TdHJhdGVneShpbnN0cnVjdGlvbiwgZXZhbHVhdG9yLCBjb250ZXh0KSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoZXZhbHVhdG9yLmNhbGwoY29udGV4dCwgaW5zdHJ1Y3Rpb24pKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoISgndmlld1BvcnRzJyBpbiBpbnN0cnVjdGlvbi5jb25maWcpKSB7XG4gICAgICBpbnN0cnVjdGlvbi5jb25maWcudmlld1BvcnRzID0ge1xuICAgICAgICAnZGVmYXVsdCc6IHtcbiAgICAgICAgICBtb2R1bGVJZDogaW5zdHJ1Y3Rpb24uY29uZmlnLm1vZHVsZUlkXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RydWN0aW9uO1xuICB9KTtcbn1cblxuZXhwb3J0IHZhciBDYW5EZWFjdGl2YXRlUHJldmlvdXNTdGVwID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDYW5EZWFjdGl2YXRlUHJldmlvdXNTdGVwKCkge1xuICAgIFxuICB9XG5cbiAgQ2FuRGVhY3RpdmF0ZVByZXZpb3VzU3RlcC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuKG5hdmlnYXRpb25JbnN0cnVjdGlvbiwgbmV4dCkge1xuICAgIHJldHVybiBwcm9jZXNzRGVhY3RpdmF0YWJsZShuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sICdjYW5EZWFjdGl2YXRlJywgbmV4dCk7XG4gIH07XG5cbiAgcmV0dXJuIENhbkRlYWN0aXZhdGVQcmV2aW91c1N0ZXA7XG59KCk7XG5cbmV4cG9ydCB2YXIgQ2FuQWN0aXZhdGVOZXh0U3RlcCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2FuQWN0aXZhdGVOZXh0U3RlcCgpIHtcbiAgICBcbiAgfVxuXG4gIENhbkFjdGl2YXRlTmV4dFN0ZXAucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1bihuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sIG5leHQpIHtcbiAgICByZXR1cm4gcHJvY2Vzc0FjdGl2YXRhYmxlKG5hdmlnYXRpb25JbnN0cnVjdGlvbiwgJ2NhbkFjdGl2YXRlJywgbmV4dCk7XG4gIH07XG5cbiAgcmV0dXJuIENhbkFjdGl2YXRlTmV4dFN0ZXA7XG59KCk7XG5cbmV4cG9ydCB2YXIgRGVhY3RpdmF0ZVByZXZpb3VzU3RlcCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGVhY3RpdmF0ZVByZXZpb3VzU3RlcCgpIHtcbiAgICBcbiAgfVxuXG4gIERlYWN0aXZhdGVQcmV2aW91c1N0ZXAucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1bihuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sIG5leHQpIHtcbiAgICByZXR1cm4gcHJvY2Vzc0RlYWN0aXZhdGFibGUobmF2aWdhdGlvbkluc3RydWN0aW9uLCAnZGVhY3RpdmF0ZScsIG5leHQsIHRydWUpO1xuICB9O1xuXG4gIHJldHVybiBEZWFjdGl2YXRlUHJldmlvdXNTdGVwO1xufSgpO1xuXG5leHBvcnQgdmFyIEFjdGl2YXRlTmV4dFN0ZXAgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFjdGl2YXRlTmV4dFN0ZXAoKSB7XG4gICAgXG4gIH1cblxuICBBY3RpdmF0ZU5leHRTdGVwLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4obmF2aWdhdGlvbkluc3RydWN0aW9uLCBuZXh0KSB7XG4gICAgcmV0dXJuIHByb2Nlc3NBY3RpdmF0YWJsZShuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sICdhY3RpdmF0ZScsIG5leHQsIHRydWUpO1xuICB9O1xuXG4gIHJldHVybiBBY3RpdmF0ZU5leHRTdGVwO1xufSgpO1xuXG5mdW5jdGlvbiBwcm9jZXNzRGVhY3RpdmF0YWJsZShuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sIGNhbGxiYWNrTmFtZSwgbmV4dCwgaWdub3JlUmVzdWx0KSB7XG4gIHZhciBwbGFuID0gbmF2aWdhdGlvbkluc3RydWN0aW9uLnBsYW47XG4gIHZhciBpbmZvcyA9IGZpbmREZWFjdGl2YXRhYmxlKHBsYW4sIGNhbGxiYWNrTmFtZSk7XG4gIHZhciBpID0gaW5mb3MubGVuZ3RoO1xuXG4gIGZ1bmN0aW9uIGluc3BlY3QodmFsKSB7XG4gICAgaWYgKGlnbm9yZVJlc3VsdCB8fCBzaG91bGRDb250aW51ZSh2YWwpKSB7XG4gICAgICByZXR1cm4gaXRlcmF0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0LmNhbmNlbCh2YWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXRlcmF0ZSgpIHtcbiAgICBpZiAoaS0tKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdmlld01vZGVsID0gaW5mb3NbaV07XG4gICAgICAgIHZhciBfcmVzdWx0ID0gdmlld01vZGVsW2NhbGxiYWNrTmFtZV0obmF2aWdhdGlvbkluc3RydWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NQb3RlbnRpYWwoX3Jlc3VsdCwgaW5zcGVjdCwgbmV4dC5jYW5jZWwpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG5leHQuY2FuY2VsKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24ucm91dGVyLmNvdWxkRGVhY3RpdmF0ZSA9IHRydWU7XG5cbiAgICByZXR1cm4gbmV4dCgpO1xuICB9XG5cbiAgcmV0dXJuIGl0ZXJhdGUoKTtcbn1cblxuZnVuY3Rpb24gZmluZERlYWN0aXZhdGFibGUocGxhbiwgY2FsbGJhY2tOYW1lKSB7XG4gIHZhciBsaXN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbXTtcblxuICBmb3IgKHZhciB2aWV3UG9ydE5hbWUgaW4gcGxhbikge1xuICAgIHZhciBfdmlld1BvcnRQbGFuID0gcGxhblt2aWV3UG9ydE5hbWVdO1xuICAgIHZhciBwcmV2Q29tcG9uZW50ID0gX3ZpZXdQb3J0UGxhbi5wcmV2Q29tcG9uZW50O1xuXG4gICAgaWYgKChfdmlld1BvcnRQbGFuLnN0cmF0ZWd5ID09PSBhY3RpdmF0aW9uU3RyYXRlZ3kuaW52b2tlTGlmZWN5Y2xlIHx8IF92aWV3UG9ydFBsYW4uc3RyYXRlZ3kgPT09IGFjdGl2YXRpb25TdHJhdGVneS5yZXBsYWNlKSAmJiBwcmV2Q29tcG9uZW50KSB7XG4gICAgICB2YXIgdmlld01vZGVsID0gcHJldkNvbXBvbmVudC52aWV3TW9kZWw7XG5cbiAgICAgIGlmIChjYWxsYmFja05hbWUgaW4gdmlld01vZGVsKSB7XG4gICAgICAgIGxpc3QucHVzaCh2aWV3TW9kZWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChfdmlld1BvcnRQbGFuLnN0cmF0ZWd5ID09PSBhY3RpdmF0aW9uU3RyYXRlZ3kucmVwbGFjZSAmJiBwcmV2Q29tcG9uZW50KSB7XG4gICAgICBhZGRQcmV2aW91c0RlYWN0aXZhdGFibGUocHJldkNvbXBvbmVudCwgY2FsbGJhY2tOYW1lLCBsaXN0KTtcbiAgICB9IGVsc2UgaWYgKF92aWV3UG9ydFBsYW4uY2hpbGROYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24pIHtcbiAgICAgIGZpbmREZWFjdGl2YXRhYmxlKF92aWV3UG9ydFBsYW4uY2hpbGROYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24ucGxhbiwgY2FsbGJhY2tOYW1lLCBsaXN0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGlzdDtcbn1cblxuZnVuY3Rpb24gYWRkUHJldmlvdXNEZWFjdGl2YXRhYmxlKGNvbXBvbmVudCwgY2FsbGJhY2tOYW1lLCBsaXN0KSB7XG4gIHZhciBjaGlsZFJvdXRlciA9IGNvbXBvbmVudC5jaGlsZFJvdXRlcjtcblxuICBpZiAoY2hpbGRSb3V0ZXIgJiYgY2hpbGRSb3V0ZXIuY3VycmVudEluc3RydWN0aW9uKSB7XG4gICAgdmFyIHZpZXdQb3J0SW5zdHJ1Y3Rpb25zID0gY2hpbGRSb3V0ZXIuY3VycmVudEluc3RydWN0aW9uLnZpZXdQb3J0SW5zdHJ1Y3Rpb25zO1xuXG4gICAgZm9yICh2YXIgdmlld1BvcnROYW1lIGluIHZpZXdQb3J0SW5zdHJ1Y3Rpb25zKSB7XG4gICAgICB2YXIgX3ZpZXdQb3J0SW5zdHJ1Y3Rpb24yID0gdmlld1BvcnRJbnN0cnVjdGlvbnNbdmlld1BvcnROYW1lXTtcbiAgICAgIHZhciBwcmV2Q29tcG9uZW50ID0gX3ZpZXdQb3J0SW5zdHJ1Y3Rpb24yLmNvbXBvbmVudDtcbiAgICAgIHZhciBwcmV2Vmlld01vZGVsID0gcHJldkNvbXBvbmVudC52aWV3TW9kZWw7XG5cbiAgICAgIGlmIChjYWxsYmFja05hbWUgaW4gcHJldlZpZXdNb2RlbCkge1xuICAgICAgICBsaXN0LnB1c2gocHJldlZpZXdNb2RlbCk7XG4gICAgICB9XG5cbiAgICAgIGFkZFByZXZpb3VzRGVhY3RpdmF0YWJsZShwcmV2Q29tcG9uZW50LCBjYWxsYmFja05hbWUsIGxpc3QpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQWN0aXZhdGFibGUobmF2aWdhdGlvbkluc3RydWN0aW9uLCBjYWxsYmFja05hbWUsIG5leHQsIGlnbm9yZVJlc3VsdCkge1xuICB2YXIgaW5mb3MgPSBmaW5kQWN0aXZhdGFibGUobmF2aWdhdGlvbkluc3RydWN0aW9uLCBjYWxsYmFja05hbWUpO1xuICB2YXIgbGVuZ3RoID0gaW5mb3MubGVuZ3RoO1xuICB2YXIgaSA9IC0xO1xuXG4gIGZ1bmN0aW9uIGluc3BlY3QodmFsLCByb3V0ZXIpIHtcbiAgICBpZiAoaWdub3JlUmVzdWx0IHx8IHNob3VsZENvbnRpbnVlKHZhbCwgcm91dGVyKSkge1xuICAgICAgcmV0dXJuIGl0ZXJhdGUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dC5jYW5jZWwodmFsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGl0ZXJhdGUoKSB7XG4gICAgaSsrO1xuXG4gICAgaWYgKGkgPCBsZW5ndGgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBfY3VycmVudDIkdmlld01vZGVsO1xuXG4gICAgICAgIHZhciBfY3VycmVudDIgPSBpbmZvc1tpXTtcbiAgICAgICAgdmFyIF9yZXN1bHQyID0gKF9jdXJyZW50MiR2aWV3TW9kZWwgPSBfY3VycmVudDIudmlld01vZGVsKVtjYWxsYmFja05hbWVdLmFwcGx5KF9jdXJyZW50MiR2aWV3TW9kZWwsIF9jdXJyZW50Mi5saWZlY3ljbGVBcmdzKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NQb3RlbnRpYWwoX3Jlc3VsdDIsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gaW5zcGVjdCh2YWwsIF9jdXJyZW50Mi5yb3V0ZXIpO1xuICAgICAgICB9LCBuZXh0LmNhbmNlbCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gbmV4dC5jYW5jZWwoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXh0KCk7XG4gIH1cblxuICByZXR1cm4gaXRlcmF0ZSgpO1xufVxuXG5mdW5jdGlvbiBmaW5kQWN0aXZhdGFibGUobmF2aWdhdGlvbkluc3RydWN0aW9uLCBjYWxsYmFja05hbWUpIHtcbiAgdmFyIGxpc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFtdO1xuICB2YXIgcm91dGVyID0gYXJndW1lbnRzWzNdO1xuXG4gIHZhciBwbGFuID0gbmF2aWdhdGlvbkluc3RydWN0aW9uLnBsYW47XG5cbiAgT2JqZWN0LmtleXMocGxhbikuZmlsdGVyKGZ1bmN0aW9uICh2aWV3UG9ydE5hbWUpIHtcbiAgICB2YXIgdmlld1BvcnRQbGFuID0gcGxhblt2aWV3UG9ydE5hbWVdO1xuICAgIHZhciB2aWV3UG9ydEluc3RydWN0aW9uID0gbmF2aWdhdGlvbkluc3RydWN0aW9uLnZpZXdQb3J0SW5zdHJ1Y3Rpb25zW3ZpZXdQb3J0TmFtZV07XG4gICAgdmFyIHZpZXdNb2RlbCA9IHZpZXdQb3J0SW5zdHJ1Y3Rpb24uY29tcG9uZW50LnZpZXdNb2RlbDtcblxuICAgIGlmICgodmlld1BvcnRQbGFuLnN0cmF0ZWd5ID09PSBhY3RpdmF0aW9uU3RyYXRlZ3kuaW52b2tlTGlmZWN5Y2xlIHx8IHZpZXdQb3J0UGxhbi5zdHJhdGVneSA9PT0gYWN0aXZhdGlvblN0cmF0ZWd5LnJlcGxhY2UpICYmIGNhbGxiYWNrTmFtZSBpbiB2aWV3TW9kZWwpIHtcbiAgICAgIGxpc3QucHVzaCh7XG4gICAgICAgIHZpZXdNb2RlbDogdmlld01vZGVsLFxuICAgICAgICBsaWZlY3ljbGVBcmdzOiB2aWV3UG9ydEluc3RydWN0aW9uLmxpZmVjeWNsZUFyZ3MsXG4gICAgICAgIHJvdXRlcjogcm91dGVyXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodmlld1BvcnRQbGFuLmNoaWxkTmF2aWdhdGlvbkluc3RydWN0aW9uKSB7XG4gICAgICBmaW5kQWN0aXZhdGFibGUodmlld1BvcnRQbGFuLmNoaWxkTmF2aWdhdGlvbkluc3RydWN0aW9uLCBjYWxsYmFja05hbWUsIGxpc3QsIHZpZXdQb3J0SW5zdHJ1Y3Rpb24uY29tcG9uZW50LmNoaWxkUm91dGVyIHx8IHJvdXRlcik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbGlzdDtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29udGludWUob3V0cHV0LCByb3V0ZXIpIHtcbiAgaWYgKG91dHB1dCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzTmF2aWdhdGlvbkNvbW1hbmQob3V0cHV0KSkge1xuICAgIGlmICh0eXBlb2Ygb3V0cHV0LnNldFJvdXRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3V0cHV0LnNldFJvdXRlcihyb3V0ZXIpO1xuICAgIH1cblxuICAgIHJldHVybiAhIW91dHB1dC5zaG91bGRDb250aW51ZVByb2Nlc3Npbmc7XG4gIH1cblxuICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbnZhciBTYWZlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTYWZlU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbkZ1bmMpIHtcbiAgICBcblxuICAgIHRoaXMuX3N1YnNjcmliZWQgPSB0cnVlO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbkZ1bmModGhpcyk7XG5cbiAgICBpZiAoIXRoaXMuX3N1YnNjcmliZWQpIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIFNhZmVTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgaWYgKHRoaXMuX3N1YnNjcmliZWQgJiYgdGhpcy5fc3Vic2NyaXB0aW9uKSB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcblxuICAgIHRoaXMuX3N1YnNjcmliZWQgPSBmYWxzZTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoU2FmZVN1YnNjcmlwdGlvbiwgW3tcbiAgICBrZXk6ICdzdWJzY3JpYmVkJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmVkO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTYWZlU3Vic2NyaXB0aW9uO1xufSgpO1xuXG5mdW5jdGlvbiBwcm9jZXNzUG90ZW50aWFsKG9iaiwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gIGlmIChvYmogJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShvYmopLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgfVxuXG4gIGlmIChvYmogJiYgdHlwZW9mIG9iai5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgb2JzID0gb2JqO1xuICAgIHJldHVybiBuZXcgU2FmZVN1YnNjcmlwdGlvbihmdW5jdGlvbiAoc3ViKSB7XG4gICAgICByZXR1cm4gb2JzLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgaWYgKHN1Yi5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHJlc29sdmUob2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiBlcnJvcihfZXJyb3IpIHtcbiAgICAgICAgICBpZiAoc3ViLnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgcmVqZWN0KF9lcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICAgICAgaWYgKHN1Yi5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHJlc29sdmUob2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gcmVzb2x2ZShvYmopO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICB9XG59XG5cbmV4cG9ydCB2YXIgUm91dGVMb2FkZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJvdXRlTG9hZGVyKCkge1xuICAgIFxuICB9XG5cbiAgUm91dGVMb2FkZXIucHJvdG90eXBlLmxvYWRSb3V0ZSA9IGZ1bmN0aW9uIGxvYWRSb3V0ZShyb3V0ZXIsIGNvbmZpZywgbmF2aWdhdGlvbkluc3RydWN0aW9uKSB7XG4gICAgdGhyb3cgRXJyb3IoJ1JvdXRlIGxvYWRlcnMgbXVzdCBpbXBsZW1lbnQgXCJsb2FkUm91dGUocm91dGVyLCBjb25maWcsIG5hdmlnYXRpb25JbnN0cnVjdGlvbilcIi4nKTtcbiAgfTtcblxuICByZXR1cm4gUm91dGVMb2FkZXI7XG59KCk7XG5cbmV4cG9ydCB2YXIgTG9hZFJvdXRlU3RlcCA9IGZ1bmN0aW9uICgpIHtcbiAgTG9hZFJvdXRlU3RlcC5pbmplY3QgPSBmdW5jdGlvbiBpbmplY3QoKSB7XG4gICAgcmV0dXJuIFtSb3V0ZUxvYWRlcl07XG4gIH07XG5cbiAgZnVuY3Rpb24gTG9hZFJvdXRlU3RlcChyb3V0ZUxvYWRlcikge1xuICAgIFxuXG4gICAgdGhpcy5yb3V0ZUxvYWRlciA9IHJvdXRlTG9hZGVyO1xuICB9XG5cbiAgTG9hZFJvdXRlU3RlcC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuKG5hdmlnYXRpb25JbnN0cnVjdGlvbiwgbmV4dCkge1xuICAgIHJldHVybiBsb2FkTmV3Um91dGUodGhpcy5yb3V0ZUxvYWRlciwgbmF2aWdhdGlvbkluc3RydWN0aW9uKS50aGVuKG5leHQpLmNhdGNoKG5leHQuY2FuY2VsKTtcbiAgfTtcblxuICByZXR1cm4gTG9hZFJvdXRlU3RlcDtcbn0oKTtcblxuZnVuY3Rpb24gbG9hZE5ld1JvdXRlKHJvdXRlTG9hZGVyLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24pIHtcbiAgdmFyIHRvTG9hZCA9IGRldGVybWluZVdoYXRUb0xvYWQobmF2aWdhdGlvbkluc3RydWN0aW9uKTtcbiAgdmFyIGxvYWRQcm9taXNlcyA9IHRvTG9hZC5tYXAoZnVuY3Rpb24gKGN1cnJlbnQpIHtcbiAgICByZXR1cm4gbG9hZFJvdXRlKHJvdXRlTG9hZGVyLCBjdXJyZW50Lm5hdmlnYXRpb25JbnN0cnVjdGlvbiwgY3VycmVudC52aWV3UG9ydFBsYW4pO1xuICB9KTtcblxuICByZXR1cm4gUHJvbWlzZS5hbGwobG9hZFByb21pc2VzKTtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lV2hhdFRvTG9hZChuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24pIHtcbiAgdmFyIHRvTG9hZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG5cbiAgdmFyIHBsYW4gPSBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24ucGxhbjtcblxuICBmb3IgKHZhciB2aWV3UG9ydE5hbWUgaW4gcGxhbikge1xuICAgIHZhciBfdmlld1BvcnRQbGFuMiA9IHBsYW5bdmlld1BvcnROYW1lXTtcblxuICAgIGlmIChfdmlld1BvcnRQbGFuMi5zdHJhdGVneSA9PT0gYWN0aXZhdGlvblN0cmF0ZWd5LnJlcGxhY2UpIHtcbiAgICAgIHRvTG9hZC5wdXNoKHsgdmlld1BvcnRQbGFuOiBfdmlld1BvcnRQbGFuMiwgbmF2aWdhdGlvbkluc3RydWN0aW9uOiBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24gfSk7XG5cbiAgICAgIGlmIChfdmlld1BvcnRQbGFuMi5jaGlsZE5hdmlnYXRpb25JbnN0cnVjdGlvbikge1xuICAgICAgICBkZXRlcm1pbmVXaGF0VG9Mb2FkKF92aWV3UG9ydFBsYW4yLmNoaWxkTmF2aWdhdGlvbkluc3RydWN0aW9uLCB0b0xvYWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3ZpZXdQb3J0SW5zdHJ1Y3Rpb24zID0gbmF2aWdhdGlvbkluc3RydWN0aW9uLmFkZFZpZXdQb3J0SW5zdHJ1Y3Rpb24odmlld1BvcnROYW1lLCBfdmlld1BvcnRQbGFuMi5zdHJhdGVneSwgX3ZpZXdQb3J0UGxhbjIucHJldk1vZHVsZUlkLCBfdmlld1BvcnRQbGFuMi5wcmV2Q29tcG9uZW50KTtcblxuICAgICAgaWYgKF92aWV3UG9ydFBsYW4yLmNoaWxkTmF2aWdhdGlvbkluc3RydWN0aW9uKSB7XG4gICAgICAgIF92aWV3UG9ydEluc3RydWN0aW9uMy5jaGlsZE5hdmlnYXRpb25JbnN0cnVjdGlvbiA9IF92aWV3UG9ydFBsYW4yLmNoaWxkTmF2aWdhdGlvbkluc3RydWN0aW9uO1xuICAgICAgICBkZXRlcm1pbmVXaGF0VG9Mb2FkKF92aWV3UG9ydFBsYW4yLmNoaWxkTmF2aWdhdGlvbkluc3RydWN0aW9uLCB0b0xvYWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0b0xvYWQ7XG59XG5cbmZ1bmN0aW9uIGxvYWRSb3V0ZShyb3V0ZUxvYWRlciwgbmF2aWdhdGlvbkluc3RydWN0aW9uLCB2aWV3UG9ydFBsYW4pIHtcbiAgdmFyIG1vZHVsZUlkID0gdmlld1BvcnRQbGFuLmNvbmZpZyA/IHZpZXdQb3J0UGxhbi5jb25maWcubW9kdWxlSWQgOiBudWxsO1xuXG4gIHJldHVybiBsb2FkQ29tcG9uZW50KHJvdXRlTG9hZGVyLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sIHZpZXdQb3J0UGxhbi5jb25maWcpLnRoZW4oZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgIHZhciB2aWV3UG9ydEluc3RydWN0aW9uID0gbmF2aWdhdGlvbkluc3RydWN0aW9uLmFkZFZpZXdQb3J0SW5zdHJ1Y3Rpb24odmlld1BvcnRQbGFuLm5hbWUsIHZpZXdQb3J0UGxhbi5zdHJhdGVneSwgbW9kdWxlSWQsIGNvbXBvbmVudCk7XG5cbiAgICB2YXIgY2hpbGRSb3V0ZXIgPSBjb21wb25lbnQuY2hpbGRSb3V0ZXI7XG4gICAgaWYgKGNoaWxkUm91dGVyKSB7XG4gICAgICB2YXIgcGF0aCA9IG5hdmlnYXRpb25JbnN0cnVjdGlvbi5nZXRXaWxkY2FyZFBhdGgoKTtcblxuICAgICAgcmV0dXJuIGNoaWxkUm91dGVyLl9jcmVhdGVOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24ocGF0aCwgbmF2aWdhdGlvbkluc3RydWN0aW9uKS50aGVuKGZ1bmN0aW9uIChjaGlsZEluc3RydWN0aW9uKSB7XG4gICAgICAgIHZpZXdQb3J0UGxhbi5jaGlsZE5hdmlnYXRpb25JbnN0cnVjdGlvbiA9IGNoaWxkSW5zdHJ1Y3Rpb247XG5cbiAgICAgICAgcmV0dXJuIF9idWlsZE5hdmlnYXRpb25QbGFuKGNoaWxkSW5zdHJ1Y3Rpb24pLnRoZW4oZnVuY3Rpb24gKGNoaWxkUGxhbikge1xuICAgICAgICAgIGlmIChjaGlsZFBsYW4gaW5zdGFuY2VvZiBSZWRpcmVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNoaWxkUGxhbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoaWxkSW5zdHJ1Y3Rpb24ucGxhbiA9IGNoaWxkUGxhbjtcbiAgICAgICAgICB2aWV3UG9ydEluc3RydWN0aW9uLmNoaWxkTmF2aWdhdGlvbkluc3RydWN0aW9uID0gY2hpbGRJbnN0cnVjdGlvbjtcblxuICAgICAgICAgIHJldHVybiBsb2FkTmV3Um91dGUocm91dGVMb2FkZXIsIGNoaWxkSW5zdHJ1Y3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBsb2FkQ29tcG9uZW50KHJvdXRlTG9hZGVyLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sIGNvbmZpZykge1xuICB2YXIgcm91dGVyID0gbmF2aWdhdGlvbkluc3RydWN0aW9uLnJvdXRlcjtcbiAgdmFyIGxpZmVjeWNsZUFyZ3MgPSBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24ubGlmZWN5Y2xlQXJncztcblxuICByZXR1cm4gcm91dGVMb2FkZXIubG9hZFJvdXRlKHJvdXRlciwgY29uZmlnLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24pLnRoZW4oZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgIHZhciB2aWV3TW9kZWwgPSBjb21wb25lbnQudmlld01vZGVsLFxuICAgICAgICBjaGlsZENvbnRhaW5lciA9IGNvbXBvbmVudC5jaGlsZENvbnRhaW5lcjtcblxuICAgIGNvbXBvbmVudC5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgY29tcG9uZW50LmNvbmZpZyA9IGNvbmZpZztcblxuICAgIGlmICgnY29uZmlndXJlUm91dGVyJyBpbiB2aWV3TW9kZWwpIHtcbiAgICAgIHZhciBjaGlsZFJvdXRlciA9IGNoaWxkQ29udGFpbmVyLmdldENoaWxkUm91dGVyKCk7XG4gICAgICBjb21wb25lbnQuY2hpbGRSb3V0ZXIgPSBjaGlsZFJvdXRlcjtcblxuICAgICAgcmV0dXJuIGNoaWxkUm91dGVyLmNvbmZpZ3VyZShmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gdmlld01vZGVsLmNvbmZpZ3VyZVJvdXRlci5hcHBseSh2aWV3TW9kZWwsIFtjLCBjaGlsZFJvdXRlcl0uY29uY2F0KGxpZmVjeWNsZUFyZ3MpKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfSk7XG59XG5cbnZhciBQaXBlbGluZVNsb3QgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBpcGVsaW5lU2xvdChjb250YWluZXIsIG5hbWUsIGFsaWFzKSB7XG4gICAgXG5cbiAgICB0aGlzLnN0ZXBzID0gW107XG5cbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLnNsb3ROYW1lID0gbmFtZTtcbiAgICB0aGlzLnNsb3RBbGlhcyA9IGFsaWFzO1xuICB9XG5cbiAgUGlwZWxpbmVTbG90LnByb3RvdHlwZS5nZXRTdGVwcyA9IGZ1bmN0aW9uIGdldFN0ZXBzKCkge1xuICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RlcHMubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gX3RoaXM4LmNvbnRhaW5lci5nZXQoeCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFBpcGVsaW5lU2xvdDtcbn0oKTtcblxuZXhwb3J0IHZhciBQaXBlbGluZVByb3ZpZGVyID0gZnVuY3Rpb24gKCkge1xuICBQaXBlbGluZVByb3ZpZGVyLmluamVjdCA9IGZ1bmN0aW9uIGluamVjdCgpIHtcbiAgICByZXR1cm4gW0NvbnRhaW5lcl07XG4gIH07XG5cbiAgZnVuY3Rpb24gUGlwZWxpbmVQcm92aWRlcihjb250YWluZXIpIHtcbiAgICBcblxuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuc3RlcHMgPSBbQnVpbGROYXZpZ2F0aW9uUGxhblN0ZXAsIENhbkRlYWN0aXZhdGVQcmV2aW91c1N0ZXAsIExvYWRSb3V0ZVN0ZXAsIHRoaXMuX2NyZWF0ZVBpcGVsaW5lU2xvdCgnYXV0aG9yaXplJyksIENhbkFjdGl2YXRlTmV4dFN0ZXAsIHRoaXMuX2NyZWF0ZVBpcGVsaW5lU2xvdCgncHJlQWN0aXZhdGUnLCAnbW9kZWxiaW5kJyksIERlYWN0aXZhdGVQcmV2aW91c1N0ZXAsIEFjdGl2YXRlTmV4dFN0ZXAsIHRoaXMuX2NyZWF0ZVBpcGVsaW5lU2xvdCgncHJlUmVuZGVyJywgJ3ByZWNvbW1pdCcpLCBDb21taXRDaGFuZ2VzU3RlcCwgdGhpcy5fY3JlYXRlUGlwZWxpbmVTbG90KCdwb3N0UmVuZGVyJywgJ3Bvc3Rjb21wbGV0ZScpXTtcbiAgfVxuXG4gIFBpcGVsaW5lUHJvdmlkZXIucHJvdG90eXBlLmNyZWF0ZVBpcGVsaW5lID0gZnVuY3Rpb24gY3JlYXRlUGlwZWxpbmUoKSB7XG4gICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICB2YXIgdXNlQ2FuRGVhY3RpdmF0ZVN0ZXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG5cbiAgICB2YXIgcGlwZWxpbmUgPSBuZXcgUGlwZWxpbmUoKTtcbiAgICB0aGlzLnN0ZXBzLmZvckVhY2goZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgIGlmICh1c2VDYW5EZWFjdGl2YXRlU3RlcCB8fCBzdGVwICE9PSBDYW5EZWFjdGl2YXRlUHJldmlvdXNTdGVwKSB7XG4gICAgICAgIHBpcGVsaW5lLmFkZFN0ZXAoX3RoaXM5LmNvbnRhaW5lci5nZXQoc3RlcCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwaXBlbGluZTtcbiAgfTtcblxuICBQaXBlbGluZVByb3ZpZGVyLnByb3RvdHlwZS5fZmluZFN0ZXAgPSBmdW5jdGlvbiBfZmluZFN0ZXAobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnN0ZXBzLmZpbmQoZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LnNsb3ROYW1lID09PSBuYW1lIHx8IHguc2xvdEFsaWFzID09PSBuYW1lO1xuICAgIH0pO1xuICB9O1xuXG4gIFBpcGVsaW5lUHJvdmlkZXIucHJvdG90eXBlLmFkZFN0ZXAgPSBmdW5jdGlvbiBhZGRTdGVwKG5hbWUsIHN0ZXApIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLl9maW5kU3RlcChuYW1lKTtcbiAgICBpZiAoZm91bmQpIHtcbiAgICAgIGlmICghZm91bmQuc3RlcHMuaW5jbHVkZXMoc3RlcCkpIHtcbiAgICAgICAgZm91bmQuc3RlcHMucHVzaChzdGVwKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBpcGVsaW5lIHNsb3QgbmFtZTogJyArIG5hbWUgKyAnLicpO1xuICAgIH1cbiAgfTtcblxuICBQaXBlbGluZVByb3ZpZGVyLnByb3RvdHlwZS5yZW1vdmVTdGVwID0gZnVuY3Rpb24gcmVtb3ZlU3RlcChuYW1lLCBzdGVwKSB7XG4gICAgdmFyIHNsb3QgPSB0aGlzLl9maW5kU3RlcChuYW1lKTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgc2xvdC5zdGVwcy5zcGxpY2Uoc2xvdC5zdGVwcy5pbmRleE9mKHN0ZXApLCAxKTtcbiAgICB9XG4gIH07XG5cbiAgUGlwZWxpbmVQcm92aWRlci5wcm90b3R5cGUuX2NsZWFyU3RlcHMgPSBmdW5jdGlvbiBfY2xlYXJTdGVwcygpIHtcbiAgICB2YXIgbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG5cbiAgICB2YXIgc2xvdCA9IHRoaXMuX2ZpbmRTdGVwKG5hbWUpO1xuICAgIGlmIChzbG90KSB7XG4gICAgICBzbG90LnN0ZXBzID0gW107XG4gICAgfVxuICB9O1xuXG4gIFBpcGVsaW5lUHJvdmlkZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5fY2xlYXJTdGVwcygnYXV0aG9yaXplJyk7XG4gICAgdGhpcy5fY2xlYXJTdGVwcygncHJlQWN0aXZhdGUnKTtcbiAgICB0aGlzLl9jbGVhclN0ZXBzKCdwcmVSZW5kZXInKTtcbiAgICB0aGlzLl9jbGVhclN0ZXBzKCdwb3N0UmVuZGVyJyk7XG4gIH07XG5cbiAgUGlwZWxpbmVQcm92aWRlci5wcm90b3R5cGUuX2NyZWF0ZVBpcGVsaW5lU2xvdCA9IGZ1bmN0aW9uIF9jcmVhdGVQaXBlbGluZVNsb3QobmFtZSwgYWxpYXMpIHtcbiAgICByZXR1cm4gbmV3IFBpcGVsaW5lU2xvdCh0aGlzLmNvbnRhaW5lciwgbmFtZSwgYWxpYXMpO1xuICB9O1xuXG4gIHJldHVybiBQaXBlbGluZVByb3ZpZGVyO1xufSgpO1xuXG52YXIgbG9nZ2VyID0gTG9nTWFuYWdlci5nZXRMb2dnZXIoJ2FwcC1yb3V0ZXInKTtcblxuZXhwb3J0IHZhciBBcHBSb3V0ZXIgPSBmdW5jdGlvbiAoX1JvdXRlcikge1xuICBfaW5oZXJpdHMoQXBwUm91dGVyLCBfUm91dGVyKTtcblxuICBBcHBSb3V0ZXIuaW5qZWN0ID0gZnVuY3Rpb24gaW5qZWN0KCkge1xuICAgIHJldHVybiBbQ29udGFpbmVyLCBIaXN0b3J5LCBQaXBlbGluZVByb3ZpZGVyLCBFdmVudEFnZ3JlZ2F0b3JdO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFwcFJvdXRlcihjb250YWluZXIsIGhpc3RvcnksIHBpcGVsaW5lUHJvdmlkZXIsIGV2ZW50cykge1xuICAgIFxuXG4gICAgdmFyIF90aGlzMTAgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUm91dGVyLmNhbGwodGhpcywgY29udGFpbmVyLCBoaXN0b3J5KSk7XG5cbiAgICBfdGhpczEwLnBpcGVsaW5lUHJvdmlkZXIgPSBwaXBlbGluZVByb3ZpZGVyO1xuICAgIF90aGlzMTAuZXZlbnRzID0gZXZlbnRzO1xuICAgIHJldHVybiBfdGhpczEwO1xuICB9XG5cbiAgQXBwUm91dGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIF9Sb3V0ZXIucHJvdG90eXBlLnJlc2V0LmNhbGwodGhpcyk7XG4gICAgdGhpcy5tYXhJbnN0cnVjdGlvbkNvdW50ID0gMTA7XG4gICAgaWYgKCF0aGlzLl9xdWV1ZSkge1xuICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcXVldWUubGVuZ3RoID0gMDtcbiAgICB9XG4gIH07XG5cbiAgQXBwUm91dGVyLnByb3RvdHlwZS5sb2FkVXJsID0gZnVuY3Rpb24gbG9hZFVybCh1cmwpIHtcbiAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlTmF2aWdhdGlvbkluc3RydWN0aW9uKHVybCkudGhlbihmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgIHJldHVybiBfdGhpczExLl9xdWV1ZUluc3RydWN0aW9uKGluc3RydWN0aW9uKTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihlcnJvcik7XG4gICAgICByZXN0b3JlUHJldmlvdXNMb2NhdGlvbihfdGhpczExKTtcbiAgICB9KTtcbiAgfTtcblxuICBBcHBSb3V0ZXIucHJvdG90eXBlLnJlZ2lzdGVyVmlld1BvcnQgPSBmdW5jdGlvbiByZWdpc3RlclZpZXdQb3J0KHZpZXdQb3J0LCBuYW1lKSB7XG4gICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuXG4gICAgX1JvdXRlci5wcm90b3R5cGUucmVnaXN0ZXJWaWV3UG9ydC5jYWxsKHRoaXMsIHZpZXdQb3J0LCBuYW1lKTtcblxuICAgIGlmICghdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgdmFyIHZpZXdNb2RlbCA9IHRoaXMuX2ZpbmRWaWV3TW9kZWwodmlld1BvcnQpO1xuICAgICAgaWYgKCdjb25maWd1cmVSb3V0ZXInIGluIHZpZXdNb2RlbCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNDb25maWd1cmVkKSB7XG4gICAgICAgICAgdmFyIHJlc29sdmVDb25maWd1cmVkUHJvbWlzZSA9IHRoaXMuX3Jlc29sdmVDb25maWd1cmVkUHJvbWlzZTtcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlQ29uZmlndXJlZFByb21pc2UgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmUoZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXdNb2RlbC5jb25maWd1cmVSb3V0ZXIoY29uZmlnLCBfdGhpczEyKTtcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMTIuYWN0aXZhdGUoKTtcbiAgICAgICAgICAgIHJlc29sdmVDb25maWd1cmVkUHJvbWlzZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RlcXVldWVJbnN0cnVjdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcblxuICBBcHBSb3V0ZXIucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gYWN0aXZhdGUob3B0aW9ucykge1xuICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHJvdXRlSGFuZGxlcjogdGhpcy5sb2FkVXJsLmJpbmQodGhpcykgfSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICB0aGlzLmhpc3RvcnkuYWN0aXZhdGUodGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLl9kZXF1ZXVlSW5zdHJ1Y3Rpb24oKTtcbiAgfTtcblxuICBBcHBSb3V0ZXIucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiBkZWFjdGl2YXRlKCkge1xuICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmhpc3RvcnkuZGVhY3RpdmF0ZSgpO1xuICB9O1xuXG4gIEFwcFJvdXRlci5wcm90b3R5cGUuX3F1ZXVlSW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbiBfcXVldWVJbnN0cnVjdGlvbihpbnN0cnVjdGlvbikge1xuICAgIHZhciBfdGhpczEzID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgaW5zdHJ1Y3Rpb24ucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBfdGhpczEzLl9xdWV1ZS51bnNoaWZ0KGluc3RydWN0aW9uKTtcbiAgICAgIF90aGlzMTMuX2RlcXVldWVJbnN0cnVjdGlvbigpO1xuICAgIH0pO1xuICB9O1xuXG4gIEFwcFJvdXRlci5wcm90b3R5cGUuX2RlcXVldWVJbnN0cnVjdGlvbiA9IGZ1bmN0aW9uIF9kZXF1ZXVlSW5zdHJ1Y3Rpb24oKSB7XG4gICAgdmFyIF90aGlzMTQgPSB0aGlzO1xuXG4gICAgdmFyIGluc3RydWN0aW9uQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMxNC5pc05hdmlnYXRpbmcgJiYgIWluc3RydWN0aW9uQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdmFyIGluc3RydWN0aW9uID0gX3RoaXMxNC5fcXVldWUuc2hpZnQoKTtcbiAgICAgIF90aGlzMTQuX3F1ZXVlLmxlbmd0aCA9IDA7XG5cbiAgICAgIGlmICghaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgX3RoaXMxNC5pc05hdmlnYXRpbmcgPSB0cnVlO1xuXG4gICAgICB2YXIgbmF2dHJhY2tlciA9IF90aGlzMTQuaGlzdG9yeS5nZXRTdGF0ZSgnTmF2aWdhdGlvblRyYWNrZXInKTtcbiAgICAgIGlmICghbmF2dHJhY2tlciAmJiAhX3RoaXMxNC5jdXJyZW50TmF2aWdhdGlvblRyYWNrZXIpIHtcbiAgICAgICAgX3RoaXMxNC5pc05hdmlnYXRpbmdGaXJzdCA9IHRydWU7XG4gICAgICAgIF90aGlzMTQuaXNOYXZpZ2F0aW5nTmV3ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIW5hdnRyYWNrZXIpIHtcbiAgICAgICAgX3RoaXMxNC5pc05hdmlnYXRpbmdOZXcgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICghX3RoaXMxNC5jdXJyZW50TmF2aWdhdGlvblRyYWNrZXIpIHtcbiAgICAgICAgX3RoaXMxNC5pc05hdmlnYXRpbmdSZWZyZXNoID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoX3RoaXMxNC5jdXJyZW50TmF2aWdhdGlvblRyYWNrZXIgPCBuYXZ0cmFja2VyKSB7XG4gICAgICAgIF90aGlzMTQuaXNOYXZpZ2F0aW5nRm9yd2FyZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKF90aGlzMTQuY3VycmVudE5hdmlnYXRpb25UcmFja2VyID4gbmF2dHJhY2tlcikge1xuICAgICAgICBfdGhpczE0LmlzTmF2aWdhdGluZ0JhY2sgPSB0cnVlO1xuICAgICAgfWlmICghbmF2dHJhY2tlcikge1xuICAgICAgICBuYXZ0cmFja2VyID0gRGF0ZS5ub3coKTtcbiAgICAgICAgX3RoaXMxNC5oaXN0b3J5LnNldFN0YXRlKCdOYXZpZ2F0aW9uVHJhY2tlcicsIG5hdnRyYWNrZXIpO1xuICAgICAgfVxuICAgICAgX3RoaXMxNC5jdXJyZW50TmF2aWdhdGlvblRyYWNrZXIgPSBuYXZ0cmFja2VyO1xuXG4gICAgICBpbnN0cnVjdGlvbi5wcmV2aW91c0luc3RydWN0aW9uID0gX3RoaXMxNC5jdXJyZW50SW5zdHJ1Y3Rpb247XG5cbiAgICAgIGlmICghaW5zdHJ1Y3Rpb25Db3VudCkge1xuICAgICAgICBfdGhpczE0LmV2ZW50cy5wdWJsaXNoKCdyb3V0ZXI6bmF2aWdhdGlvbjpwcm9jZXNzaW5nJywgeyBpbnN0cnVjdGlvbjogaW5zdHJ1Y3Rpb24gfSk7XG4gICAgICB9IGVsc2UgaWYgKGluc3RydWN0aW9uQ291bnQgPT09IF90aGlzMTQubWF4SW5zdHJ1Y3Rpb25Db3VudCAtIDEpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGluc3RydWN0aW9uQ291bnQgKyAxICsgJyBuYXZpZ2F0aW9uIGluc3RydWN0aW9ucyBoYXZlIGJlZW4gYXR0ZW1wdGVkIHdpdGhvdXQgc3VjY2Vzcy4gUmVzdG9yaW5nIGxhc3Qga25vd24gZ29vZCBsb2NhdGlvbi4nKTtcbiAgICAgICAgcmVzdG9yZVByZXZpb3VzTG9jYXRpb24oX3RoaXMxNCk7XG4gICAgICAgIHJldHVybiBfdGhpczE0Ll9kZXF1ZXVlSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25Db3VudCArIDEpO1xuICAgICAgfSBlbHNlIGlmIChpbnN0cnVjdGlvbkNvdW50ID4gX3RoaXMxNC5tYXhJbnN0cnVjdGlvbkNvdW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWF4aW11bSBuYXZpZ2F0aW9uIGF0dGVtcHRzIGV4Y2VlZGVkLiBHaXZpbmcgdXAuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwaXBlbGluZSA9IF90aGlzMTQucGlwZWxpbmVQcm92aWRlci5jcmVhdGVQaXBlbGluZSghX3RoaXMxNC5jb3VsZERlYWN0aXZhdGUpO1xuXG4gICAgICByZXR1cm4gcGlwZWxpbmUucnVuKGluc3RydWN0aW9uKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NSZXN1bHQoaW5zdHJ1Y3Rpb24sIHJlc3VsdCwgaW5zdHJ1Y3Rpb25Db3VudCwgX3RoaXMxNCk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHsgb3V0cHV0OiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoZXJyb3IpIH07XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVJbnN0cnVjdGlvbihpbnN0cnVjdGlvbiwgcmVzdWx0LCAhIWluc3RydWN0aW9uQ291bnQsIF90aGlzMTQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgQXBwUm91dGVyLnByb3RvdHlwZS5fZmluZFZpZXdNb2RlbCA9IGZ1bmN0aW9uIF9maW5kVmlld01vZGVsKHZpZXdQb3J0KSB7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyLnZpZXdNb2RlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLnZpZXdNb2RlbDtcbiAgICB9XG5cbiAgICBpZiAodmlld1BvcnQuY29udGFpbmVyKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gdmlld1BvcnQuY29udGFpbmVyO1xuXG4gICAgICB3aGlsZSAoY29udGFpbmVyKSB7XG4gICAgICAgIGlmIChjb250YWluZXIudmlld01vZGVsKSB7XG4gICAgICAgICAgdGhpcy5jb250YWluZXIudmlld01vZGVsID0gY29udGFpbmVyLnZpZXdNb2RlbDtcbiAgICAgICAgICByZXR1cm4gY29udGFpbmVyLnZpZXdNb2RlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICByZXR1cm4gQXBwUm91dGVyO1xufShSb3V0ZXIpO1xuXG5mdW5jdGlvbiBwcm9jZXNzUmVzdWx0KGluc3RydWN0aW9uLCByZXN1bHQsIGluc3RydWN0aW9uQ291bnQsIHJvdXRlcikge1xuICBpZiAoIShyZXN1bHQgJiYgJ2NvbXBsZXRlZCcgaW4gcmVzdWx0ICYmICdvdXRwdXQnIGluIHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwge307XG4gICAgcmVzdWx0Lm91dHB1dCA9IG5ldyBFcnJvcignRXhwZWN0ZWQgcm91dGVyIHBpcGVsaW5lIHRvIHJldHVybiBhIG5hdmlnYXRpb24gcmVzdWx0LCBidXQgZ290IFsnICsgSlNPTi5zdHJpbmdpZnkocmVzdWx0KSArICddIGluc3RlYWQuJyk7XG4gIH1cblxuICB2YXIgZmluYWxSZXN1bHQgPSBudWxsO1xuICB2YXIgbmF2aWdhdGlvbkNvbW1hbmRSZXN1bHQgPSBudWxsO1xuICBpZiAoaXNOYXZpZ2F0aW9uQ29tbWFuZChyZXN1bHQub3V0cHV0KSkge1xuICAgIG5hdmlnYXRpb25Db21tYW5kUmVzdWx0ID0gcmVzdWx0Lm91dHB1dC5uYXZpZ2F0ZShyb3V0ZXIpO1xuICB9IGVsc2Uge1xuICAgIGZpbmFsUmVzdWx0ID0gcmVzdWx0O1xuXG4gICAgaWYgKCFyZXN1bHQuY29tcGxldGVkKSB7XG4gICAgICBpZiAocmVzdWx0Lm91dHB1dCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihyZXN1bHQub3V0cHV0KTtcbiAgICAgIH1cblxuICAgICAgcmVzdG9yZVByZXZpb3VzTG9jYXRpb24ocm91dGVyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5hdmlnYXRpb25Db21tYW5kUmVzdWx0KS50aGVuKGZ1bmN0aW9uIChfKSB7XG4gICAgcmV0dXJuIHJvdXRlci5fZGVxdWV1ZUluc3RydWN0aW9uKGluc3RydWN0aW9uQ291bnQgKyAxKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoaW5uZXJSZXN1bHQpIHtcbiAgICByZXR1cm4gZmluYWxSZXN1bHQgfHwgaW5uZXJSZXN1bHQgfHwgcmVzdWx0O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluc3RydWN0aW9uKGluc3RydWN0aW9uLCByZXN1bHQsIGlzSW5uZXJJbnN0cnVjdGlvbiwgcm91dGVyKSB7XG4gIGluc3RydWN0aW9uLnJlc29sdmUocmVzdWx0KTtcblxuICB2YXIgZXZlbnRBcmdzID0geyBpbnN0cnVjdGlvbjogaW5zdHJ1Y3Rpb24sIHJlc3VsdDogcmVzdWx0IH07XG4gIGlmICghaXNJbm5lckluc3RydWN0aW9uKSB7XG4gICAgcm91dGVyLmlzTmF2aWdhdGluZyA9IGZhbHNlO1xuICAgIHJvdXRlci5pc0V4cGxpY2l0TmF2aWdhdGlvbiA9IGZhbHNlO1xuICAgIHJvdXRlci5pc0V4cGxpY2l0TmF2aWdhdGlvbkJhY2sgPSBmYWxzZTtcbiAgICByb3V0ZXIuaXNOYXZpZ2F0aW5nRmlyc3QgPSBmYWxzZTtcbiAgICByb3V0ZXIuaXNOYXZpZ2F0aW5nTmV3ID0gZmFsc2U7XG4gICAgcm91dGVyLmlzTmF2aWdhdGluZ1JlZnJlc2ggPSBmYWxzZTtcbiAgICByb3V0ZXIuaXNOYXZpZ2F0aW5nRm9yd2FyZCA9IGZhbHNlO1xuICAgIHJvdXRlci5pc05hdmlnYXRpbmdCYWNrID0gZmFsc2U7XG4gICAgcm91dGVyLmNvdWxkRGVhY3RpdmF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIGV2ZW50TmFtZSA9IHZvaWQgMDtcblxuICAgIGlmIChyZXN1bHQub3V0cHV0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGV2ZW50TmFtZSA9ICdlcnJvcic7XG4gICAgfSBlbHNlIGlmICghcmVzdWx0LmNvbXBsZXRlZCkge1xuICAgICAgZXZlbnROYW1lID0gJ2NhbmNlbGVkJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9xdWVyeVN0cmluZyA9IGluc3RydWN0aW9uLnF1ZXJ5U3RyaW5nID8gJz8nICsgaW5zdHJ1Y3Rpb24ucXVlcnlTdHJpbmcgOiAnJztcbiAgICAgIHJvdXRlci5oaXN0b3J5LnByZXZpb3VzTG9jYXRpb24gPSBpbnN0cnVjdGlvbi5mcmFnbWVudCArIF9xdWVyeVN0cmluZztcbiAgICAgIGV2ZW50TmFtZSA9ICdzdWNjZXNzJztcbiAgICB9XG5cbiAgICByb3V0ZXIuZXZlbnRzLnB1Ymxpc2goJ3JvdXRlcjpuYXZpZ2F0aW9uOicgKyBldmVudE5hbWUsIGV2ZW50QXJncyk7XG4gICAgcm91dGVyLmV2ZW50cy5wdWJsaXNoKCdyb3V0ZXI6bmF2aWdhdGlvbjpjb21wbGV0ZScsIGV2ZW50QXJncyk7XG4gIH0gZWxzZSB7XG4gICAgcm91dGVyLmV2ZW50cy5wdWJsaXNoKCdyb3V0ZXI6bmF2aWdhdGlvbjpjaGlsZDpjb21wbGV0ZScsIGV2ZW50QXJncyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZXN0b3JlUHJldmlvdXNMb2NhdGlvbihyb3V0ZXIpIHtcbiAgdmFyIHByZXZpb3VzTG9jYXRpb24gPSByb3V0ZXIuaGlzdG9yeS5wcmV2aW91c0xvY2F0aW9uO1xuICBpZiAocHJldmlvdXNMb2NhdGlvbikge1xuICAgIHJvdXRlci5uYXZpZ2F0ZShyb3V0ZXIuaGlzdG9yeS5wcmV2aW91c0xvY2F0aW9uLCB7IHRyaWdnZXI6IGZhbHNlLCByZXBsYWNlOiB0cnVlIH0pO1xuICB9IGVsc2UgaWYgKHJvdXRlci5mYWxsYmFja1JvdXRlKSB7XG4gICAgcm91dGVyLm5hdmlnYXRlKHJvdXRlci5mYWxsYmFja1JvdXRlLCB7IHRyaWdnZXI6IHRydWUsIHJlcGxhY2U6IHRydWUgfSk7XG4gIH0gZWxzZSB7XG4gICAgbG9nZ2VyLmVycm9yKCdSb3V0ZXIgbmF2aWdhdGlvbiBmYWlsZWQsIGFuZCBubyBwcmV2aW91cyBsb2NhdGlvbiBvciBmYWxsYmFja1JvdXRlIGNvdWxkIGJlIHJlc3RvcmVkLicpO1xuICB9XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4ysu\n");

/***/ }),

/***/ "Q/5p":
/*!*********************************************************************************!*\
  !*** ./node_modules/aurelia-polyfills/dist/native-modules/aurelia-polyfills.js ***!
  \*********************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var aurelia_pal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-pal */ \"70NS\");\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n\n\nif (typeof FEATURE_NO_ES2015 === 'undefined') {\n\n  (function (Object, GOPS) {\n    'use strict';\n\n    if (GOPS in Object) return;\n\n    var setDescriptor,\n        G = aurelia_pal__WEBPACK_IMPORTED_MODULE_0__[\"PLATFORM\"].global,\n        id = 0,\n        random = '' + Math.random(),\n        prefix = '__\\x01symbol:',\n        prefixLength = prefix.length,\n        internalSymbol = '__\\x01symbol@@' + random,\n        DP = 'defineProperty',\n        DPies = 'defineProperties',\n        GOPN = 'getOwnPropertyNames',\n        GOPD = 'getOwnPropertyDescriptor',\n        PIE = 'propertyIsEnumerable',\n        gOPN = Object[GOPN],\n        gOPD = Object[GOPD],\n        create = Object.create,\n        keys = Object.keys,\n        defineProperty = Object[DP],\n        $defineProperties = Object[DPies],\n        descriptor = gOPD(Object, GOPN),\n        ObjectProto = Object.prototype,\n        hOP = ObjectProto.hasOwnProperty,\n        pIE = ObjectProto[PIE],\n        toString = ObjectProto.toString,\n        indexOf = Array.prototype.indexOf || function (v) {\n      for (var i = this.length; i-- && this[i] !== v;) {}\n      return i;\n    },\n        addInternalIfNeeded = function addInternalIfNeeded(o, uid, enumerable) {\n      if (!hOP.call(o, internalSymbol)) {\n        defineProperty(o, internalSymbol, {\n          enumerable: false,\n          configurable: false,\n          writable: false,\n          value: {}\n        });\n      }\n      o[internalSymbol]['@@' + uid] = enumerable;\n    },\n        createWithSymbols = function createWithSymbols(proto, descriptors) {\n      var self = create(proto);\n      if (descriptors !== null && (typeof descriptors === 'undefined' ? 'undefined' : _typeof(descriptors)) === 'object') {\n        gOPN(descriptors).forEach(function (key) {\n          if (propertyIsEnumerable.call(descriptors, key)) {\n            $defineProperty(self, key, descriptors[key]);\n          }\n        });\n      }\n      return self;\n    },\n        copyAsNonEnumerable = function copyAsNonEnumerable(descriptor) {\n      var newDescriptor = create(descriptor);\n      newDescriptor.enumerable = false;\n      return newDescriptor;\n    },\n        get = function get() {},\n        onlyNonSymbols = function onlyNonSymbols(name) {\n      return name != internalSymbol && !hOP.call(source, name);\n    },\n        onlySymbols = function onlySymbols(name) {\n      return name != internalSymbol && hOP.call(source, name);\n    },\n        propertyIsEnumerable = function propertyIsEnumerable(key) {\n      var uid = '' + key;\n      return onlySymbols(uid) ? hOP.call(this, uid) && this[internalSymbol] && this[internalSymbol]['@@' + uid] : pIE.call(this, key);\n    },\n        setAndGetSymbol = function setAndGetSymbol(uid) {\n      var descriptor = {\n        enumerable: false,\n        configurable: true,\n        get: get,\n        set: function set(value) {\n          setDescriptor(this, uid, {\n            enumerable: false,\n            configurable: true,\n            writable: true,\n            value: value\n          });\n          addInternalIfNeeded(this, uid, true);\n        }\n      };\n      defineProperty(ObjectProto, uid, descriptor);\n      return source[uid] = defineProperty(Object(uid), 'constructor', sourceConstructor);\n    },\n        _Symbol = function _Symbol2(description) {\n      if (this && this !== G) {\n        throw new TypeError('Symbol is not a constructor');\n      }\n      return setAndGetSymbol(prefix.concat(description || '', random, ++id));\n    },\n        source = create(null),\n        sourceConstructor = { value: _Symbol },\n        sourceMap = function sourceMap(uid) {\n      return source[uid];\n    },\n        $defineProperty = function defineProp(o, key, descriptor) {\n      var uid = '' + key;\n      if (onlySymbols(uid)) {\n        setDescriptor(o, uid, descriptor.enumerable ? copyAsNonEnumerable(descriptor) : descriptor);\n        addInternalIfNeeded(o, uid, !!descriptor.enumerable);\n      } else {\n        defineProperty(o, key, descriptor);\n      }\n      return o;\n    },\n        $getOwnPropertySymbols = function getOwnPropertySymbols(o) {\n      var cof = toString.call(o);\n      o = cof === '[object String]' ? o.split('') : Object(o);\n      return gOPN(o).filter(onlySymbols).map(sourceMap);\n    };\n\n    descriptor.value = $defineProperty;\n    defineProperty(Object, DP, descriptor);\n\n    descriptor.value = $getOwnPropertySymbols;\n    defineProperty(Object, GOPS, descriptor);\n\n    var cachedWindowNames = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' ? Object.getOwnPropertyNames(window) : [];\n    var originalObjectGetOwnPropertyNames = Object.getOwnPropertyNames;\n    descriptor.value = function getOwnPropertyNames(o) {\n      if (toString.call(o) === '[object Window]') {\n        try {\n          return originalObjectGetOwnPropertyNames(o);\n        } catch (e) {\n          return [].concat([], cachedWindowNames);\n        }\n      }\n      return gOPN(o).filter(onlyNonSymbols);\n    };\n    defineProperty(Object, GOPN, descriptor);\n\n    descriptor.value = function defineProperties(o, descriptors) {\n      var symbols = $getOwnPropertySymbols(descriptors);\n      if (symbols.length) {\n        keys(descriptors).concat(symbols).forEach(function (uid) {\n          if (propertyIsEnumerable.call(descriptors, uid)) {\n            $defineProperty(o, uid, descriptors[uid]);\n          }\n        });\n      } else {\n        $defineProperties(o, descriptors);\n      }\n      return o;\n    };\n    defineProperty(Object, DPies, descriptor);\n\n    descriptor.value = propertyIsEnumerable;\n    defineProperty(ObjectProto, PIE, descriptor);\n\n    descriptor.value = _Symbol;\n    defineProperty(G, 'Symbol', descriptor);\n\n    descriptor.value = function (key) {\n      var uid = prefix.concat(prefix, key, random);\n      return uid in ObjectProto ? source[uid] : setAndGetSymbol(uid);\n    };\n    defineProperty(_Symbol, 'for', descriptor);\n\n    descriptor.value = function (symbol) {\n      return hOP.call(source, symbol) ? symbol.slice(prefixLength * 2, -random.length) : void 0;\n    };\n    defineProperty(_Symbol, 'keyFor', descriptor);\n\n    descriptor.value = function getOwnPropertyDescriptor(o, key) {\n      var descriptor = gOPD(o, key);\n      if (descriptor && onlySymbols(key)) {\n        descriptor.enumerable = propertyIsEnumerable.call(o, key);\n      }\n      return descriptor;\n    };\n    defineProperty(Object, GOPD, descriptor);\n\n    descriptor.value = function (proto, descriptors) {\n      return arguments.length === 1 ? create(proto) : createWithSymbols(proto, descriptors);\n    };\n    defineProperty(Object, 'create', descriptor);\n\n    descriptor.value = function () {\n      var str = toString.call(this);\n      return str === '[object String]' && onlySymbols(this) ? '[object Symbol]' : str;\n    };\n    defineProperty(ObjectProto, 'toString', descriptor);\n\n    try {\n      setDescriptor = create(defineProperty({}, prefix, {\n        get: function get() {\n          return defineProperty(this, prefix, { value: false })[prefix];\n        }\n      }))[prefix] || defineProperty;\n    } catch (o_O) {\n      setDescriptor = function setDescriptor(o, key, descriptor) {\n        var protoDescriptor = gOPD(ObjectProto, key);\n        delete ObjectProto[key];\n        defineProperty(o, key, descriptor);\n        defineProperty(ObjectProto, key, protoDescriptor);\n      };\n    }\n  })(Object, 'getOwnPropertySymbols');\n\n  (function (O, S) {\n    var dP = O.defineProperty,\n        ObjectProto = O.prototype,\n        toString = ObjectProto.toString,\n        toStringTag = 'toStringTag',\n        descriptor;\n    ['iterator', 'match', 'replace', 'search', 'split', 'hasInstance', 'isConcatSpreadable', 'unscopables', 'species', 'toPrimitive', toStringTag].forEach(function (name) {\n      if (!(name in Symbol)) {\n        dP(Symbol, name, { value: Symbol(name) });\n        switch (name) {\n          case toStringTag:\n            descriptor = O.getOwnPropertyDescriptor(ObjectProto, 'toString');\n            descriptor.value = function () {\n              var str = toString.call(this),\n                  tst = typeof this === 'undefined' || this === null ? undefined : this[Symbol.toStringTag];\n              return typeof tst === 'undefined' ? str : '[object ' + tst + ']';\n            };\n            dP(ObjectProto, 'toString', descriptor);\n            break;\n        }\n      }\n    });\n  })(Object, Symbol);\n\n  (function (Si, AP, SP) {\n\n    function returnThis() {\n      return this;\n    }\n\n    if (!AP[Si]) AP[Si] = function () {\n      var i = 0,\n          self = this,\n          iterator = {\n        next: function next() {\n          var done = self.length <= i;\n          return done ? { done: done } : { done: done, value: self[i++] };\n        }\n      };\n      iterator[Si] = returnThis;\n      return iterator;\n    };\n\n    if (!SP[Si]) SP[Si] = function () {\n      var fromCodePoint = String.fromCodePoint,\n          self = this,\n          i = 0,\n          length = self.length,\n          iterator = {\n        next: function next() {\n          var done = length <= i,\n              c = done ? '' : fromCodePoint(self.codePointAt(i));\n          i += c.length;\n          return done ? { done: done } : { done: done, value: c };\n        }\n      };\n      iterator[Si] = returnThis;\n      return iterator;\n    };\n  })(Symbol.iterator, Array.prototype, String.prototype);\n}\n\nif (typeof FEATURE_NO_ES2015 === 'undefined') {\n\n  Number.isNaN = Number.isNaN || function (value) {\n    return value !== value;\n  };\n\n  Number.isFinite = Number.isFinite || function (value) {\n    return typeof value === \"number\" && isFinite(value);\n  };\n}\n\nif (!String.prototype.endsWith || function () {\n  try {\n    return !\"ab\".endsWith(\"a\", 1);\n  } catch (e) {\n    return true;\n  }\n}()) {\n  String.prototype.endsWith = function (searchString, position) {\n    var subjectString = this.toString();\n    if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {\n      position = subjectString.length;\n    }\n    position -= searchString.length;\n    var lastIndex = subjectString.indexOf(searchString, position);\n    return lastIndex !== -1 && lastIndex === position;\n  };\n}\n\nif (!String.prototype.startsWith || function () {\n  try {\n    return !\"ab\".startsWith(\"b\", 1);\n  } catch (e) {\n    return true;\n  }\n}()) {\n  String.prototype.startsWith = function (searchString, position) {\n    position = position || 0;\n    return this.substr(position, searchString.length) === searchString;\n  };\n}\n\nif (typeof FEATURE_NO_ES2015 === 'undefined') {\n\n  if (!Array.from) {\n    Array.from = function () {\n      var toInteger = function toInteger(it) {\n        return isNaN(it = +it) ? 0 : (it > 0 ? Math.floor : Math.ceil)(it);\n      };\n      var toLength = function toLength(it) {\n        return it > 0 ? Math.min(toInteger(it), 0x1fffffffffffff) : 0;\n      };\n      var iterCall = function iterCall(iter, fn, val, index) {\n        try {\n          return fn(val, index);\n        } catch (E) {\n          if (typeof iter.return == 'function') iter.return();\n          throw E;\n        }\n      };\n\n      return function from(arrayLike) {\n        var O = Object(arrayLike),\n            C = typeof this == 'function' ? this : Array,\n            aLen = arguments.length,\n            mapfn = aLen > 1 ? arguments[1] : undefined,\n            mapping = mapfn !== undefined,\n            index = 0,\n            iterFn = O[Symbol.iterator],\n            length,\n            result,\n            step,\n            iterator;\n        if (mapping) mapfn = mapfn.bind(aLen > 2 ? arguments[2] : undefined);\n        if (iterFn != undefined && !Array.isArray(arrayLike)) {\n          for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {\n            result[index] = mapping ? iterCall(iterator, mapfn, step.value, index) : step.value;\n          }\n        } else {\n          length = toLength(O.length);\n          for (result = new C(length); length > index; index++) {\n            result[index] = mapping ? mapfn(O[index], index) : O[index];\n          }\n        }\n        result.length = index;\n        return result;\n      };\n    }();\n  }\n\n  if (!Array.prototype.find) {\n    Object.defineProperty(Array.prototype, 'find', {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: function value(predicate) {\n        if (this === null) {\n          throw new TypeError('Array.prototype.find called on null or undefined');\n        }\n        if (typeof predicate !== 'function') {\n          throw new TypeError('predicate must be a function');\n        }\n        var list = Object(this);\n        var length = list.length >>> 0;\n        var thisArg = arguments[1];\n        var value;\n\n        for (var i = 0; i < length; i++) {\n          value = list[i];\n          if (predicate.call(thisArg, value, i, list)) {\n            return value;\n          }\n        }\n        return undefined;\n      }\n    });\n  }\n\n  if (!Array.prototype.findIndex) {\n    Object.defineProperty(Array.prototype, 'findIndex', {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: function value(predicate) {\n        if (this === null) {\n          throw new TypeError('Array.prototype.findIndex called on null or undefined');\n        }\n        if (typeof predicate !== 'function') {\n          throw new TypeError('predicate must be a function');\n        }\n        var list = Object(this);\n        var length = list.length >>> 0;\n        var thisArg = arguments[1];\n        var value;\n\n        for (var i = 0; i < length; i++) {\n          value = list[i];\n          if (predicate.call(thisArg, value, i, list)) {\n            return i;\n          }\n        }\n        return -1;\n      }\n    });\n  }\n}\n\nif (typeof FEATURE_NO_ES2016 === 'undefined' && !Array.prototype.includes) {\n  Object.defineProperty(Array.prototype, 'includes', {\n    configurable: true,\n    writable: true,\n    enumerable: false,\n    value: function value(searchElement) {\n      var O = Object(this);\n      var len = parseInt(O.length) || 0;\n      if (len === 0) {\n        return false;\n      }\n      var n = parseInt(arguments[1]) || 0;\n      var k;\n      if (n >= 0) {\n        k = n;\n      } else {\n        k = len + n;\n        if (k < 0) {\n          k = 0;\n        }\n      }\n      var currentElement;\n      while (k < len) {\n        currentElement = O[k];\n        if (searchElement === currentElement || searchElement !== searchElement && currentElement !== currentElement) {\n          return true;\n        }\n        k++;\n      }\n      return false;\n    }\n  });\n}\n\nif (typeof FEATURE_NO_ES2015 === 'undefined') {\n\n  (function () {\n    var needsFix = false;\n\n    try {\n      var s = Object.keys('a');\n      needsFix = s.length !== 1 || s[0] !== '0';\n    } catch (e) {\n      needsFix = true;\n    }\n\n    if (needsFix) {\n      Object.keys = function () {\n        var hasOwnProperty = Object.prototype.hasOwnProperty,\n            hasDontEnumBug = !{ toString: null }.propertyIsEnumerable('toString'),\n            dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],\n            dontEnumsLength = dontEnums.length;\n\n        return function (obj) {\n          if (obj === undefined || obj === null) {\n            throw TypeError('Cannot convert undefined or null to object');\n          }\n\n          obj = Object(obj);\n\n          var result = [],\n              prop,\n              i;\n\n          for (prop in obj) {\n            if (hasOwnProperty.call(obj, prop)) {\n              result.push(prop);\n            }\n          }\n\n          if (hasDontEnumBug) {\n            for (i = 0; i < dontEnumsLength; i++) {\n              if (hasOwnProperty.call(obj, dontEnums[i])) {\n                result.push(dontEnums[i]);\n              }\n            }\n          }\n\n          return result;\n        };\n      }();\n    }\n  })();\n\n  (function (O) {\n    if ('assign' in O) {\n      return;\n    }\n\n    O.defineProperty(O, 'assign', {\n      configurable: true,\n      writable: true,\n      value: function () {\n        var gOPS = O.getOwnPropertySymbols,\n            pIE = O.propertyIsEnumerable,\n            filterOS = gOPS ? function (self) {\n          return gOPS(self).filter(pIE, self);\n        } : function () {\n          return Array.prototype;\n        };\n\n        return function assign(where) {\n          if (gOPS && !(where instanceof O)) {\n            console.warn('problematic Symbols', where);\n          }\n\n          function set(keyOrSymbol) {\n            where[keyOrSymbol] = arg[keyOrSymbol];\n          }\n\n          for (var i = 1, ii = arguments.length; i < ii; ++i) {\n            var arg = arguments[i];\n\n            if (arg === null || arg === undefined) {\n              continue;\n            }\n\n            O.keys(arg).concat(filterOS(arg)).forEach(set);\n          }\n\n          return where;\n        };\n      }()\n    });\n  })(Object);\n\n  if (!Object.is) {\n    Object.is = function (x, y) {\n      if (x === y) {\n        return x !== 0 || 1 / x === 1 / y;\n      } else {\n        return x !== x && y !== y;\n      }\n    };\n  }\n}\n\nif (typeof FEATURE_NO_ES2015 === 'undefined') {\n\n  (function (global) {\n    var i;\n\n    var defineProperty = Object.defineProperty,\n        is = function is(a, b) {\n      return a === b || a !== a && b !== b;\n    };\n\n    if (typeof WeakMap == 'undefined') {\n      global.WeakMap = createCollection({\n        'delete': sharedDelete,\n\n        clear: sharedClear,\n\n        get: sharedGet,\n\n        has: mapHas,\n\n        set: sharedSet\n      }, true);\n    }\n\n    if (typeof Map == 'undefined' || typeof new Map().values !== 'function' || !new Map().values().next) {\n      var _createCollection;\n\n      global.Map = createCollection((_createCollection = {\n        'delete': sharedDelete,\n\n        has: mapHas,\n\n        get: sharedGet,\n\n        set: sharedSet,\n\n        keys: sharedKeys,\n\n        values: sharedValues,\n\n        entries: mapEntries,\n\n        forEach: sharedForEach,\n\n        clear: sharedClear\n      }, _createCollection[Symbol.iterator] = mapEntries, _createCollection));\n    }\n\n    if (typeof Set == 'undefined' || typeof new Set().values !== 'function' || !new Set().values().next) {\n      var _createCollection2;\n\n      global.Set = createCollection((_createCollection2 = {\n        has: setHas,\n\n        add: sharedAdd,\n\n        'delete': sharedDelete,\n\n        clear: sharedClear,\n\n        keys: sharedValues,\n        values: sharedValues,\n\n        entries: setEntries,\n\n        forEach: sharedForEach\n      }, _createCollection2[Symbol.iterator] = sharedValues, _createCollection2));\n    }\n\n    if (typeof WeakSet == 'undefined') {\n      global.WeakSet = createCollection({\n        'delete': sharedDelete,\n\n        add: sharedAdd,\n\n        clear: sharedClear,\n\n        has: setHas\n      }, true);\n    }\n\n    function createCollection(proto, objectOnly) {\n      function Collection(a) {\n        if (!this || this.constructor !== Collection) return new Collection(a);\n        this._keys = [];\n        this._values = [];\n        this._itp = [];\n        this.objectOnly = objectOnly;\n\n        if (a) init.call(this, a);\n      }\n\n      if (!objectOnly) {\n        defineProperty(proto, 'size', {\n          get: sharedSize\n        });\n      }\n\n      proto.constructor = Collection;\n      Collection.prototype = proto;\n\n      return Collection;\n    }\n\n    function init(a) {\n      var i;\n\n      if (this.add) a.forEach(this.add, this);else a.forEach(function (a) {\n          this.set(a[0], a[1]);\n        }, this);\n    }\n\n    function sharedDelete(key) {\n      if (this.has(key)) {\n        this._keys.splice(i, 1);\n        this._values.splice(i, 1);\n\n        this._itp.forEach(function (p) {\n          if (i < p[0]) p[0]--;\n        });\n      }\n\n      return -1 < i;\n    };\n\n    function sharedGet(key) {\n      return this.has(key) ? this._values[i] : undefined;\n    }\n\n    function has(list, key) {\n      if (this.objectOnly && key !== Object(key)) throw new TypeError(\"Invalid value used as weak collection key\");\n\n      if (key != key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {} else i = list.indexOf(key);\n      return -1 < i;\n    }\n\n    function setHas(value) {\n      return has.call(this, this._values, value);\n    }\n\n    function mapHas(value) {\n      return has.call(this, this._keys, value);\n    }\n\n    function sharedSet(key, value) {\n      this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value;\n      return this;\n    }\n\n    function sharedAdd(value) {\n      if (!this.has(value)) this._values.push(value);\n      return this;\n    }\n\n    function sharedClear() {\n      (this._keys || 0).length = this._values.length = 0;\n    }\n\n    function sharedKeys() {\n      return sharedIterator(this._itp, this._keys);\n    }\n\n    function sharedValues() {\n      return sharedIterator(this._itp, this._values);\n    }\n\n    function mapEntries() {\n      return sharedIterator(this._itp, this._keys, this._values);\n    }\n\n    function setEntries() {\n      return sharedIterator(this._itp, this._values, this._values);\n    }\n\n    function sharedIterator(itp, array, array2) {\n      var _ref;\n\n      var p = [0],\n          done = false;\n      itp.push(p);\n      return _ref = {}, _ref[Symbol.iterator] = function () {\n        return this;\n      }, _ref.next = function next() {\n        var v,\n            k = p[0];\n        if (!done && k < array.length) {\n          v = array2 ? [array[k], array2[k]] : array[k];\n          p[0]++;\n        } else {\n          done = true;\n          itp.splice(itp.indexOf(p), 1);\n        }\n        return { done: done, value: v };\n      }, _ref;\n    }\n\n    function sharedSize() {\n      return this._values.length;\n    }\n\n    function sharedForEach(callback, context) {\n      var it = this.entries();\n      for (;;) {\n        var r = it.next();\n        if (r.done) break;\n        callback.call(context, r.value[1], r.value[0], this);\n      }\n    }\n  })(aurelia_pal__WEBPACK_IMPORTED_MODULE_0__[\"PLATFORM\"].global);\n}\n\nif (typeof FEATURE_NO_ES2015 === 'undefined') {\n\n  var bind = Function.prototype.bind;\n\n  if (typeof aurelia_pal__WEBPACK_IMPORTED_MODULE_0__[\"PLATFORM\"].global.Reflect === 'undefined') {\n    aurelia_pal__WEBPACK_IMPORTED_MODULE_0__[\"PLATFORM\"].global.Reflect = {};\n  }\n\n  if (typeof Reflect.defineProperty !== 'function') {\n    Reflect.defineProperty = function (target, propertyKey, descriptor) {\n      if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' ? target === null : typeof target !== 'function') {\n        throw new TypeError('Reflect.defineProperty called on non-object');\n      }\n      try {\n        Object.defineProperty(target, propertyKey, descriptor);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    };\n  }\n\n  if (typeof Reflect.construct !== 'function') {\n    Reflect.construct = function (Target, args) {\n      if (args) {\n        switch (args.length) {\n          case 0:\n            return new Target();\n          case 1:\n            return new Target(args[0]);\n          case 2:\n            return new Target(args[0], args[1]);\n          case 3:\n            return new Target(args[0], args[1], args[2]);\n          case 4:\n            return new Target(args[0], args[1], args[2], args[3]);\n        }\n      }\n\n      var a = [null];\n      a.push.apply(a, args);\n      return new (bind.apply(Target, a))();\n    };\n  }\n\n  if (typeof Reflect.ownKeys !== 'function') {\n    Reflect.ownKeys = function (o) {\n      return Object.getOwnPropertyNames(o).concat(Object.getOwnPropertySymbols(o));\n    };\n  }\n}\n\nif (typeof FEATURE_NO_ESNEXT === 'undefined') {\n\n  var emptyMetadata = Object.freeze({});\n  var metadataContainerKey = '__metadata__';\n\n  if (typeof Reflect.getOwnMetadata !== 'function') {\n    Reflect.getOwnMetadata = function (metadataKey, target, targetKey) {\n      if (target.hasOwnProperty(metadataContainerKey)) {\n        return (target[metadataContainerKey][targetKey] || emptyMetadata)[metadataKey];\n      }\n    };\n  }\n\n  if (typeof Reflect.defineMetadata !== 'function') {\n    Reflect.defineMetadata = function (metadataKey, metadataValue, target, targetKey) {\n      var metadataContainer = target.hasOwnProperty(metadataContainerKey) ? target[metadataContainerKey] : target[metadataContainerKey] = {};\n      var targetContainer = metadataContainer[targetKey] || (metadataContainer[targetKey] = {});\n      targetContainer[metadataKey] = metadataValue;\n    };\n  }\n\n  if (typeof Reflect.metadata !== 'function') {\n    Reflect.metadata = function (metadataKey, metadataValue) {\n      return function (target, targetKey) {\n        Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);\n      };\n    };\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUS81cC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLXBvbHlmaWxscy9kaXN0L25hdGl2ZS1tb2R1bGVzL2F1cmVsaWEtcG9seWZpbGxzLmpzPzQzZmUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5pbXBvcnQgeyBQTEFURk9STSB9IGZyb20gJ2F1cmVsaWEtcGFsJztcblxuaWYgKHR5cGVvZiBGRUFUVVJFX05PX0VTMjAxNSA9PT0gJ3VuZGVmaW5lZCcpIHtcblxuICAoZnVuY3Rpb24gKE9iamVjdCwgR09QUykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmIChHT1BTIGluIE9iamVjdCkgcmV0dXJuO1xuXG4gICAgdmFyIHNldERlc2NyaXB0b3IsXG4gICAgICAgIEcgPSBQTEFURk9STS5nbG9iYWwsXG4gICAgICAgIGlkID0gMCxcbiAgICAgICAgcmFuZG9tID0gJycgKyBNYXRoLnJhbmRvbSgpLFxuICAgICAgICBwcmVmaXggPSAnX19cXHgwMXN5bWJvbDonLFxuICAgICAgICBwcmVmaXhMZW5ndGggPSBwcmVmaXgubGVuZ3RoLFxuICAgICAgICBpbnRlcm5hbFN5bWJvbCA9ICdfX1xceDAxc3ltYm9sQEAnICsgcmFuZG9tLFxuICAgICAgICBEUCA9ICdkZWZpbmVQcm9wZXJ0eScsXG4gICAgICAgIERQaWVzID0gJ2RlZmluZVByb3BlcnRpZXMnLFxuICAgICAgICBHT1BOID0gJ2dldE93blByb3BlcnR5TmFtZXMnLFxuICAgICAgICBHT1BEID0gJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsXG4gICAgICAgIFBJRSA9ICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICAgICAgIGdPUE4gPSBPYmplY3RbR09QTl0sXG4gICAgICAgIGdPUEQgPSBPYmplY3RbR09QRF0sXG4gICAgICAgIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUsXG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyxcbiAgICAgICAgZGVmaW5lUHJvcGVydHkgPSBPYmplY3RbRFBdLFxuICAgICAgICAkZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdFtEUGllc10sXG4gICAgICAgIGRlc2NyaXB0b3IgPSBnT1BEKE9iamVjdCwgR09QTiksXG4gICAgICAgIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgaE9QID0gT2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHksXG4gICAgICAgIHBJRSA9IE9iamVjdFByb3RvW1BJRV0sXG4gICAgICAgIHRvU3RyaW5nID0gT2JqZWN0UHJvdG8udG9TdHJpbmcsXG4gICAgICAgIGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiB8fCBmdW5jdGlvbiAodikge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoOyBpLS0gJiYgdGhpc1tpXSAhPT0gdjspIHt9XG4gICAgICByZXR1cm4gaTtcbiAgICB9LFxuICAgICAgICBhZGRJbnRlcm5hbElmTmVlZGVkID0gZnVuY3Rpb24gYWRkSW50ZXJuYWxJZk5lZWRlZChvLCB1aWQsIGVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaE9QLmNhbGwobywgaW50ZXJuYWxTeW1ib2wpKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KG8sIGludGVybmFsU3ltYm9sLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgb1tpbnRlcm5hbFN5bWJvbF1bJ0BAJyArIHVpZF0gPSBlbnVtZXJhYmxlO1xuICAgIH0sXG4gICAgICAgIGNyZWF0ZVdpdGhTeW1ib2xzID0gZnVuY3Rpb24gY3JlYXRlV2l0aFN5bWJvbHMocHJvdG8sIGRlc2NyaXB0b3JzKSB7XG4gICAgICB2YXIgc2VsZiA9IGNyZWF0ZShwcm90byk7XG4gICAgICBpZiAoZGVzY3JpcHRvcnMgIT09IG51bGwgJiYgKHR5cGVvZiBkZXNjcmlwdG9ycyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZGVzY3JpcHRvcnMpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZ09QTihkZXNjcmlwdG9ycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZGVzY3JpcHRvcnMsIGtleSkpIHtcbiAgICAgICAgICAgICRkZWZpbmVQcm9wZXJ0eShzZWxmLCBrZXksIGRlc2NyaXB0b3JzW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuICAgICAgICBjb3B5QXNOb25FbnVtZXJhYmxlID0gZnVuY3Rpb24gY29weUFzTm9uRW51bWVyYWJsZShkZXNjcmlwdG9yKSB7XG4gICAgICB2YXIgbmV3RGVzY3JpcHRvciA9IGNyZWF0ZShkZXNjcmlwdG9yKTtcbiAgICAgIG5ld0Rlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIG5ld0Rlc2NyaXB0b3I7XG4gICAgfSxcbiAgICAgICAgZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge30sXG4gICAgICAgIG9ubHlOb25TeW1ib2xzID0gZnVuY3Rpb24gb25seU5vblN5bWJvbHMobmFtZSkge1xuICAgICAgcmV0dXJuIG5hbWUgIT0gaW50ZXJuYWxTeW1ib2wgJiYgIWhPUC5jYWxsKHNvdXJjZSwgbmFtZSk7XG4gICAgfSxcbiAgICAgICAgb25seVN5bWJvbHMgPSBmdW5jdGlvbiBvbmx5U3ltYm9scyhuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZSAhPSBpbnRlcm5hbFN5bWJvbCAmJiBoT1AuY2FsbChzb3VyY2UsIG5hbWUpO1xuICAgIH0sXG4gICAgICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gICAgICB2YXIgdWlkID0gJycgKyBrZXk7XG4gICAgICByZXR1cm4gb25seVN5bWJvbHModWlkKSA/IGhPUC5jYWxsKHRoaXMsIHVpZCkgJiYgdGhpc1tpbnRlcm5hbFN5bWJvbF0gJiYgdGhpc1tpbnRlcm5hbFN5bWJvbF1bJ0BAJyArIHVpZF0gOiBwSUUuY2FsbCh0aGlzLCBrZXkpO1xuICAgIH0sXG4gICAgICAgIHNldEFuZEdldFN5bWJvbCA9IGZ1bmN0aW9uIHNldEFuZEdldFN5bWJvbCh1aWQpIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGdldCxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICBzZXREZXNjcmlwdG9yKHRoaXMsIHVpZCwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFkZEludGVybmFsSWZOZWVkZWQodGhpcywgdWlkLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGRlZmluZVByb3BlcnR5KE9iamVjdFByb3RvLCB1aWQsIGRlc2NyaXB0b3IpO1xuICAgICAgcmV0dXJuIHNvdXJjZVt1aWRdID0gZGVmaW5lUHJvcGVydHkoT2JqZWN0KHVpZCksICdjb25zdHJ1Y3RvcicsIHNvdXJjZUNvbnN0cnVjdG9yKTtcbiAgICB9LFxuICAgICAgICBfU3ltYm9sID0gZnVuY3Rpb24gX1N5bWJvbDIoZGVzY3JpcHRpb24pIHtcbiAgICAgIGlmICh0aGlzICYmIHRoaXMgIT09IEcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0QW5kR2V0U3ltYm9sKHByZWZpeC5jb25jYXQoZGVzY3JpcHRpb24gfHwgJycsIHJhbmRvbSwgKytpZCkpO1xuICAgIH0sXG4gICAgICAgIHNvdXJjZSA9IGNyZWF0ZShudWxsKSxcbiAgICAgICAgc291cmNlQ29uc3RydWN0b3IgPSB7IHZhbHVlOiBfU3ltYm9sIH0sXG4gICAgICAgIHNvdXJjZU1hcCA9IGZ1bmN0aW9uIHNvdXJjZU1hcCh1aWQpIHtcbiAgICAgIHJldHVybiBzb3VyY2VbdWlkXTtcbiAgICB9LFxuICAgICAgICAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wKG8sIGtleSwgZGVzY3JpcHRvcikge1xuICAgICAgdmFyIHVpZCA9ICcnICsga2V5O1xuICAgICAgaWYgKG9ubHlTeW1ib2xzKHVpZCkpIHtcbiAgICAgICAgc2V0RGVzY3JpcHRvcihvLCB1aWQsIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA/IGNvcHlBc05vbkVudW1lcmFibGUoZGVzY3JpcHRvcikgOiBkZXNjcmlwdG9yKTtcbiAgICAgICAgYWRkSW50ZXJuYWxJZk5lZWRlZChvLCB1aWQsICEhZGVzY3JpcHRvci5lbnVtZXJhYmxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KG8sIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9LFxuICAgICAgICAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKG8pIHtcbiAgICAgIHZhciBjb2YgPSB0b1N0cmluZy5jYWxsKG8pO1xuICAgICAgbyA9IGNvZiA9PT0gJ1tvYmplY3QgU3RyaW5nXScgPyBvLnNwbGl0KCcnKSA6IE9iamVjdChvKTtcbiAgICAgIHJldHVybiBnT1BOKG8pLmZpbHRlcihvbmx5U3ltYm9scykubWFwKHNvdXJjZU1hcCk7XG4gICAgfTtcblxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSAkZGVmaW5lUHJvcGVydHk7XG4gICAgZGVmaW5lUHJvcGVydHkoT2JqZWN0LCBEUCwgZGVzY3JpcHRvcik7XG5cbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gJGdldE93blByb3BlcnR5U3ltYm9scztcbiAgICBkZWZpbmVQcm9wZXJ0eShPYmplY3QsIEdPUFMsIGRlc2NyaXB0b3IpO1xuXG4gICAgdmFyIGNhY2hlZFdpbmRvd05hbWVzID0gKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdpbmRvdykpID09PSAnb2JqZWN0JyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcbiAgICB2YXIgb3JpZ2luYWxPYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMobykge1xuICAgICAgaWYgKHRvU3RyaW5nLmNhbGwobykgPT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsT2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcyhvKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoW10sIGNhY2hlZFdpbmRvd05hbWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGdPUE4obykuZmlsdGVyKG9ubHlOb25TeW1ib2xzKTtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnR5KE9iamVjdCwgR09QTiwgZGVzY3JpcHRvcik7XG5cbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhvLCBkZXNjcmlwdG9ycykge1xuICAgICAgdmFyIHN5bWJvbHMgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzKGRlc2NyaXB0b3JzKTtcbiAgICAgIGlmIChzeW1ib2xzLmxlbmd0aCkge1xuICAgICAgICBrZXlzKGRlc2NyaXB0b3JzKS5jb25jYXQoc3ltYm9scykuZm9yRWFjaChmdW5jdGlvbiAodWlkKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZGVzY3JpcHRvcnMsIHVpZCkpIHtcbiAgICAgICAgICAgICRkZWZpbmVQcm9wZXJ0eShvLCB1aWQsIGRlc2NyaXB0b3JzW3VpZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkZGVmaW5lUHJvcGVydGllcyhvLCBkZXNjcmlwdG9ycyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnR5KE9iamVjdCwgRFBpZXMsIGRlc2NyaXB0b3IpO1xuXG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICAgIGRlZmluZVByb3BlcnR5KE9iamVjdFByb3RvLCBQSUUsIGRlc2NyaXB0b3IpO1xuXG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IF9TeW1ib2w7XG4gICAgZGVmaW5lUHJvcGVydHkoRywgJ1N5bWJvbCcsIGRlc2NyaXB0b3IpO1xuXG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciB1aWQgPSBwcmVmaXguY29uY2F0KHByZWZpeCwga2V5LCByYW5kb20pO1xuICAgICAgcmV0dXJuIHVpZCBpbiBPYmplY3RQcm90byA/IHNvdXJjZVt1aWRdIDogc2V0QW5kR2V0U3ltYm9sKHVpZCk7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0eShfU3ltYm9sLCAnZm9yJywgZGVzY3JpcHRvcik7XG5cbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgcmV0dXJuIGhPUC5jYWxsKHNvdXJjZSwgc3ltYm9sKSA/IHN5bWJvbC5zbGljZShwcmVmaXhMZW5ndGggKiAyLCAtcmFuZG9tLmxlbmd0aCkgOiB2b2lkIDA7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0eShfU3ltYm9sLCAna2V5Rm9yJywgZGVzY3JpcHRvcik7XG5cbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG8sIGtleSkge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnT1BEKG8sIGtleSk7XG4gICAgICBpZiAoZGVzY3JpcHRvciAmJiBvbmx5U3ltYm9scyhrZXkpKSB7XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwobywga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydHkoT2JqZWN0LCBHT1BELCBkZXNjcmlwdG9yKTtcblxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAocHJvdG8sIGRlc2NyaXB0b3JzKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGNyZWF0ZShwcm90bykgOiBjcmVhdGVXaXRoU3ltYm9scyhwcm90bywgZGVzY3JpcHRvcnMpO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydHkoT2JqZWN0LCAnY3JlYXRlJywgZGVzY3JpcHRvcik7XG5cbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0ciA9IHRvU3RyaW5nLmNhbGwodGhpcyk7XG4gICAgICByZXR1cm4gc3RyID09PSAnW29iamVjdCBTdHJpbmddJyAmJiBvbmx5U3ltYm9scyh0aGlzKSA/ICdbb2JqZWN0IFN5bWJvbF0nIDogc3RyO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG8sICd0b1N0cmluZycsIGRlc2NyaXB0b3IpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldERlc2NyaXB0b3IgPSBjcmVhdGUoZGVmaW5lUHJvcGVydHkoe30sIHByZWZpeCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkodGhpcywgcHJlZml4LCB7IHZhbHVlOiBmYWxzZSB9KVtwcmVmaXhdO1xuICAgICAgICB9XG4gICAgICB9KSlbcHJlZml4XSB8fCBkZWZpbmVQcm9wZXJ0eTtcbiAgICB9IGNhdGNoIChvX08pIHtcbiAgICAgIHNldERlc2NyaXB0b3IgPSBmdW5jdGlvbiBzZXREZXNjcmlwdG9yKG8sIGtleSwgZGVzY3JpcHRvcikge1xuICAgICAgICB2YXIgcHJvdG9EZXNjcmlwdG9yID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgICAgICAgZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gICAgICAgIGRlZmluZVByb3BlcnR5KG8sIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzY3JpcHRvcik7XG4gICAgICB9O1xuICAgIH1cbiAgfSkoT2JqZWN0LCAnZ2V0T3duUHJvcGVydHlTeW1ib2xzJyk7XG5cbiAgKGZ1bmN0aW9uIChPLCBTKSB7XG4gICAgdmFyIGRQID0gTy5kZWZpbmVQcm9wZXJ0eSxcbiAgICAgICAgT2JqZWN0UHJvdG8gPSBPLnByb3RvdHlwZSxcbiAgICAgICAgdG9TdHJpbmcgPSBPYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgdG9TdHJpbmdUYWcgPSAndG9TdHJpbmdUYWcnLFxuICAgICAgICBkZXNjcmlwdG9yO1xuICAgIFsnaXRlcmF0b3InLCAnbWF0Y2gnLCAncmVwbGFjZScsICdzZWFyY2gnLCAnc3BsaXQnLCAnaGFzSW5zdGFuY2UnLCAnaXNDb25jYXRTcHJlYWRhYmxlJywgJ3Vuc2NvcGFibGVzJywgJ3NwZWNpZXMnLCAndG9QcmltaXRpdmUnLCB0b1N0cmluZ1RhZ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKCEobmFtZSBpbiBTeW1ib2wpKSB7XG4gICAgICAgIGRQKFN5bWJvbCwgbmFtZSwgeyB2YWx1ZTogU3ltYm9sKG5hbWUpIH0pO1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICBjYXNlIHRvU3RyaW5nVGFnOlxuICAgICAgICAgICAgZGVzY3JpcHRvciA9IE8uZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdFByb3RvLCAndG9TdHJpbmcnKTtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBzdHIgPSB0b1N0cmluZy5jYWxsKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgdHN0ID0gdHlwZW9mIHRoaXMgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMgPT09IG51bGwgPyB1bmRlZmluZWQgOiB0aGlzW1N5bWJvbC50b1N0cmluZ1RhZ107XG4gICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdHN0ID09PSAndW5kZWZpbmVkJyA/IHN0ciA6ICdbb2JqZWN0ICcgKyB0c3QgKyAnXSc7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZFAoT2JqZWN0UHJvdG8sICd0b1N0cmluZycsIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSkoT2JqZWN0LCBTeW1ib2wpO1xuXG4gIChmdW5jdGlvbiAoU2ksIEFQLCBTUCkge1xuXG4gICAgZnVuY3Rpb24gcmV0dXJuVGhpcygpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICghQVBbU2ldKSBBUFtTaV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgaXRlcmF0b3IgPSB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgdmFyIGRvbmUgPSBzZWxmLmxlbmd0aCA8PSBpO1xuICAgICAgICAgIHJldHVybiBkb25lID8geyBkb25lOiBkb25lIH0gOiB7IGRvbmU6IGRvbmUsIHZhbHVlOiBzZWxmW2krK10gfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGl0ZXJhdG9yW1NpXSA9IHJldHVyblRoaXM7XG4gICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfTtcblxuICAgIGlmICghU1BbU2ldKSBTUFtTaV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50LFxuICAgICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoLFxuICAgICAgICAgIGl0ZXJhdG9yID0ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHZhciBkb25lID0gbGVuZ3RoIDw9IGksXG4gICAgICAgICAgICAgIGMgPSBkb25lID8gJycgOiBmcm9tQ29kZVBvaW50KHNlbGYuY29kZVBvaW50QXQoaSkpO1xuICAgICAgICAgIGkgKz0gYy5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGRvbmUgPyB7IGRvbmU6IGRvbmUgfSA6IHsgZG9uZTogZG9uZSwgdmFsdWU6IGMgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGl0ZXJhdG9yW1NpXSA9IHJldHVyblRoaXM7XG4gICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfTtcbiAgfSkoU3ltYm9sLml0ZXJhdG9yLCBBcnJheS5wcm90b3R5cGUsIFN0cmluZy5wcm90b3R5cGUpO1xufVxuXG5pZiAodHlwZW9mIEZFQVRVUkVfTk9fRVMyMDE1ID09PSAndW5kZWZpbmVkJykge1xuXG4gIE51bWJlci5pc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xuICB9O1xuXG4gIE51bWJlci5pc0Zpbml0ZSA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbHVlKTtcbiAgfTtcbn1cblxuaWYgKCFTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoIHx8IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gIVwiYWJcIi5lbmRzV2l0aChcImFcIiwgMSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSgpKSB7XG4gIFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGggPSBmdW5jdGlvbiAoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICAgIHZhciBzdWJqZWN0U3RyaW5nID0gdGhpcy50b1N0cmluZygpO1xuICAgIGlmICh0eXBlb2YgcG9zaXRpb24gIT09ICdudW1iZXInIHx8ICFpc0Zpbml0ZShwb3NpdGlvbikgfHwgTWF0aC5mbG9vcihwb3NpdGlvbikgIT09IHBvc2l0aW9uIHx8IHBvc2l0aW9uID4gc3ViamVjdFN0cmluZy5sZW5ndGgpIHtcbiAgICAgIHBvc2l0aW9uID0gc3ViamVjdFN0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIHBvc2l0aW9uIC09IHNlYXJjaFN0cmluZy5sZW5ndGg7XG4gICAgdmFyIGxhc3RJbmRleCA9IHN1YmplY3RTdHJpbmcuaW5kZXhPZihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gbGFzdEluZGV4ICE9PSAtMSAmJiBsYXN0SW5kZXggPT09IHBvc2l0aW9uO1xuICB9O1xufVxuXG5pZiAoIVN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCB8fCBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICFcImFiXCIuc3RhcnRzV2l0aChcImJcIiwgMSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSgpKSB7XG4gIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCA9IGZ1bmN0aW9uIChzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgcG9zaXRpb24gPSBwb3NpdGlvbiB8fCAwO1xuICAgIHJldHVybiB0aGlzLnN1YnN0cihwb3NpdGlvbiwgc2VhcmNoU3RyaW5nLmxlbmd0aCkgPT09IHNlYXJjaFN0cmluZztcbiAgfTtcbn1cblxuaWYgKHR5cGVvZiBGRUFUVVJFX05PX0VTMjAxNSA9PT0gJ3VuZGVmaW5lZCcpIHtcblxuICBpZiAoIUFycmF5LmZyb20pIHtcbiAgICBBcnJheS5mcm9tID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRvSW50ZWdlciA9IGZ1bmN0aW9uIHRvSW50ZWdlcihpdCkge1xuICAgICAgICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBNYXRoLmZsb29yIDogTWF0aC5jZWlsKShpdCk7XG4gICAgICB9O1xuICAgICAgdmFyIHRvTGVuZ3RoID0gZnVuY3Rpb24gdG9MZW5ndGgoaXQpIHtcbiAgICAgICAgcmV0dXJuIGl0ID4gMCA/IE1hdGgubWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDtcbiAgICAgIH07XG4gICAgICB2YXIgaXRlckNhbGwgPSBmdW5jdGlvbiBpdGVyQ2FsbChpdGVyLCBmbiwgdmFsLCBpbmRleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBmbih2YWwsIGluZGV4KTtcbiAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgaXRlci5yZXR1cm4gPT0gJ2Z1bmN0aW9uJykgaXRlci5yZXR1cm4oKTtcbiAgICAgICAgICB0aHJvdyBFO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gZnJvbShhcnJheUxpa2UpIHtcbiAgICAgICAgdmFyIE8gPSBPYmplY3QoYXJyYXlMaWtlKSxcbiAgICAgICAgICAgIEMgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5LFxuICAgICAgICAgICAgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICBpdGVyRm4gPSBPW1N5bWJvbC5pdGVyYXRvcl0sXG4gICAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICBzdGVwLFxuICAgICAgICAgICAgaXRlcmF0b3I7XG4gICAgICAgIGlmIChtYXBwaW5nKSBtYXBmbiA9IG1hcGZuLmJpbmQoYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheShhcnJheUxpa2UpKSB7XG4gICAgICAgICAgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQygpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBtYXBwaW5nID8gaXRlckNhbGwoaXRlcmF0b3IsIG1hcGZuLCBzdGVwLnZhbHVlLCBpbmRleCkgOiBzdGVwLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSgpO1xuICB9XG5cbiAgaWYgKCFBcnJheS5wcm90b3R5cGUuZmluZCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheS5wcm90b3R5cGUsICdmaW5kJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShwcmVkaWNhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZmluZCBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ByZWRpY2F0ZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoID4+PiAwO1xuICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YWx1ZSA9IGxpc3RbaV07XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpLCBsaXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSwgJ2ZpbmRJbmRleCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUocHJlZGljYXRlKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ByZWRpY2F0ZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoID4+PiAwO1xuICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YWx1ZSA9IGxpc3RbaV07XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpLCBsaXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5pZiAodHlwZW9mIEZFQVRVUkVfTk9fRVMyMDE2ID09PSAndW5kZWZpbmVkJyAmJiAhQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheS5wcm90b3R5cGUsICdpbmNsdWRlcycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgIHZhciBPID0gT2JqZWN0KHRoaXMpO1xuICAgICAgdmFyIGxlbiA9IHBhcnNlSW50KE8ubGVuZ3RoKSB8fCAwO1xuICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgbiA9IHBhcnNlSW50KGFyZ3VtZW50c1sxXSkgfHwgMDtcbiAgICAgIHZhciBrO1xuICAgICAgaWYgKG4gPj0gMCkge1xuICAgICAgICBrID0gbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGsgPSBsZW4gKyBuO1xuICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICBrID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGN1cnJlbnRFbGVtZW50O1xuICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgY3VycmVudEVsZW1lbnQgPSBPW2tdO1xuICAgICAgICBpZiAoc2VhcmNoRWxlbWVudCA9PT0gY3VycmVudEVsZW1lbnQgfHwgc2VhcmNoRWxlbWVudCAhPT0gc2VhcmNoRWxlbWVudCAmJiBjdXJyZW50RWxlbWVudCAhPT0gY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBrKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcbn1cblxuaWYgKHR5cGVvZiBGRUFUVVJFX05PX0VTMjAxNSA9PT0gJ3VuZGVmaW5lZCcpIHtcblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZWVkc0ZpeCA9IGZhbHNlO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBzID0gT2JqZWN0LmtleXMoJ2EnKTtcbiAgICAgIG5lZWRzRml4ID0gcy5sZW5ndGggIT09IDEgfHwgc1swXSAhPT0gJzAnO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG5lZWRzRml4ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobmVlZHNGaXgpIHtcbiAgICAgIE9iamVjdC5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgICAgICAgaGFzRG9udEVudW1CdWcgPSAheyB0b1N0cmluZzogbnVsbCB9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpLFxuICAgICAgICAgICAgZG9udEVudW1zID0gWyd0b1N0cmluZycsICd0b0xvY2FsZVN0cmluZycsICd2YWx1ZU9mJywgJ2hhc093blByb3BlcnR5JywgJ2lzUHJvdG90eXBlT2YnLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAnY29uc3RydWN0b3InXSxcbiAgICAgICAgICAgIGRvbnRFbnVtc0xlbmd0aCA9IGRvbnRFbnVtcy5sZW5ndGg7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICBpZiAob2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9iaiA9IE9iamVjdChvYmopO1xuXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFzRG9udEVudW1CdWcpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkb250RW51bXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGRvbnRFbnVtc1tpXSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChkb250RW51bXNbaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH0oKTtcbiAgICB9XG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uIChPKSB7XG4gICAgaWYgKCdhc3NpZ24nIGluIE8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBPLmRlZmluZVByb3BlcnR5KE8sICdhc3NpZ24nLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnT1BTID0gTy5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgICAgICAgICBwSUUgPSBPLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgICAgICAgICAgZmlsdGVyT1MgPSBnT1BTID8gZnVuY3Rpb24gKHNlbGYpIHtcbiAgICAgICAgICByZXR1cm4gZ09QUyhzZWxmKS5maWx0ZXIocElFLCBzZWxmKTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhc3NpZ24od2hlcmUpIHtcbiAgICAgICAgICBpZiAoZ09QUyAmJiAhKHdoZXJlIGluc3RhbmNlb2YgTykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigncHJvYmxlbWF0aWMgU3ltYm9scycsIHdoZXJlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBzZXQoa2V5T3JTeW1ib2wpIHtcbiAgICAgICAgICAgIHdoZXJlW2tleU9yU3ltYm9sXSA9IGFyZ1trZXlPclN5bWJvbF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDEsIGlpID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgICAgIGlmIChhcmcgPT09IG51bGwgfHwgYXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE8ua2V5cyhhcmcpLmNvbmNhdChmaWx0ZXJPUyhhcmcpKS5mb3JFYWNoKHNldCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHdoZXJlO1xuICAgICAgICB9O1xuICAgICAgfSgpXG4gICAgfSk7XG4gIH0pKE9iamVjdCk7XG5cbiAgaWYgKCFPYmplY3QuaXMpIHtcbiAgICBPYmplY3QuaXMgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbmlmICh0eXBlb2YgRkVBVFVSRV9OT19FUzIwMTUgPT09ICd1bmRlZmluZWQnKSB7XG5cbiAgKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICB2YXIgaTtcblxuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcbiAgICAgICAgaXMgPSBmdW5jdGlvbiBpcyhhLCBiKSB7XG4gICAgICByZXR1cm4gYSA9PT0gYiB8fCBhICE9PSBhICYmIGIgIT09IGI7XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgV2Vha01hcCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgZ2xvYmFsLldlYWtNYXAgPSBjcmVhdGVDb2xsZWN0aW9uKHtcbiAgICAgICAgJ2RlbGV0ZSc6IHNoYXJlZERlbGV0ZSxcblxuICAgICAgICBjbGVhcjogc2hhcmVkQ2xlYXIsXG5cbiAgICAgICAgZ2V0OiBzaGFyZWRHZXQsXG5cbiAgICAgICAgaGFzOiBtYXBIYXMsXG5cbiAgICAgICAgc2V0OiBzaGFyZWRTZXRcbiAgICAgIH0sIHRydWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgTWFwID09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBuZXcgTWFwKCkudmFsdWVzICE9PSAnZnVuY3Rpb24nIHx8ICFuZXcgTWFwKCkudmFsdWVzKCkubmV4dCkge1xuICAgICAgdmFyIF9jcmVhdGVDb2xsZWN0aW9uO1xuXG4gICAgICBnbG9iYWwuTWFwID0gY3JlYXRlQ29sbGVjdGlvbigoX2NyZWF0ZUNvbGxlY3Rpb24gPSB7XG4gICAgICAgICdkZWxldGUnOiBzaGFyZWREZWxldGUsXG5cbiAgICAgICAgaGFzOiBtYXBIYXMsXG5cbiAgICAgICAgZ2V0OiBzaGFyZWRHZXQsXG5cbiAgICAgICAgc2V0OiBzaGFyZWRTZXQsXG5cbiAgICAgICAga2V5czogc2hhcmVkS2V5cyxcblxuICAgICAgICB2YWx1ZXM6IHNoYXJlZFZhbHVlcyxcblxuICAgICAgICBlbnRyaWVzOiBtYXBFbnRyaWVzLFxuXG4gICAgICAgIGZvckVhY2g6IHNoYXJlZEZvckVhY2gsXG5cbiAgICAgICAgY2xlYXI6IHNoYXJlZENsZWFyXG4gICAgICB9LCBfY3JlYXRlQ29sbGVjdGlvbltTeW1ib2wuaXRlcmF0b3JdID0gbWFwRW50cmllcywgX2NyZWF0ZUNvbGxlY3Rpb24pKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIFNldCA9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgbmV3IFNldCgpLnZhbHVlcyAhPT0gJ2Z1bmN0aW9uJyB8fCAhbmV3IFNldCgpLnZhbHVlcygpLm5leHQpIHtcbiAgICAgIHZhciBfY3JlYXRlQ29sbGVjdGlvbjI7XG5cbiAgICAgIGdsb2JhbC5TZXQgPSBjcmVhdGVDb2xsZWN0aW9uKChfY3JlYXRlQ29sbGVjdGlvbjIgPSB7XG4gICAgICAgIGhhczogc2V0SGFzLFxuXG4gICAgICAgIGFkZDogc2hhcmVkQWRkLFxuXG4gICAgICAgICdkZWxldGUnOiBzaGFyZWREZWxldGUsXG5cbiAgICAgICAgY2xlYXI6IHNoYXJlZENsZWFyLFxuXG4gICAgICAgIGtleXM6IHNoYXJlZFZhbHVlcyxcbiAgICAgICAgdmFsdWVzOiBzaGFyZWRWYWx1ZXMsXG5cbiAgICAgICAgZW50cmllczogc2V0RW50cmllcyxcblxuICAgICAgICBmb3JFYWNoOiBzaGFyZWRGb3JFYWNoXG4gICAgICB9LCBfY3JlYXRlQ29sbGVjdGlvbjJbU3ltYm9sLml0ZXJhdG9yXSA9IHNoYXJlZFZhbHVlcywgX2NyZWF0ZUNvbGxlY3Rpb24yKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBXZWFrU2V0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwuV2Vha1NldCA9IGNyZWF0ZUNvbGxlY3Rpb24oe1xuICAgICAgICAnZGVsZXRlJzogc2hhcmVkRGVsZXRlLFxuXG4gICAgICAgIGFkZDogc2hhcmVkQWRkLFxuXG4gICAgICAgIGNsZWFyOiBzaGFyZWRDbGVhcixcblxuICAgICAgICBoYXM6IHNldEhhc1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29sbGVjdGlvbihwcm90bywgb2JqZWN0T25seSkge1xuICAgICAgZnVuY3Rpb24gQ29sbGVjdGlvbihhKSB7XG4gICAgICAgIGlmICghdGhpcyB8fCB0aGlzLmNvbnN0cnVjdG9yICE9PSBDb2xsZWN0aW9uKSByZXR1cm4gbmV3IENvbGxlY3Rpb24oYSk7XG4gICAgICAgIHRoaXMuX2tleXMgPSBbXTtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0gW107XG4gICAgICAgIHRoaXMuX2l0cCA9IFtdO1xuICAgICAgICB0aGlzLm9iamVjdE9ubHkgPSBvYmplY3RPbmx5O1xuXG4gICAgICAgIGlmIChhKSBpbml0LmNhbGwodGhpcywgYSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghb2JqZWN0T25seSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShwcm90bywgJ3NpemUnLCB7XG4gICAgICAgICAgZ2V0OiBzaGFyZWRTaXplXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBwcm90by5jb25zdHJ1Y3RvciA9IENvbGxlY3Rpb247XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZSA9IHByb3RvO1xuXG4gICAgICByZXR1cm4gQ29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0KGEpIHtcbiAgICAgIHZhciBpO1xuXG4gICAgICBpZiAodGhpcy5hZGQpIGEuZm9yRWFjaCh0aGlzLmFkZCwgdGhpcyk7ZWxzZSBhLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICB0aGlzLnNldChhWzBdLCBhWzFdKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hhcmVkRGVsZXRlKGtleSkge1xuICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgdGhpcy5fa2V5cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHRoaXMuX3ZhbHVlcy5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgdGhpcy5faXRwLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICBpZiAoaSA8IHBbMF0pIHBbMF0tLTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAtMSA8IGk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNoYXJlZEdldChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhrZXkpID8gdGhpcy5fdmFsdWVzW2ldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhcyhsaXN0LCBrZXkpIHtcbiAgICAgIGlmICh0aGlzLm9iamVjdE9ubHkgJiYga2V5ICE9PSBPYmplY3Qoa2V5KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdmFsdWUgdXNlZCBhcyB3ZWFrIGNvbGxlY3Rpb24ga2V5XCIpO1xuXG4gICAgICBpZiAoa2V5ICE9IGtleSB8fCBrZXkgPT09IDApIGZvciAoaSA9IGxpc3QubGVuZ3RoOyBpLS0gJiYgIWlzKGxpc3RbaV0sIGtleSk7KSB7fSBlbHNlIGkgPSBsaXN0LmluZGV4T2Yoa2V5KTtcbiAgICAgIHJldHVybiAtMSA8IGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0SGFzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaGFzLmNhbGwodGhpcywgdGhpcy5fdmFsdWVzLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwSGFzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaGFzLmNhbGwodGhpcywgdGhpcy5fa2V5cywgdmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNoYXJlZFNldChrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLmhhcyhrZXkpID8gdGhpcy5fdmFsdWVzW2ldID0gdmFsdWUgOiB0aGlzLl92YWx1ZXNbdGhpcy5fa2V5cy5wdXNoKGtleSkgLSAxXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hhcmVkQWRkKHZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzKHZhbHVlKSkgdGhpcy5fdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hhcmVkQ2xlYXIoKSB7XG4gICAgICAodGhpcy5fa2V5cyB8fCAwKS5sZW5ndGggPSB0aGlzLl92YWx1ZXMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaGFyZWRLZXlzKCkge1xuICAgICAgcmV0dXJuIHNoYXJlZEl0ZXJhdG9yKHRoaXMuX2l0cCwgdGhpcy5fa2V5cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hhcmVkVmFsdWVzKCkge1xuICAgICAgcmV0dXJuIHNoYXJlZEl0ZXJhdG9yKHRoaXMuX2l0cCwgdGhpcy5fdmFsdWVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXBFbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIHNoYXJlZEl0ZXJhdG9yKHRoaXMuX2l0cCwgdGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRFbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIHNoYXJlZEl0ZXJhdG9yKHRoaXMuX2l0cCwgdGhpcy5fdmFsdWVzLCB0aGlzLl92YWx1ZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNoYXJlZEl0ZXJhdG9yKGl0cCwgYXJyYXksIGFycmF5Mikge1xuICAgICAgdmFyIF9yZWY7XG5cbiAgICAgIHZhciBwID0gWzBdLFxuICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgIGl0cC5wdXNoKHApO1xuICAgICAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sIF9yZWYubmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciB2LFxuICAgICAgICAgICAgayA9IHBbMF07XG4gICAgICAgIGlmICghZG9uZSAmJiBrIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgdiA9IGFycmF5MiA/IFthcnJheVtrXSwgYXJyYXkyW2tdXSA6IGFycmF5W2tdO1xuICAgICAgICAgIHBbMF0rKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICBpdHAuc3BsaWNlKGl0cC5pbmRleE9mKHApLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiBkb25lLCB2YWx1ZTogdiB9O1xuICAgICAgfSwgX3JlZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaGFyZWRTaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hhcmVkRm9yRWFjaChjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgdmFyIGl0ID0gdGhpcy5lbnRyaWVzKCk7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIHZhciByID0gaXQubmV4dCgpO1xuICAgICAgICBpZiAoci5kb25lKSBicmVhaztcbiAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCByLnZhbHVlWzFdLCByLnZhbHVlWzBdLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pKFBMQVRGT1JNLmdsb2JhbCk7XG59XG5cbmlmICh0eXBlb2YgRkVBVFVSRV9OT19FUzIwMTUgPT09ICd1bmRlZmluZWQnKSB7XG5cbiAgdmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZDtcblxuICBpZiAodHlwZW9mIFBMQVRGT1JNLmdsb2JhbC5SZWZsZWN0ID09PSAndW5kZWZpbmVkJykge1xuICAgIFBMQVRGT1JNLmdsb2JhbC5SZWZsZWN0ID0ge307XG4gIH1cblxuICBpZiAodHlwZW9mIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkgIT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKHRhcmdldCwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IpIHtcbiAgICAgIGlmICgodHlwZW9mIHRhcmdldCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodGFyZ2V0KSkgPT09ICdvYmplY3QnID8gdGFyZ2V0ID09PSBudWxsIDogdHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWZsZWN0LmRlZmluZVByb3BlcnR5IGNhbGxlZCBvbiBub24tb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgUmVmbGVjdC5jb25zdHJ1Y3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0LmNvbnN0cnVjdCA9IGZ1bmN0aW9uIChUYXJnZXQsIGFyZ3MpIHtcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldCgpO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgcmV0dXJuIG5ldyAoYmluZC5hcHBseShUYXJnZXQsIGEpKSgpO1xuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIFJlZmxlY3Qub3duS2V5cyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3Qub3duS2V5cyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobykuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobykpO1xuICAgIH07XG4gIH1cbn1cblxuaWYgKHR5cGVvZiBGRUFUVVJFX05PX0VTTkVYVCA9PT0gJ3VuZGVmaW5lZCcpIHtcblxuICB2YXIgZW1wdHlNZXRhZGF0YSA9IE9iamVjdC5mcmVlemUoe30pO1xuICB2YXIgbWV0YWRhdGFDb250YWluZXJLZXkgPSAnX19tZXRhZGF0YV9fJztcblxuICBpZiAodHlwZW9mIFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEgIT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0LmdldE93bk1ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHRhcmdldEtleSkge1xuICAgICAgaWYgKHRhcmdldC5oYXNPd25Qcm9wZXJ0eShtZXRhZGF0YUNvbnRhaW5lcktleSkpIHtcbiAgICAgICAgcmV0dXJuICh0YXJnZXRbbWV0YWRhdGFDb250YWluZXJLZXldW3RhcmdldEtleV0gfHwgZW1wdHlNZXRhZGF0YSlbbWV0YWRhdGFLZXldO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEgIT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHRhcmdldEtleSkge1xuICAgICAgdmFyIG1ldGFkYXRhQ29udGFpbmVyID0gdGFyZ2V0Lmhhc093blByb3BlcnR5KG1ldGFkYXRhQ29udGFpbmVyS2V5KSA/IHRhcmdldFttZXRhZGF0YUNvbnRhaW5lcktleV0gOiB0YXJnZXRbbWV0YWRhdGFDb250YWluZXJLZXldID0ge307XG4gICAgICB2YXIgdGFyZ2V0Q29udGFpbmVyID0gbWV0YWRhdGFDb250YWluZXJbdGFyZ2V0S2V5XSB8fCAobWV0YWRhdGFDb250YWluZXJbdGFyZ2V0S2V5XSA9IHt9KTtcbiAgICAgIHRhcmdldENvbnRhaW5lclttZXRhZGF0YUtleV0gPSBtZXRhZGF0YVZhbHVlO1xuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgIT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0Lm1ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0S2V5KSB7XG4gICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgdGFyZ2V0S2V5KTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///Q/5p\n");

/***/ }),

/***/ "iD3O":
/*!***********************************************************************!*\
  !*** ./node_modules/aurelia-path/dist/native-modules/aurelia-path.js ***!
  \***********************************************************************/
/*! exports provided: relativeToFile, join, buildQueryString, parseQueryString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"relativeToFile\", function() { return relativeToFile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"join\", function() { return join; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildQueryString\", function() { return buildQueryString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseQueryString\", function() { return parseQueryString; });\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction trimDots(ary) {\n  for (var i = 0; i < ary.length; ++i) {\n    var part = ary[i];\n    if (part === '.') {\n      ary.splice(i, 1);\n      i -= 1;\n    } else if (part === '..') {\n      if (i === 0 || i === 1 && ary[2] === '..' || ary[i - 1] === '..') {\n        continue;\n      } else if (i > 0) {\n        ary.splice(i - 1, 2);\n        i -= 2;\n      }\n    }\n  }\n}\n\nfunction relativeToFile(name, file) {\n  var fileParts = file && file.split('/');\n  var nameParts = name.trim().split('/');\n\n  if (nameParts[0].charAt(0) === '.' && fileParts) {\n    var normalizedBaseParts = fileParts.slice(0, fileParts.length - 1);\n    nameParts.unshift.apply(nameParts, normalizedBaseParts);\n  }\n\n  trimDots(nameParts);\n\n  return nameParts.join('/');\n}\n\nfunction join(path1, path2) {\n  if (!path1) {\n    return path2;\n  }\n\n  if (!path2) {\n    return path1;\n  }\n\n  var schemeMatch = path1.match(/^([^/]*?:)\\//);\n  var scheme = schemeMatch && schemeMatch.length > 0 ? schemeMatch[1] : '';\n  path1 = path1.substr(scheme.length);\n\n  var urlPrefix = void 0;\n  if (path1.indexOf('///') === 0 && scheme === 'file:') {\n    urlPrefix = '///';\n  } else if (path1.indexOf('//') === 0) {\n    urlPrefix = '//';\n  } else if (path1.indexOf('/') === 0) {\n    urlPrefix = '/';\n  } else {\n    urlPrefix = '';\n  }\n\n  var trailingSlash = path2.slice(-1) === '/' ? '/' : '';\n\n  var url1 = path1.split('/');\n  var url2 = path2.split('/');\n  var url3 = [];\n\n  for (var i = 0, ii = url1.length; i < ii; ++i) {\n    if (url1[i] === '..') {\n      url3.pop();\n    } else if (url1[i] === '.' || url1[i] === '') {\n      continue;\n    } else {\n      url3.push(url1[i]);\n    }\n  }\n\n  for (var _i = 0, _ii = url2.length; _i < _ii; ++_i) {\n    if (url2[_i] === '..') {\n      url3.pop();\n    } else if (url2[_i] === '.' || url2[_i] === '') {\n      continue;\n    } else {\n      url3.push(url2[_i]);\n    }\n  }\n\n  return scheme + urlPrefix + url3.join('/') + trailingSlash;\n}\n\nvar encode = encodeURIComponent;\nvar encodeKey = function encodeKey(k) {\n  return encode(k).replace('%24', '$');\n};\n\nfunction buildParam(key, value, traditional) {\n  var result = [];\n  if (value === null || value === undefined) {\n    return result;\n  }\n  if (Array.isArray(value)) {\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (traditional) {\n        result.push(encodeKey(key) + '=' + encode(value[i]));\n      } else {\n        var arrayKey = key + '[' + (_typeof(value[i]) === 'object' && value[i] !== null ? i : '') + ']';\n        result = result.concat(buildParam(arrayKey, value[i]));\n      }\n    }\n  } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && !traditional) {\n    for (var propertyName in value) {\n      result = result.concat(buildParam(key + '[' + propertyName + ']', value[propertyName]));\n    }\n  } else {\n    result.push(encodeKey(key) + '=' + encode(value));\n  }\n  return result;\n}\n\nfunction buildQueryString(params, traditional) {\n  var pairs = [];\n  var keys = Object.keys(params || {}).sort();\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    pairs = pairs.concat(buildParam(key, params[key], traditional));\n  }\n\n  if (pairs.length === 0) {\n    return '';\n  }\n\n  return pairs.join('&');\n}\n\nfunction processScalarParam(existedParam, value) {\n  if (Array.isArray(existedParam)) {\n    existedParam.push(value);\n    return existedParam;\n  }\n  if (existedParam !== undefined) {\n    return [existedParam, value];\n  }\n\n  return value;\n}\n\nfunction parseComplexParam(queryParams, keys, value) {\n  var currentParams = queryParams;\n  var keysLastIndex = keys.length - 1;\n  for (var j = 0; j <= keysLastIndex; j++) {\n    var key = keys[j] === '' ? currentParams.length : keys[j];\n    if (j < keysLastIndex) {\n      var prevValue = !currentParams[key] || _typeof(currentParams[key]) === 'object' ? currentParams[key] : [currentParams[key]];\n      currentParams = currentParams[key] = prevValue || (isNaN(keys[j + 1]) ? {} : []);\n    } else {\n      currentParams = currentParams[key] = value;\n    }\n  }\n}\n\nfunction parseQueryString(queryString) {\n  var queryParams = {};\n  if (!queryString || typeof queryString !== 'string') {\n    return queryParams;\n  }\n\n  var query = queryString;\n  if (query.charAt(0) === '?') {\n    query = query.substr(1);\n  }\n\n  var pairs = query.replace(/\\+/g, ' ').split('&');\n  for (var i = 0; i < pairs.length; i++) {\n    var pair = pairs[i].split('=');\n    var key = decodeURIComponent(pair[0]);\n    if (!key) {\n      continue;\n    }\n\n    var keys = key.split('][');\n    var keysLastIndex = keys.length - 1;\n\n    if (/\\[/.test(keys[0]) && /\\]$/.test(keys[keysLastIndex])) {\n      keys[keysLastIndex] = keys[keysLastIndex].replace(/\\]$/, '');\n      keys = keys.shift().split('[').concat(keys);\n      keysLastIndex = keys.length - 1;\n    } else {\n      keysLastIndex = 0;\n    }\n\n    if (pair.length >= 2) {\n      var value = pair[1] ? decodeURIComponent(pair[1]) : '';\n      if (keysLastIndex) {\n        parseComplexParam(queryParams, keys, value);\n      } else {\n        queryParams[key] = processScalarParam(queryParams[key], value);\n      }\n    } else {\n      queryParams[key] = true;\n    }\n  }\n  return queryParams;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaUQzTy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLXBhdGgvZGlzdC9uYXRpdmUtbW9kdWxlcy9hdXJlbGlhLXBhdGguanM/ODgzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIHRyaW1Eb3RzKGFyeSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJ0ID0gYXJ5W2ldO1xuICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgIGFyeS5zcGxpY2UoaSwgMSk7XG4gICAgICBpIC09IDE7XG4gICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSAxICYmIGFyeVsyXSA9PT0gJy4uJyB8fCBhcnlbaSAtIDFdID09PSAnLi4nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChpID4gMCkge1xuICAgICAgICBhcnkuc3BsaWNlKGkgLSAxLCAyKTtcbiAgICAgICAgaSAtPSAyO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVsYXRpdmVUb0ZpbGUobmFtZSwgZmlsZSkge1xuICB2YXIgZmlsZVBhcnRzID0gZmlsZSAmJiBmaWxlLnNwbGl0KCcvJyk7XG4gIHZhciBuYW1lUGFydHMgPSBuYW1lLnRyaW0oKS5zcGxpdCgnLycpO1xuXG4gIGlmIChuYW1lUGFydHNbMF0uY2hhckF0KDApID09PSAnLicgJiYgZmlsZVBhcnRzKSB7XG4gICAgdmFyIG5vcm1hbGl6ZWRCYXNlUGFydHMgPSBmaWxlUGFydHMuc2xpY2UoMCwgZmlsZVBhcnRzLmxlbmd0aCAtIDEpO1xuICAgIG5hbWVQYXJ0cy51bnNoaWZ0LmFwcGx5KG5hbWVQYXJ0cywgbm9ybWFsaXplZEJhc2VQYXJ0cyk7XG4gIH1cblxuICB0cmltRG90cyhuYW1lUGFydHMpO1xuXG4gIHJldHVybiBuYW1lUGFydHMuam9pbignLycpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gam9pbihwYXRoMSwgcGF0aDIpIHtcbiAgaWYgKCFwYXRoMSkge1xuICAgIHJldHVybiBwYXRoMjtcbiAgfVxuXG4gIGlmICghcGF0aDIpIHtcbiAgICByZXR1cm4gcGF0aDE7XG4gIH1cblxuICB2YXIgc2NoZW1lTWF0Y2ggPSBwYXRoMS5tYXRjaCgvXihbXi9dKj86KVxcLy8pO1xuICB2YXIgc2NoZW1lID0gc2NoZW1lTWF0Y2ggJiYgc2NoZW1lTWF0Y2gubGVuZ3RoID4gMCA/IHNjaGVtZU1hdGNoWzFdIDogJyc7XG4gIHBhdGgxID0gcGF0aDEuc3Vic3RyKHNjaGVtZS5sZW5ndGgpO1xuXG4gIHZhciB1cmxQcmVmaXggPSB2b2lkIDA7XG4gIGlmIChwYXRoMS5pbmRleE9mKCcvLy8nKSA9PT0gMCAmJiBzY2hlbWUgPT09ICdmaWxlOicpIHtcbiAgICB1cmxQcmVmaXggPSAnLy8vJztcbiAgfSBlbHNlIGlmIChwYXRoMS5pbmRleE9mKCcvLycpID09PSAwKSB7XG4gICAgdXJsUHJlZml4ID0gJy8vJztcbiAgfSBlbHNlIGlmIChwYXRoMS5pbmRleE9mKCcvJykgPT09IDApIHtcbiAgICB1cmxQcmVmaXggPSAnLyc7XG4gIH0gZWxzZSB7XG4gICAgdXJsUHJlZml4ID0gJyc7XG4gIH1cblxuICB2YXIgdHJhaWxpbmdTbGFzaCA9IHBhdGgyLnNsaWNlKC0xKSA9PT0gJy8nID8gJy8nIDogJyc7XG5cbiAgdmFyIHVybDEgPSBwYXRoMS5zcGxpdCgnLycpO1xuICB2YXIgdXJsMiA9IHBhdGgyLnNwbGl0KCcvJyk7XG4gIHZhciB1cmwzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gdXJsMS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgaWYgKHVybDFbaV0gPT09ICcuLicpIHtcbiAgICAgIHVybDMucG9wKCk7XG4gICAgfSBlbHNlIGlmICh1cmwxW2ldID09PSAnLicgfHwgdXJsMVtpXSA9PT0gJycpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cmwzLnB1c2godXJsMVtpXSk7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX2kgPSAwLCBfaWkgPSB1cmwyLmxlbmd0aDsgX2kgPCBfaWk7ICsrX2kpIHtcbiAgICBpZiAodXJsMltfaV0gPT09ICcuLicpIHtcbiAgICAgIHVybDMucG9wKCk7XG4gICAgfSBlbHNlIGlmICh1cmwyW19pXSA9PT0gJy4nIHx8IHVybDJbX2ldID09PSAnJykge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVybDMucHVzaCh1cmwyW19pXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNjaGVtZSArIHVybFByZWZpeCArIHVybDMuam9pbignLycpICsgdHJhaWxpbmdTbGFzaDtcbn1cblxudmFyIGVuY29kZSA9IGVuY29kZVVSSUNvbXBvbmVudDtcbnZhciBlbmNvZGVLZXkgPSBmdW5jdGlvbiBlbmNvZGVLZXkoaykge1xuICByZXR1cm4gZW5jb2RlKGspLnJlcGxhY2UoJyUyNCcsICckJyk7XG59O1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtKGtleSwgdmFsdWUsIHRyYWRpdGlvbmFsKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodHJhZGl0aW9uYWwpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlS2V5KGtleSkgKyAnPScgKyBlbmNvZGUodmFsdWVbaV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhcnJheUtleSA9IGtleSArICdbJyArIChfdHlwZW9mKHZhbHVlW2ldKSA9PT0gJ29iamVjdCcgJiYgdmFsdWVbaV0gIT09IG51bGwgPyBpIDogJycpICsgJ10nO1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGJ1aWxkUGFyYW0oYXJyYXlLZXksIHZhbHVlW2ldKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkgPT09ICdvYmplY3QnICYmICF0cmFkaXRpb25hbCkge1xuICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiB2YWx1ZSkge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChidWlsZFBhcmFtKGtleSArICdbJyArIHByb3BlcnR5TmFtZSArICddJywgdmFsdWVbcHJvcGVydHlOYW1lXSkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucHVzaChlbmNvZGVLZXkoa2V5KSArICc9JyArIGVuY29kZSh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFF1ZXJ5U3RyaW5nKHBhcmFtcywgdHJhZGl0aW9uYWwpIHtcbiAgdmFyIHBhaXJzID0gW107XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocGFyYW1zIHx8IHt9KS5zb3J0KCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgcGFpcnMgPSBwYWlycy5jb25jYXQoYnVpbGRQYXJhbShrZXksIHBhcmFtc1trZXldLCB0cmFkaXRpb25hbCkpO1xuICB9XG5cbiAgaWYgKHBhaXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiBwYWlycy5qb2luKCcmJyk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NTY2FsYXJQYXJhbShleGlzdGVkUGFyYW0sIHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4aXN0ZWRQYXJhbSkpIHtcbiAgICBleGlzdGVkUGFyYW0ucHVzaCh2YWx1ZSk7XG4gICAgcmV0dXJuIGV4aXN0ZWRQYXJhbTtcbiAgfVxuICBpZiAoZXhpc3RlZFBhcmFtICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gW2V4aXN0ZWRQYXJhbSwgdmFsdWVdO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNvbXBsZXhQYXJhbShxdWVyeVBhcmFtcywga2V5cywgdmFsdWUpIHtcbiAgdmFyIGN1cnJlbnRQYXJhbXMgPSBxdWVyeVBhcmFtcztcbiAgdmFyIGtleXNMYXN0SW5kZXggPSBrZXlzLmxlbmd0aCAtIDE7XG4gIGZvciAodmFyIGogPSAwOyBqIDw9IGtleXNMYXN0SW5kZXg7IGorKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2pdID09PSAnJyA/IGN1cnJlbnRQYXJhbXMubGVuZ3RoIDoga2V5c1tqXTtcbiAgICBpZiAoaiA8IGtleXNMYXN0SW5kZXgpIHtcbiAgICAgIHZhciBwcmV2VmFsdWUgPSAhY3VycmVudFBhcmFtc1trZXldIHx8IF90eXBlb2YoY3VycmVudFBhcmFtc1trZXldKSA9PT0gJ29iamVjdCcgPyBjdXJyZW50UGFyYW1zW2tleV0gOiBbY3VycmVudFBhcmFtc1trZXldXTtcbiAgICAgIGN1cnJlbnRQYXJhbXMgPSBjdXJyZW50UGFyYW1zW2tleV0gPSBwcmV2VmFsdWUgfHwgKGlzTmFOKGtleXNbaiArIDFdKSA/IHt9IDogW10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50UGFyYW1zID0gY3VycmVudFBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nKHF1ZXJ5U3RyaW5nKSB7XG4gIHZhciBxdWVyeVBhcmFtcyA9IHt9O1xuICBpZiAoIXF1ZXJ5U3RyaW5nIHx8IHR5cGVvZiBxdWVyeVN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcXVlcnlQYXJhbXM7XG4gIH1cblxuICB2YXIgcXVlcnkgPSBxdWVyeVN0cmluZztcbiAgaWYgKHF1ZXJ5LmNoYXJBdCgwKSA9PT0gJz8nKSB7XG4gICAgcXVlcnkgPSBxdWVyeS5zdWJzdHIoMSk7XG4gIH1cblxuICB2YXIgcGFpcnMgPSBxdWVyeS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnJicpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhaXIgPSBwYWlyc1tpXS5zcGxpdCgnPScpO1xuICAgIHZhciBrZXkgPSBkZWNvZGVVUklDb21wb25lbnQocGFpclswXSk7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0ga2V5LnNwbGl0KCddWycpO1xuICAgIHZhciBrZXlzTGFzdEluZGV4ID0ga2V5cy5sZW5ndGggLSAxO1xuXG4gICAgaWYgKC9cXFsvLnRlc3Qoa2V5c1swXSkgJiYgL1xcXSQvLnRlc3Qoa2V5c1trZXlzTGFzdEluZGV4XSkpIHtcbiAgICAgIGtleXNba2V5c0xhc3RJbmRleF0gPSBrZXlzW2tleXNMYXN0SW5kZXhdLnJlcGxhY2UoL1xcXSQvLCAnJyk7XG4gICAgICBrZXlzID0ga2V5cy5zaGlmdCgpLnNwbGl0KCdbJykuY29uY2F0KGtleXMpO1xuICAgICAga2V5c0xhc3RJbmRleCA9IGtleXMubGVuZ3RoIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5c0xhc3RJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBhaXIubGVuZ3RoID49IDIpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHBhaXJbMV0gPyBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSkgOiAnJztcbiAgICAgIGlmIChrZXlzTGFzdEluZGV4KSB7XG4gICAgICAgIHBhcnNlQ29tcGxleFBhcmFtKHF1ZXJ5UGFyYW1zLCBrZXlzLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeVBhcmFtc1trZXldID0gcHJvY2Vzc1NjYWxhclBhcmFtKHF1ZXJ5UGFyYW1zW2tleV0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnlQYXJhbXNba2V5XSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBxdWVyeVBhcmFtcztcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///iD3O\n");

/***/ })

}]);